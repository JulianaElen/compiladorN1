Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> block
Rule 2     block -> LBRACE declaration statements RBRACE
Rule 3     declaration -> type ID SEMICOLON declaration
Rule 4     declaration -> empty
Rule 5     type -> basic dimensions
Rule 6     type -> basic HASH
Rule 7     type -> basic
Rule 8     type -> RECORD LBRACE declaration RBRACE
Rule 9     dimensions -> LBRACK NUMBER_INT RBRACK dimensions
Rule 10    dimensions -> LBRACK NUMBER_INT RBRACK
Rule 11    basic -> INT
Rule 12    basic -> CHAR
Rule 13    basic -> BOOL
Rule 14    statements -> statement statements
Rule 15    statements -> empty
Rule 16    statement -> local EQUALS boolean SEMICOLON
Rule 17    statement -> conditional
Rule 18    statement -> while_loop
Rule 19    statement -> do_while_loop
Rule 20    statement -> BREAK SEMICOLON
Rule 21    statement -> print
Rule 22    statement -> read
Rule 23    statement -> block
Rule 24    print -> PRINT LPAREN boolean RPAREN SEMICOLON
Rule 25    read -> READ LPAREN local RPAREN SEMICOLON
Rule 26    conditional -> IF LPAREN boolean RPAREN statement conditional_aux
Rule 27    conditional_aux -> ELSE statement
Rule 28    conditional_aux -> empty
Rule 29    while_loop -> WHILE LPAREN boolean RPAREN statement
Rule 30    do_while_loop -> DO statement WHILE LPAREN boolean RPAREN SEMICOLON
Rule 31    local -> ID
Rule 32    local -> HASH ID
Rule 33    local -> ID local_aux
Rule 34    local -> HASH ID local_aux
Rule 35    local_aux -> offset
Rule 36    local_aux -> field
Rule 37    offset -> LBRACK boolean RBRACK offset
Rule 38    offset -> empty
Rule 39    field -> DOT factor field
Rule 40    field -> DOT factor
Rule 41    boolean -> join
Rule 42    boolean -> boolean OR join
Rule 43    join -> equality
Rule 44    join -> join AND equality
Rule 45    equality -> relational
Rule 46    equality -> equality EQ relational
Rule 47    equality -> equality NEQ relational
Rule 48    relational -> expression
Rule 49    relational -> relational_operator expression
Rule 50    relational_operator -> LT
Rule 51    relational_operator -> LE
Rule 52    relational_operator -> GT
Rule 53    relational_operator -> GE
Rule 54    expression -> term
Rule 55    expression -> expression expression_operator term
Rule 56    expression_operator -> PLUS
Rule 57    expression_operator -> MINUS
Rule 58    term -> unary
Rule 59    term -> term TIMES unary
Rule 60    term -> term DIVIDE unary
Rule 61    unary -> NOT unary
Rule 62    unary -> NEG unary
Rule 63    unary -> factor
Rule 64    factor -> LPAREN boolean RPAREN
Rule 65    factor -> local
Rule 66    factor -> NUMBER_INT
Rule 67    factor -> NUMBER_FLOAT
Rule 68    factor -> FALSE
Rule 69    factor -> TRUE
Rule 70    empty -> <empty>

Terminals, with rules where they appear

AND                  : 44
BOOL                 : 13
BREAK                : 20
CHAR                 : 12
DIVIDE               : 60
DO                   : 30
DOT                  : 39 40
ELSE                 : 27
EQ                   : 46
EQUALS               : 16
FALSE                : 68
GE                   : 53
GT                   : 52
HASH                 : 6 32 34
ID                   : 3 31 32 33 34
IF                   : 26
INT                  : 11
LBRACE               : 2 8
LBRACK               : 9 10 37
LE                   : 51
LPAREN               : 24 25 26 29 30 64
LT                   : 50
MINUS                : 57
NEG                  : 62
NEQ                  : 47
NOT                  : 61
NUMBER_FLOAT         : 67
NUMBER_INT           : 9 10 66
OR                   : 42
PLUS                 : 56
PRINT                : 24
RBRACE               : 2 8
RBRACK               : 9 10 37
READ                 : 25
RECORD               : 8
RPAREN               : 24 25 26 29 30 64
SEMICOLON            : 3 16 20 24 25 30
TIMES                : 59
TRUE                 : 69
WHILE                : 29 30
error                : 

Nonterminals, with rules where they appear

basic                : 5 6 7
block                : 1 23
boolean              : 16 24 26 29 30 37 42 64
conditional          : 17
conditional_aux      : 26
declaration          : 2 3 8
dimensions           : 5 9
do_while_loop        : 19
empty                : 4 15 28 38
equality             : 43 44 46 47
expression           : 48 49 55
expression_operator  : 55
factor               : 39 40 63
field                : 36 39
join                 : 41 42 44
local                : 16 25 65
local_aux            : 33 34
offset               : 35 37
print                : 21
program              : 0
read                 : 22
relational           : 45 46 47
relational_operator  : 49
statement            : 14 26 27 29 30
statements           : 2 14
term                 : 54 55 59 60
type                 : 3
unary                : 58 59 60 61 62
while_loop           : 18

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . block
    (2) block -> . LBRACE declaration statements RBRACE

    LBRACE          shift and go to state 3

    program                        shift and go to state 1
    block                          shift and go to state 2

state 1

    (0) S' -> program .



state 2

    (1) program -> block .

    $end            reduce using rule 1 (program -> block .)


state 3

    (2) block -> LBRACE . declaration statements RBRACE
    (3) declaration -> . type ID SEMICOLON declaration
    (4) declaration -> . empty
    (5) type -> . basic dimensions
    (6) type -> . basic HASH
    (7) type -> . basic
    (8) type -> . RECORD LBRACE declaration RBRACE
    (70) empty -> .
    (11) basic -> . INT
    (12) basic -> . CHAR
    (13) basic -> . BOOL

    RECORD          shift and go to state 8
    BREAK           reduce using rule 70 (empty -> .)
    ID              reduce using rule 70 (empty -> .)
    HASH            reduce using rule 70 (empty -> .)
    IF              reduce using rule 70 (empty -> .)
    WHILE           reduce using rule 70 (empty -> .)
    DO              reduce using rule 70 (empty -> .)
    PRINT           reduce using rule 70 (empty -> .)
    READ            reduce using rule 70 (empty -> .)
    LBRACE          reduce using rule 70 (empty -> .)
    RBRACE          reduce using rule 70 (empty -> .)
    INT             shift and go to state 9
    CHAR            shift and go to state 10
    BOOL            shift and go to state 11

    declaration                    shift and go to state 4
    type                           shift and go to state 5
    empty                          shift and go to state 6
    basic                          shift and go to state 7

state 4

    (2) block -> LBRACE declaration . statements RBRACE
    (14) statements -> . statement statements
    (15) statements -> . empty
    (16) statement -> . local EQUALS boolean SEMICOLON
    (17) statement -> . conditional
    (18) statement -> . while_loop
    (19) statement -> . do_while_loop
    (20) statement -> . BREAK SEMICOLON
    (21) statement -> . print
    (22) statement -> . read
    (23) statement -> . block
    (70) empty -> .
    (31) local -> . ID
    (32) local -> . HASH ID
    (33) local -> . ID local_aux
    (34) local -> . HASH ID local_aux
    (26) conditional -> . IF LPAREN boolean RPAREN statement conditional_aux
    (29) while_loop -> . WHILE LPAREN boolean RPAREN statement
    (30) do_while_loop -> . DO statement WHILE LPAREN boolean RPAREN SEMICOLON
    (24) print -> . PRINT LPAREN boolean RPAREN SEMICOLON
    (25) read -> . READ LPAREN local RPAREN SEMICOLON
    (2) block -> . LBRACE declaration statements RBRACE

    BREAK           shift and go to state 19
    RBRACE          reduce using rule 70 (empty -> .)
    ID              shift and go to state 23
    HASH            shift and go to state 24
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    DO              shift and go to state 27
    PRINT           shift and go to state 28
    READ            shift and go to state 29
    LBRACE          shift and go to state 3

    statements                     shift and go to state 12
    statement                      shift and go to state 13
    empty                          shift and go to state 14
    local                          shift and go to state 15
    conditional                    shift and go to state 16
    while_loop                     shift and go to state 17
    do_while_loop                  shift and go to state 18
    print                          shift and go to state 20
    read                           shift and go to state 21
    block                          shift and go to state 22

state 5

    (3) declaration -> type . ID SEMICOLON declaration

    ID              shift and go to state 30


state 6

    (4) declaration -> empty .

    BREAK           reduce using rule 4 (declaration -> empty .)
    ID              reduce using rule 4 (declaration -> empty .)
    HASH            reduce using rule 4 (declaration -> empty .)
    IF              reduce using rule 4 (declaration -> empty .)
    WHILE           reduce using rule 4 (declaration -> empty .)
    DO              reduce using rule 4 (declaration -> empty .)
    PRINT           reduce using rule 4 (declaration -> empty .)
    READ            reduce using rule 4 (declaration -> empty .)
    LBRACE          reduce using rule 4 (declaration -> empty .)
    RBRACE          reduce using rule 4 (declaration -> empty .)


state 7

    (5) type -> basic . dimensions
    (6) type -> basic . HASH
    (7) type -> basic .
    (9) dimensions -> . LBRACK NUMBER_INT RBRACK dimensions
    (10) dimensions -> . LBRACK NUMBER_INT RBRACK

    HASH            shift and go to state 32
    ID              reduce using rule 7 (type -> basic .)
    LBRACK          shift and go to state 33

    dimensions                     shift and go to state 31

state 8

    (8) type -> RECORD . LBRACE declaration RBRACE

    LBRACE          shift and go to state 34


state 9

    (11) basic -> INT .

    HASH            reduce using rule 11 (basic -> INT .)
    LBRACK          reduce using rule 11 (basic -> INT .)
    ID              reduce using rule 11 (basic -> INT .)


state 10

    (12) basic -> CHAR .

    HASH            reduce using rule 12 (basic -> CHAR .)
    LBRACK          reduce using rule 12 (basic -> CHAR .)
    ID              reduce using rule 12 (basic -> CHAR .)


state 11

    (13) basic -> BOOL .

    HASH            reduce using rule 13 (basic -> BOOL .)
    LBRACK          reduce using rule 13 (basic -> BOOL .)
    ID              reduce using rule 13 (basic -> BOOL .)


state 12

    (2) block -> LBRACE declaration statements . RBRACE

    RBRACE          shift and go to state 35


state 13

    (14) statements -> statement . statements
    (14) statements -> . statement statements
    (15) statements -> . empty
    (16) statement -> . local EQUALS boolean SEMICOLON
    (17) statement -> . conditional
    (18) statement -> . while_loop
    (19) statement -> . do_while_loop
    (20) statement -> . BREAK SEMICOLON
    (21) statement -> . print
    (22) statement -> . read
    (23) statement -> . block
    (70) empty -> .
    (31) local -> . ID
    (32) local -> . HASH ID
    (33) local -> . ID local_aux
    (34) local -> . HASH ID local_aux
    (26) conditional -> . IF LPAREN boolean RPAREN statement conditional_aux
    (29) while_loop -> . WHILE LPAREN boolean RPAREN statement
    (30) do_while_loop -> . DO statement WHILE LPAREN boolean RPAREN SEMICOLON
    (24) print -> . PRINT LPAREN boolean RPAREN SEMICOLON
    (25) read -> . READ LPAREN local RPAREN SEMICOLON
    (2) block -> . LBRACE declaration statements RBRACE

    BREAK           shift and go to state 19
    RBRACE          reduce using rule 70 (empty -> .)
    ID              shift and go to state 23
    HASH            shift and go to state 24
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    DO              shift and go to state 27
    PRINT           shift and go to state 28
    READ            shift and go to state 29
    LBRACE          shift and go to state 3

    statement                      shift and go to state 13
    statements                     shift and go to state 36
    empty                          shift and go to state 14
    local                          shift and go to state 15
    conditional                    shift and go to state 16
    while_loop                     shift and go to state 17
    do_while_loop                  shift and go to state 18
    print                          shift and go to state 20
    read                           shift and go to state 21
    block                          shift and go to state 22

state 14

    (15) statements -> empty .

    RBRACE          reduce using rule 15 (statements -> empty .)


state 15

    (16) statement -> local . EQUALS boolean SEMICOLON

    EQUALS          shift and go to state 37


state 16

    (17) statement -> conditional .

    BREAK           reduce using rule 17 (statement -> conditional .)
    ID              reduce using rule 17 (statement -> conditional .)
    HASH            reduce using rule 17 (statement -> conditional .)
    IF              reduce using rule 17 (statement -> conditional .)
    WHILE           reduce using rule 17 (statement -> conditional .)
    DO              reduce using rule 17 (statement -> conditional .)
    PRINT           reduce using rule 17 (statement -> conditional .)
    READ            reduce using rule 17 (statement -> conditional .)
    LBRACE          reduce using rule 17 (statement -> conditional .)
    RBRACE          reduce using rule 17 (statement -> conditional .)
    ELSE            reduce using rule 17 (statement -> conditional .)


state 17

    (18) statement -> while_loop .

    BREAK           reduce using rule 18 (statement -> while_loop .)
    ID              reduce using rule 18 (statement -> while_loop .)
    HASH            reduce using rule 18 (statement -> while_loop .)
    IF              reduce using rule 18 (statement -> while_loop .)
    WHILE           reduce using rule 18 (statement -> while_loop .)
    DO              reduce using rule 18 (statement -> while_loop .)
    PRINT           reduce using rule 18 (statement -> while_loop .)
    READ            reduce using rule 18 (statement -> while_loop .)
    LBRACE          reduce using rule 18 (statement -> while_loop .)
    RBRACE          reduce using rule 18 (statement -> while_loop .)
    ELSE            reduce using rule 18 (statement -> while_loop .)


state 18

    (19) statement -> do_while_loop .

    BREAK           reduce using rule 19 (statement -> do_while_loop .)
    ID              reduce using rule 19 (statement -> do_while_loop .)
    HASH            reduce using rule 19 (statement -> do_while_loop .)
    IF              reduce using rule 19 (statement -> do_while_loop .)
    WHILE           reduce using rule 19 (statement -> do_while_loop .)
    DO              reduce using rule 19 (statement -> do_while_loop .)
    PRINT           reduce using rule 19 (statement -> do_while_loop .)
    READ            reduce using rule 19 (statement -> do_while_loop .)
    LBRACE          reduce using rule 19 (statement -> do_while_loop .)
    RBRACE          reduce using rule 19 (statement -> do_while_loop .)
    ELSE            reduce using rule 19 (statement -> do_while_loop .)


state 19

    (20) statement -> BREAK . SEMICOLON

    SEMICOLON       shift and go to state 38


state 20

    (21) statement -> print .

    BREAK           reduce using rule 21 (statement -> print .)
    ID              reduce using rule 21 (statement -> print .)
    HASH            reduce using rule 21 (statement -> print .)
    IF              reduce using rule 21 (statement -> print .)
    WHILE           reduce using rule 21 (statement -> print .)
    DO              reduce using rule 21 (statement -> print .)
    PRINT           reduce using rule 21 (statement -> print .)
    READ            reduce using rule 21 (statement -> print .)
    LBRACE          reduce using rule 21 (statement -> print .)
    RBRACE          reduce using rule 21 (statement -> print .)
    ELSE            reduce using rule 21 (statement -> print .)


state 21

    (22) statement -> read .

    BREAK           reduce using rule 22 (statement -> read .)
    ID              reduce using rule 22 (statement -> read .)
    HASH            reduce using rule 22 (statement -> read .)
    IF              reduce using rule 22 (statement -> read .)
    WHILE           reduce using rule 22 (statement -> read .)
    DO              reduce using rule 22 (statement -> read .)
    PRINT           reduce using rule 22 (statement -> read .)
    READ            reduce using rule 22 (statement -> read .)
    LBRACE          reduce using rule 22 (statement -> read .)
    RBRACE          reduce using rule 22 (statement -> read .)
    ELSE            reduce using rule 22 (statement -> read .)


state 22

    (23) statement -> block .

    BREAK           reduce using rule 23 (statement -> block .)
    ID              reduce using rule 23 (statement -> block .)
    HASH            reduce using rule 23 (statement -> block .)
    IF              reduce using rule 23 (statement -> block .)
    WHILE           reduce using rule 23 (statement -> block .)
    DO              reduce using rule 23 (statement -> block .)
    PRINT           reduce using rule 23 (statement -> block .)
    READ            reduce using rule 23 (statement -> block .)
    LBRACE          reduce using rule 23 (statement -> block .)
    RBRACE          reduce using rule 23 (statement -> block .)
    ELSE            reduce using rule 23 (statement -> block .)


state 23

    (31) local -> ID .
    (33) local -> ID . local_aux
    (35) local_aux -> . offset
    (36) local_aux -> . field
    (37) offset -> . LBRACK boolean RBRACK offset
    (38) offset -> . empty
    (39) field -> . DOT factor field
    (40) field -> . DOT factor
    (70) empty -> .

  ! shift/reduce conflict for DOT resolved as shift
  ! reduce/reduce conflict for EQUALS resolved using rule 31 (local -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 31 (local -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 31 (local -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 31 (local -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 31 (local -> ID .)
  ! reduce/reduce conflict for EQ resolved using rule 31 (local -> ID .)
  ! reduce/reduce conflict for NEQ resolved using rule 31 (local -> ID .)
  ! reduce/reduce conflict for AND resolved using rule 31 (local -> ID .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 31 (local -> ID .)
  ! reduce/reduce conflict for OR resolved using rule 31 (local -> ID .)
  ! reduce/reduce conflict for RBRACK resolved using rule 31 (local -> ID .)
  ! shift/reduce conflict for DOT resolved as shift
  ! reduce/reduce conflict for RPAREN resolved using rule 31 (local -> ID .)
    EQUALS          reduce using rule 31 (local -> ID .)
    TIMES           reduce using rule 31 (local -> ID .)
    DIVIDE          reduce using rule 31 (local -> ID .)
    PLUS            reduce using rule 31 (local -> ID .)
    MINUS           reduce using rule 31 (local -> ID .)
    EQ              reduce using rule 31 (local -> ID .)
    NEQ             reduce using rule 31 (local -> ID .)
    AND             reduce using rule 31 (local -> ID .)
    SEMICOLON       reduce using rule 31 (local -> ID .)
    OR              reduce using rule 31 (local -> ID .)
    RBRACK          reduce using rule 31 (local -> ID .)
    RPAREN          reduce using rule 31 (local -> ID .)
    LBRACK          shift and go to state 42
    DOT             shift and go to state 44

  ! DOT             [ reduce using rule 31 (local -> ID .) ]
  ! EQUALS          [ reduce using rule 70 (empty -> .) ]
  ! TIMES           [ reduce using rule 70 (empty -> .) ]
  ! DIVIDE          [ reduce using rule 70 (empty -> .) ]
  ! PLUS            [ reduce using rule 70 (empty -> .) ]
  ! MINUS           [ reduce using rule 70 (empty -> .) ]
  ! EQ              [ reduce using rule 70 (empty -> .) ]
  ! NEQ             [ reduce using rule 70 (empty -> .) ]
  ! AND             [ reduce using rule 70 (empty -> .) ]
  ! SEMICOLON       [ reduce using rule 70 (empty -> .) ]
  ! OR              [ reduce using rule 70 (empty -> .) ]
  ! RBRACK          [ reduce using rule 70 (empty -> .) ]
  ! DOT             [ reduce using rule 70 (empty -> .) ]
  ! RPAREN          [ reduce using rule 70 (empty -> .) ]

    local_aux                      shift and go to state 39
    offset                         shift and go to state 40
    field                          shift and go to state 41
    empty                          shift and go to state 43

state 24

    (32) local -> HASH . ID
    (34) local -> HASH . ID local_aux

    ID              shift and go to state 45


state 25

    (26) conditional -> IF . LPAREN boolean RPAREN statement conditional_aux

    LPAREN          shift and go to state 46


state 26

    (29) while_loop -> WHILE . LPAREN boolean RPAREN statement

    LPAREN          shift and go to state 47


state 27

    (30) do_while_loop -> DO . statement WHILE LPAREN boolean RPAREN SEMICOLON
    (16) statement -> . local EQUALS boolean SEMICOLON
    (17) statement -> . conditional
    (18) statement -> . while_loop
    (19) statement -> . do_while_loop
    (20) statement -> . BREAK SEMICOLON
    (21) statement -> . print
    (22) statement -> . read
    (23) statement -> . block
    (31) local -> . ID
    (32) local -> . HASH ID
    (33) local -> . ID local_aux
    (34) local -> . HASH ID local_aux
    (26) conditional -> . IF LPAREN boolean RPAREN statement conditional_aux
    (29) while_loop -> . WHILE LPAREN boolean RPAREN statement
    (30) do_while_loop -> . DO statement WHILE LPAREN boolean RPAREN SEMICOLON
    (24) print -> . PRINT LPAREN boolean RPAREN SEMICOLON
    (25) read -> . READ LPAREN local RPAREN SEMICOLON
    (2) block -> . LBRACE declaration statements RBRACE

    BREAK           shift and go to state 19
    ID              shift and go to state 23
    HASH            shift and go to state 24
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    DO              shift and go to state 27
    PRINT           shift and go to state 28
    READ            shift and go to state 29
    LBRACE          shift and go to state 3

    statement                      shift and go to state 48
    local                          shift and go to state 15
    conditional                    shift and go to state 16
    while_loop                     shift and go to state 17
    do_while_loop                  shift and go to state 18
    print                          shift and go to state 20
    read                           shift and go to state 21
    block                          shift and go to state 22

state 28

    (24) print -> PRINT . LPAREN boolean RPAREN SEMICOLON

    LPAREN          shift and go to state 49


state 29

    (25) read -> READ . LPAREN local RPAREN SEMICOLON

    LPAREN          shift and go to state 50


state 30

    (3) declaration -> type ID . SEMICOLON declaration

    SEMICOLON       shift and go to state 51


state 31

    (5) type -> basic dimensions .

    ID              reduce using rule 5 (type -> basic dimensions .)


state 32

    (6) type -> basic HASH .

    ID              reduce using rule 6 (type -> basic HASH .)


state 33

    (9) dimensions -> LBRACK . NUMBER_INT RBRACK dimensions
    (10) dimensions -> LBRACK . NUMBER_INT RBRACK

    NUMBER_INT      shift and go to state 52


state 34

    (8) type -> RECORD LBRACE . declaration RBRACE
    (3) declaration -> . type ID SEMICOLON declaration
    (4) declaration -> . empty
    (5) type -> . basic dimensions
    (6) type -> . basic HASH
    (7) type -> . basic
    (8) type -> . RECORD LBRACE declaration RBRACE
    (70) empty -> .
    (11) basic -> . INT
    (12) basic -> . CHAR
    (13) basic -> . BOOL

    RECORD          shift and go to state 8
    RBRACE          reduce using rule 70 (empty -> .)
    INT             shift and go to state 9
    CHAR            shift and go to state 10
    BOOL            shift and go to state 11

    declaration                    shift and go to state 53
    type                           shift and go to state 5
    empty                          shift and go to state 6
    basic                          shift and go to state 7

state 35

    (2) block -> LBRACE declaration statements RBRACE .

    $end            reduce using rule 2 (block -> LBRACE declaration statements RBRACE .)
    BREAK           reduce using rule 2 (block -> LBRACE declaration statements RBRACE .)
    ID              reduce using rule 2 (block -> LBRACE declaration statements RBRACE .)
    HASH            reduce using rule 2 (block -> LBRACE declaration statements RBRACE .)
    IF              reduce using rule 2 (block -> LBRACE declaration statements RBRACE .)
    WHILE           reduce using rule 2 (block -> LBRACE declaration statements RBRACE .)
    DO              reduce using rule 2 (block -> LBRACE declaration statements RBRACE .)
    PRINT           reduce using rule 2 (block -> LBRACE declaration statements RBRACE .)
    READ            reduce using rule 2 (block -> LBRACE declaration statements RBRACE .)
    LBRACE          reduce using rule 2 (block -> LBRACE declaration statements RBRACE .)
    RBRACE          reduce using rule 2 (block -> LBRACE declaration statements RBRACE .)
    ELSE            reduce using rule 2 (block -> LBRACE declaration statements RBRACE .)


state 36

    (14) statements -> statement statements .

    RBRACE          reduce using rule 14 (statements -> statement statements .)


state 37

    (16) statement -> local EQUALS . boolean SEMICOLON
    (41) boolean -> . join
    (42) boolean -> . boolean OR join
    (43) join -> . equality
    (44) join -> . join AND equality
    (45) equality -> . relational
    (46) equality -> . equality EQ relational
    (47) equality -> . equality NEQ relational
    (48) relational -> . expression
    (49) relational -> . relational_operator expression
    (54) expression -> . term
    (55) expression -> . expression expression_operator term
    (50) relational_operator -> . LT
    (51) relational_operator -> . LE
    (52) relational_operator -> . GT
    (53) relational_operator -> . GE
    (58) term -> . unary
    (59) term -> . term TIMES unary
    (60) term -> . term DIVIDE unary
    (61) unary -> . NOT unary
    (62) unary -> . NEG unary
    (63) unary -> . factor
    (64) factor -> . LPAREN boolean RPAREN
    (65) factor -> . local
    (66) factor -> . NUMBER_INT
    (67) factor -> . NUMBER_FLOAT
    (68) factor -> . FALSE
    (69) factor -> . TRUE
    (31) local -> . ID
    (32) local -> . HASH ID
    (33) local -> . ID local_aux
    (34) local -> . HASH ID local_aux

    LT              shift and go to state 62
    LE              shift and go to state 63
    GT              shift and go to state 64
    GE              shift and go to state 65
    NOT             shift and go to state 67
    NEG             shift and go to state 68
    LPAREN          shift and go to state 70
    NUMBER_INT      shift and go to state 71
    NUMBER_FLOAT    shift and go to state 72
    FALSE           shift and go to state 73
    TRUE            shift and go to state 74
    ID              shift and go to state 23
    HASH            shift and go to state 24

    local                          shift and go to state 54
    boolean                        shift and go to state 55
    join                           shift and go to state 56
    equality                       shift and go to state 57
    relational                     shift and go to state 58
    expression                     shift and go to state 59
    relational_operator            shift and go to state 60
    term                           shift and go to state 61
    unary                          shift and go to state 66
    factor                         shift and go to state 69

state 38

    (20) statement -> BREAK SEMICOLON .

    BREAK           reduce using rule 20 (statement -> BREAK SEMICOLON .)
    ID              reduce using rule 20 (statement -> BREAK SEMICOLON .)
    HASH            reduce using rule 20 (statement -> BREAK SEMICOLON .)
    IF              reduce using rule 20 (statement -> BREAK SEMICOLON .)
    WHILE           reduce using rule 20 (statement -> BREAK SEMICOLON .)
    DO              reduce using rule 20 (statement -> BREAK SEMICOLON .)
    PRINT           reduce using rule 20 (statement -> BREAK SEMICOLON .)
    READ            reduce using rule 20 (statement -> BREAK SEMICOLON .)
    LBRACE          reduce using rule 20 (statement -> BREAK SEMICOLON .)
    RBRACE          reduce using rule 20 (statement -> BREAK SEMICOLON .)
    ELSE            reduce using rule 20 (statement -> BREAK SEMICOLON .)


state 39

    (33) local -> ID local_aux .

    EQUALS          reduce using rule 33 (local -> ID local_aux .)
    TIMES           reduce using rule 33 (local -> ID local_aux .)
    DIVIDE          reduce using rule 33 (local -> ID local_aux .)
    PLUS            reduce using rule 33 (local -> ID local_aux .)
    MINUS           reduce using rule 33 (local -> ID local_aux .)
    EQ              reduce using rule 33 (local -> ID local_aux .)
    NEQ             reduce using rule 33 (local -> ID local_aux .)
    AND             reduce using rule 33 (local -> ID local_aux .)
    SEMICOLON       reduce using rule 33 (local -> ID local_aux .)
    OR              reduce using rule 33 (local -> ID local_aux .)
    RBRACK          reduce using rule 33 (local -> ID local_aux .)
    DOT             reduce using rule 33 (local -> ID local_aux .)
    RPAREN          reduce using rule 33 (local -> ID local_aux .)


state 40

    (35) local_aux -> offset .

    EQUALS          reduce using rule 35 (local_aux -> offset .)
    TIMES           reduce using rule 35 (local_aux -> offset .)
    DIVIDE          reduce using rule 35 (local_aux -> offset .)
    PLUS            reduce using rule 35 (local_aux -> offset .)
    MINUS           reduce using rule 35 (local_aux -> offset .)
    EQ              reduce using rule 35 (local_aux -> offset .)
    NEQ             reduce using rule 35 (local_aux -> offset .)
    AND             reduce using rule 35 (local_aux -> offset .)
    SEMICOLON       reduce using rule 35 (local_aux -> offset .)
    OR              reduce using rule 35 (local_aux -> offset .)
    RBRACK          reduce using rule 35 (local_aux -> offset .)
    DOT             reduce using rule 35 (local_aux -> offset .)
    RPAREN          reduce using rule 35 (local_aux -> offset .)


state 41

    (36) local_aux -> field .

    EQUALS          reduce using rule 36 (local_aux -> field .)
    TIMES           reduce using rule 36 (local_aux -> field .)
    DIVIDE          reduce using rule 36 (local_aux -> field .)
    PLUS            reduce using rule 36 (local_aux -> field .)
    MINUS           reduce using rule 36 (local_aux -> field .)
    EQ              reduce using rule 36 (local_aux -> field .)
    NEQ             reduce using rule 36 (local_aux -> field .)
    AND             reduce using rule 36 (local_aux -> field .)
    SEMICOLON       reduce using rule 36 (local_aux -> field .)
    OR              reduce using rule 36 (local_aux -> field .)
    RBRACK          reduce using rule 36 (local_aux -> field .)
    DOT             reduce using rule 36 (local_aux -> field .)
    RPAREN          reduce using rule 36 (local_aux -> field .)


state 42

    (37) offset -> LBRACK . boolean RBRACK offset
    (41) boolean -> . join
    (42) boolean -> . boolean OR join
    (43) join -> . equality
    (44) join -> . join AND equality
    (45) equality -> . relational
    (46) equality -> . equality EQ relational
    (47) equality -> . equality NEQ relational
    (48) relational -> . expression
    (49) relational -> . relational_operator expression
    (54) expression -> . term
    (55) expression -> . expression expression_operator term
    (50) relational_operator -> . LT
    (51) relational_operator -> . LE
    (52) relational_operator -> . GT
    (53) relational_operator -> . GE
    (58) term -> . unary
    (59) term -> . term TIMES unary
    (60) term -> . term DIVIDE unary
    (61) unary -> . NOT unary
    (62) unary -> . NEG unary
    (63) unary -> . factor
    (64) factor -> . LPAREN boolean RPAREN
    (65) factor -> . local
    (66) factor -> . NUMBER_INT
    (67) factor -> . NUMBER_FLOAT
    (68) factor -> . FALSE
    (69) factor -> . TRUE
    (31) local -> . ID
    (32) local -> . HASH ID
    (33) local -> . ID local_aux
    (34) local -> . HASH ID local_aux

    LT              shift and go to state 62
    LE              shift and go to state 63
    GT              shift and go to state 64
    GE              shift and go to state 65
    NOT             shift and go to state 67
    NEG             shift and go to state 68
    LPAREN          shift and go to state 70
    NUMBER_INT      shift and go to state 71
    NUMBER_FLOAT    shift and go to state 72
    FALSE           shift and go to state 73
    TRUE            shift and go to state 74
    ID              shift and go to state 23
    HASH            shift and go to state 24

    boolean                        shift and go to state 75
    join                           shift and go to state 56
    equality                       shift and go to state 57
    relational                     shift and go to state 58
    expression                     shift and go to state 59
    relational_operator            shift and go to state 60
    term                           shift and go to state 61
    unary                          shift and go to state 66
    factor                         shift and go to state 69
    local                          shift and go to state 54

state 43

    (38) offset -> empty .

    EQUALS          reduce using rule 38 (offset -> empty .)
    TIMES           reduce using rule 38 (offset -> empty .)
    DIVIDE          reduce using rule 38 (offset -> empty .)
    PLUS            reduce using rule 38 (offset -> empty .)
    MINUS           reduce using rule 38 (offset -> empty .)
    EQ              reduce using rule 38 (offset -> empty .)
    NEQ             reduce using rule 38 (offset -> empty .)
    AND             reduce using rule 38 (offset -> empty .)
    SEMICOLON       reduce using rule 38 (offset -> empty .)
    OR              reduce using rule 38 (offset -> empty .)
    RBRACK          reduce using rule 38 (offset -> empty .)
    DOT             reduce using rule 38 (offset -> empty .)
    RPAREN          reduce using rule 38 (offset -> empty .)


state 44

    (39) field -> DOT . factor field
    (40) field -> DOT . factor
    (64) factor -> . LPAREN boolean RPAREN
    (65) factor -> . local
    (66) factor -> . NUMBER_INT
    (67) factor -> . NUMBER_FLOAT
    (68) factor -> . FALSE
    (69) factor -> . TRUE
    (31) local -> . ID
    (32) local -> . HASH ID
    (33) local -> . ID local_aux
    (34) local -> . HASH ID local_aux

    LPAREN          shift and go to state 70
    NUMBER_INT      shift and go to state 71
    NUMBER_FLOAT    shift and go to state 72
    FALSE           shift and go to state 73
    TRUE            shift and go to state 74
    ID              shift and go to state 23
    HASH            shift and go to state 24

    factor                         shift and go to state 76
    local                          shift and go to state 54

state 45

    (32) local -> HASH ID .
    (34) local -> HASH ID . local_aux
    (35) local_aux -> . offset
    (36) local_aux -> . field
    (37) offset -> . LBRACK boolean RBRACK offset
    (38) offset -> . empty
    (39) field -> . DOT factor field
    (40) field -> . DOT factor
    (70) empty -> .

  ! shift/reduce conflict for DOT resolved as shift
  ! reduce/reduce conflict for EQUALS resolved using rule 32 (local -> HASH ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 32 (local -> HASH ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 32 (local -> HASH ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 32 (local -> HASH ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 32 (local -> HASH ID .)
  ! reduce/reduce conflict for EQ resolved using rule 32 (local -> HASH ID .)
  ! reduce/reduce conflict for NEQ resolved using rule 32 (local -> HASH ID .)
  ! reduce/reduce conflict for AND resolved using rule 32 (local -> HASH ID .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 32 (local -> HASH ID .)
  ! reduce/reduce conflict for OR resolved using rule 32 (local -> HASH ID .)
  ! reduce/reduce conflict for RBRACK resolved using rule 32 (local -> HASH ID .)
  ! shift/reduce conflict for DOT resolved as shift
  ! reduce/reduce conflict for RPAREN resolved using rule 32 (local -> HASH ID .)
    EQUALS          reduce using rule 32 (local -> HASH ID .)
    TIMES           reduce using rule 32 (local -> HASH ID .)
    DIVIDE          reduce using rule 32 (local -> HASH ID .)
    PLUS            reduce using rule 32 (local -> HASH ID .)
    MINUS           reduce using rule 32 (local -> HASH ID .)
    EQ              reduce using rule 32 (local -> HASH ID .)
    NEQ             reduce using rule 32 (local -> HASH ID .)
    AND             reduce using rule 32 (local -> HASH ID .)
    SEMICOLON       reduce using rule 32 (local -> HASH ID .)
    OR              reduce using rule 32 (local -> HASH ID .)
    RBRACK          reduce using rule 32 (local -> HASH ID .)
    RPAREN          reduce using rule 32 (local -> HASH ID .)
    LBRACK          shift and go to state 42
    DOT             shift and go to state 44

  ! DOT             [ reduce using rule 32 (local -> HASH ID .) ]
  ! EQUALS          [ reduce using rule 70 (empty -> .) ]
  ! TIMES           [ reduce using rule 70 (empty -> .) ]
  ! DIVIDE          [ reduce using rule 70 (empty -> .) ]
  ! PLUS            [ reduce using rule 70 (empty -> .) ]
  ! MINUS           [ reduce using rule 70 (empty -> .) ]
  ! EQ              [ reduce using rule 70 (empty -> .) ]
  ! NEQ             [ reduce using rule 70 (empty -> .) ]
  ! AND             [ reduce using rule 70 (empty -> .) ]
  ! SEMICOLON       [ reduce using rule 70 (empty -> .) ]
  ! OR              [ reduce using rule 70 (empty -> .) ]
  ! RBRACK          [ reduce using rule 70 (empty -> .) ]
  ! DOT             [ reduce using rule 70 (empty -> .) ]
  ! RPAREN          [ reduce using rule 70 (empty -> .) ]

    local_aux                      shift and go to state 77
    offset                         shift and go to state 40
    field                          shift and go to state 41
    empty                          shift and go to state 43

state 46

    (26) conditional -> IF LPAREN . boolean RPAREN statement conditional_aux
    (41) boolean -> . join
    (42) boolean -> . boolean OR join
    (43) join -> . equality
    (44) join -> . join AND equality
    (45) equality -> . relational
    (46) equality -> . equality EQ relational
    (47) equality -> . equality NEQ relational
    (48) relational -> . expression
    (49) relational -> . relational_operator expression
    (54) expression -> . term
    (55) expression -> . expression expression_operator term
    (50) relational_operator -> . LT
    (51) relational_operator -> . LE
    (52) relational_operator -> . GT
    (53) relational_operator -> . GE
    (58) term -> . unary
    (59) term -> . term TIMES unary
    (60) term -> . term DIVIDE unary
    (61) unary -> . NOT unary
    (62) unary -> . NEG unary
    (63) unary -> . factor
    (64) factor -> . LPAREN boolean RPAREN
    (65) factor -> . local
    (66) factor -> . NUMBER_INT
    (67) factor -> . NUMBER_FLOAT
    (68) factor -> . FALSE
    (69) factor -> . TRUE
    (31) local -> . ID
    (32) local -> . HASH ID
    (33) local -> . ID local_aux
    (34) local -> . HASH ID local_aux

    LT              shift and go to state 62
    LE              shift and go to state 63
    GT              shift and go to state 64
    GE              shift and go to state 65
    NOT             shift and go to state 67
    NEG             shift and go to state 68
    LPAREN          shift and go to state 70
    NUMBER_INT      shift and go to state 71
    NUMBER_FLOAT    shift and go to state 72
    FALSE           shift and go to state 73
    TRUE            shift and go to state 74
    ID              shift and go to state 23
    HASH            shift and go to state 24

    boolean                        shift and go to state 78
    join                           shift and go to state 56
    equality                       shift and go to state 57
    relational                     shift and go to state 58
    expression                     shift and go to state 59
    relational_operator            shift and go to state 60
    term                           shift and go to state 61
    unary                          shift and go to state 66
    factor                         shift and go to state 69
    local                          shift and go to state 54

state 47

    (29) while_loop -> WHILE LPAREN . boolean RPAREN statement
    (41) boolean -> . join
    (42) boolean -> . boolean OR join
    (43) join -> . equality
    (44) join -> . join AND equality
    (45) equality -> . relational
    (46) equality -> . equality EQ relational
    (47) equality -> . equality NEQ relational
    (48) relational -> . expression
    (49) relational -> . relational_operator expression
    (54) expression -> . term
    (55) expression -> . expression expression_operator term
    (50) relational_operator -> . LT
    (51) relational_operator -> . LE
    (52) relational_operator -> . GT
    (53) relational_operator -> . GE
    (58) term -> . unary
    (59) term -> . term TIMES unary
    (60) term -> . term DIVIDE unary
    (61) unary -> . NOT unary
    (62) unary -> . NEG unary
    (63) unary -> . factor
    (64) factor -> . LPAREN boolean RPAREN
    (65) factor -> . local
    (66) factor -> . NUMBER_INT
    (67) factor -> . NUMBER_FLOAT
    (68) factor -> . FALSE
    (69) factor -> . TRUE
    (31) local -> . ID
    (32) local -> . HASH ID
    (33) local -> . ID local_aux
    (34) local -> . HASH ID local_aux

    LT              shift and go to state 62
    LE              shift and go to state 63
    GT              shift and go to state 64
    GE              shift and go to state 65
    NOT             shift and go to state 67
    NEG             shift and go to state 68
    LPAREN          shift and go to state 70
    NUMBER_INT      shift and go to state 71
    NUMBER_FLOAT    shift and go to state 72
    FALSE           shift and go to state 73
    TRUE            shift and go to state 74
    ID              shift and go to state 23
    HASH            shift and go to state 24

    boolean                        shift and go to state 79
    join                           shift and go to state 56
    equality                       shift and go to state 57
    relational                     shift and go to state 58
    expression                     shift and go to state 59
    relational_operator            shift and go to state 60
    term                           shift and go to state 61
    unary                          shift and go to state 66
    factor                         shift and go to state 69
    local                          shift and go to state 54

state 48

    (30) do_while_loop -> DO statement . WHILE LPAREN boolean RPAREN SEMICOLON

    WHILE           shift and go to state 80


state 49

    (24) print -> PRINT LPAREN . boolean RPAREN SEMICOLON
    (41) boolean -> . join
    (42) boolean -> . boolean OR join
    (43) join -> . equality
    (44) join -> . join AND equality
    (45) equality -> . relational
    (46) equality -> . equality EQ relational
    (47) equality -> . equality NEQ relational
    (48) relational -> . expression
    (49) relational -> . relational_operator expression
    (54) expression -> . term
    (55) expression -> . expression expression_operator term
    (50) relational_operator -> . LT
    (51) relational_operator -> . LE
    (52) relational_operator -> . GT
    (53) relational_operator -> . GE
    (58) term -> . unary
    (59) term -> . term TIMES unary
    (60) term -> . term DIVIDE unary
    (61) unary -> . NOT unary
    (62) unary -> . NEG unary
    (63) unary -> . factor
    (64) factor -> . LPAREN boolean RPAREN
    (65) factor -> . local
    (66) factor -> . NUMBER_INT
    (67) factor -> . NUMBER_FLOAT
    (68) factor -> . FALSE
    (69) factor -> . TRUE
    (31) local -> . ID
    (32) local -> . HASH ID
    (33) local -> . ID local_aux
    (34) local -> . HASH ID local_aux

    LT              shift and go to state 62
    LE              shift and go to state 63
    GT              shift and go to state 64
    GE              shift and go to state 65
    NOT             shift and go to state 67
    NEG             shift and go to state 68
    LPAREN          shift and go to state 70
    NUMBER_INT      shift and go to state 71
    NUMBER_FLOAT    shift and go to state 72
    FALSE           shift and go to state 73
    TRUE            shift and go to state 74
    ID              shift and go to state 23
    HASH            shift and go to state 24

    boolean                        shift and go to state 81
    join                           shift and go to state 56
    equality                       shift and go to state 57
    relational                     shift and go to state 58
    expression                     shift and go to state 59
    relational_operator            shift and go to state 60
    term                           shift and go to state 61
    unary                          shift and go to state 66
    factor                         shift and go to state 69
    local                          shift and go to state 54

state 50

    (25) read -> READ LPAREN . local RPAREN SEMICOLON
    (31) local -> . ID
    (32) local -> . HASH ID
    (33) local -> . ID local_aux
    (34) local -> . HASH ID local_aux

    ID              shift and go to state 23
    HASH            shift and go to state 24

    local                          shift and go to state 82

state 51

    (3) declaration -> type ID SEMICOLON . declaration
    (3) declaration -> . type ID SEMICOLON declaration
    (4) declaration -> . empty
    (5) type -> . basic dimensions
    (6) type -> . basic HASH
    (7) type -> . basic
    (8) type -> . RECORD LBRACE declaration RBRACE
    (70) empty -> .
    (11) basic -> . INT
    (12) basic -> . CHAR
    (13) basic -> . BOOL

    RECORD          shift and go to state 8
    BREAK           reduce using rule 70 (empty -> .)
    ID              reduce using rule 70 (empty -> .)
    HASH            reduce using rule 70 (empty -> .)
    IF              reduce using rule 70 (empty -> .)
    WHILE           reduce using rule 70 (empty -> .)
    DO              reduce using rule 70 (empty -> .)
    PRINT           reduce using rule 70 (empty -> .)
    READ            reduce using rule 70 (empty -> .)
    LBRACE          reduce using rule 70 (empty -> .)
    RBRACE          reduce using rule 70 (empty -> .)
    INT             shift and go to state 9
    CHAR            shift and go to state 10
    BOOL            shift and go to state 11

    type                           shift and go to state 5
    declaration                    shift and go to state 83
    empty                          shift and go to state 6
    basic                          shift and go to state 7

state 52

    (9) dimensions -> LBRACK NUMBER_INT . RBRACK dimensions
    (10) dimensions -> LBRACK NUMBER_INT . RBRACK

    RBRACK          shift and go to state 84


state 53

    (8) type -> RECORD LBRACE declaration . RBRACE

    RBRACE          shift and go to state 85


state 54

    (65) factor -> local .

    TIMES           reduce using rule 65 (factor -> local .)
    DIVIDE          reduce using rule 65 (factor -> local .)
    PLUS            reduce using rule 65 (factor -> local .)
    MINUS           reduce using rule 65 (factor -> local .)
    EQ              reduce using rule 65 (factor -> local .)
    NEQ             reduce using rule 65 (factor -> local .)
    AND             reduce using rule 65 (factor -> local .)
    SEMICOLON       reduce using rule 65 (factor -> local .)
    OR              reduce using rule 65 (factor -> local .)
    RBRACK          reduce using rule 65 (factor -> local .)
    EQUALS          reduce using rule 65 (factor -> local .)
    DOT             reduce using rule 65 (factor -> local .)
    RPAREN          reduce using rule 65 (factor -> local .)


state 55

    (16) statement -> local EQUALS boolean . SEMICOLON
    (42) boolean -> boolean . OR join

    SEMICOLON       shift and go to state 86
    OR              shift and go to state 87


state 56

    (41) boolean -> join .
    (44) join -> join . AND equality

    SEMICOLON       reduce using rule 41 (boolean -> join .)
    OR              reduce using rule 41 (boolean -> join .)
    RBRACK          reduce using rule 41 (boolean -> join .)
    RPAREN          reduce using rule 41 (boolean -> join .)
    AND             shift and go to state 88


state 57

    (43) join -> equality .
    (46) equality -> equality . EQ relational
    (47) equality -> equality . NEQ relational

    AND             reduce using rule 43 (join -> equality .)
    SEMICOLON       reduce using rule 43 (join -> equality .)
    OR              reduce using rule 43 (join -> equality .)
    RBRACK          reduce using rule 43 (join -> equality .)
    RPAREN          reduce using rule 43 (join -> equality .)
    EQ              shift and go to state 89
    NEQ             shift and go to state 90


state 58

    (45) equality -> relational .

    EQ              reduce using rule 45 (equality -> relational .)
    NEQ             reduce using rule 45 (equality -> relational .)
    AND             reduce using rule 45 (equality -> relational .)
    SEMICOLON       reduce using rule 45 (equality -> relational .)
    OR              reduce using rule 45 (equality -> relational .)
    RBRACK          reduce using rule 45 (equality -> relational .)
    RPAREN          reduce using rule 45 (equality -> relational .)


state 59

    (48) relational -> expression .
    (55) expression -> expression . expression_operator term
    (56) expression_operator -> . PLUS
    (57) expression_operator -> . MINUS

    EQ              reduce using rule 48 (relational -> expression .)
    NEQ             reduce using rule 48 (relational -> expression .)
    AND             reduce using rule 48 (relational -> expression .)
    SEMICOLON       reduce using rule 48 (relational -> expression .)
    OR              reduce using rule 48 (relational -> expression .)
    RBRACK          reduce using rule 48 (relational -> expression .)
    RPAREN          reduce using rule 48 (relational -> expression .)
    PLUS            shift and go to state 92
    MINUS           shift and go to state 93

    expression_operator            shift and go to state 91

state 60

    (49) relational -> relational_operator . expression
    (54) expression -> . term
    (55) expression -> . expression expression_operator term
    (58) term -> . unary
    (59) term -> . term TIMES unary
    (60) term -> . term DIVIDE unary
    (61) unary -> . NOT unary
    (62) unary -> . NEG unary
    (63) unary -> . factor
    (64) factor -> . LPAREN boolean RPAREN
    (65) factor -> . local
    (66) factor -> . NUMBER_INT
    (67) factor -> . NUMBER_FLOAT
    (68) factor -> . FALSE
    (69) factor -> . TRUE
    (31) local -> . ID
    (32) local -> . HASH ID
    (33) local -> . ID local_aux
    (34) local -> . HASH ID local_aux

    NOT             shift and go to state 67
    NEG             shift and go to state 68
    LPAREN          shift and go to state 70
    NUMBER_INT      shift and go to state 71
    NUMBER_FLOAT    shift and go to state 72
    FALSE           shift and go to state 73
    TRUE            shift and go to state 74
    ID              shift and go to state 23
    HASH            shift and go to state 24

    expression                     shift and go to state 94
    term                           shift and go to state 61
    unary                          shift and go to state 66
    factor                         shift and go to state 69
    local                          shift and go to state 54

state 61

    (54) expression -> term .
    (59) term -> term . TIMES unary
    (60) term -> term . DIVIDE unary

    PLUS            reduce using rule 54 (expression -> term .)
    MINUS           reduce using rule 54 (expression -> term .)
    EQ              reduce using rule 54 (expression -> term .)
    NEQ             reduce using rule 54 (expression -> term .)
    AND             reduce using rule 54 (expression -> term .)
    SEMICOLON       reduce using rule 54 (expression -> term .)
    OR              reduce using rule 54 (expression -> term .)
    RBRACK          reduce using rule 54 (expression -> term .)
    RPAREN          reduce using rule 54 (expression -> term .)
    TIMES           shift and go to state 95
    DIVIDE          shift and go to state 96


state 62

    (50) relational_operator -> LT .

    NOT             reduce using rule 50 (relational_operator -> LT .)
    NEG             reduce using rule 50 (relational_operator -> LT .)
    LPAREN          reduce using rule 50 (relational_operator -> LT .)
    NUMBER_INT      reduce using rule 50 (relational_operator -> LT .)
    NUMBER_FLOAT    reduce using rule 50 (relational_operator -> LT .)
    FALSE           reduce using rule 50 (relational_operator -> LT .)
    TRUE            reduce using rule 50 (relational_operator -> LT .)
    ID              reduce using rule 50 (relational_operator -> LT .)
    HASH            reduce using rule 50 (relational_operator -> LT .)


state 63

    (51) relational_operator -> LE .

    NOT             reduce using rule 51 (relational_operator -> LE .)
    NEG             reduce using rule 51 (relational_operator -> LE .)
    LPAREN          reduce using rule 51 (relational_operator -> LE .)
    NUMBER_INT      reduce using rule 51 (relational_operator -> LE .)
    NUMBER_FLOAT    reduce using rule 51 (relational_operator -> LE .)
    FALSE           reduce using rule 51 (relational_operator -> LE .)
    TRUE            reduce using rule 51 (relational_operator -> LE .)
    ID              reduce using rule 51 (relational_operator -> LE .)
    HASH            reduce using rule 51 (relational_operator -> LE .)


state 64

    (52) relational_operator -> GT .

    NOT             reduce using rule 52 (relational_operator -> GT .)
    NEG             reduce using rule 52 (relational_operator -> GT .)
    LPAREN          reduce using rule 52 (relational_operator -> GT .)
    NUMBER_INT      reduce using rule 52 (relational_operator -> GT .)
    NUMBER_FLOAT    reduce using rule 52 (relational_operator -> GT .)
    FALSE           reduce using rule 52 (relational_operator -> GT .)
    TRUE            reduce using rule 52 (relational_operator -> GT .)
    ID              reduce using rule 52 (relational_operator -> GT .)
    HASH            reduce using rule 52 (relational_operator -> GT .)


state 65

    (53) relational_operator -> GE .

    NOT             reduce using rule 53 (relational_operator -> GE .)
    NEG             reduce using rule 53 (relational_operator -> GE .)
    LPAREN          reduce using rule 53 (relational_operator -> GE .)
    NUMBER_INT      reduce using rule 53 (relational_operator -> GE .)
    NUMBER_FLOAT    reduce using rule 53 (relational_operator -> GE .)
    FALSE           reduce using rule 53 (relational_operator -> GE .)
    TRUE            reduce using rule 53 (relational_operator -> GE .)
    ID              reduce using rule 53 (relational_operator -> GE .)
    HASH            reduce using rule 53 (relational_operator -> GE .)


state 66

    (58) term -> unary .

    TIMES           reduce using rule 58 (term -> unary .)
    DIVIDE          reduce using rule 58 (term -> unary .)
    PLUS            reduce using rule 58 (term -> unary .)
    MINUS           reduce using rule 58 (term -> unary .)
    EQ              reduce using rule 58 (term -> unary .)
    NEQ             reduce using rule 58 (term -> unary .)
    AND             reduce using rule 58 (term -> unary .)
    SEMICOLON       reduce using rule 58 (term -> unary .)
    OR              reduce using rule 58 (term -> unary .)
    RBRACK          reduce using rule 58 (term -> unary .)
    RPAREN          reduce using rule 58 (term -> unary .)


state 67

    (61) unary -> NOT . unary
    (61) unary -> . NOT unary
    (62) unary -> . NEG unary
    (63) unary -> . factor
    (64) factor -> . LPAREN boolean RPAREN
    (65) factor -> . local
    (66) factor -> . NUMBER_INT
    (67) factor -> . NUMBER_FLOAT
    (68) factor -> . FALSE
    (69) factor -> . TRUE
    (31) local -> . ID
    (32) local -> . HASH ID
    (33) local -> . ID local_aux
    (34) local -> . HASH ID local_aux

    NOT             shift and go to state 67
    NEG             shift and go to state 68
    LPAREN          shift and go to state 70
    NUMBER_INT      shift and go to state 71
    NUMBER_FLOAT    shift and go to state 72
    FALSE           shift and go to state 73
    TRUE            shift and go to state 74
    ID              shift and go to state 23
    HASH            shift and go to state 24

    unary                          shift and go to state 97
    factor                         shift and go to state 69
    local                          shift and go to state 54

state 68

    (62) unary -> NEG . unary
    (61) unary -> . NOT unary
    (62) unary -> . NEG unary
    (63) unary -> . factor
    (64) factor -> . LPAREN boolean RPAREN
    (65) factor -> . local
    (66) factor -> . NUMBER_INT
    (67) factor -> . NUMBER_FLOAT
    (68) factor -> . FALSE
    (69) factor -> . TRUE
    (31) local -> . ID
    (32) local -> . HASH ID
    (33) local -> . ID local_aux
    (34) local -> . HASH ID local_aux

    NOT             shift and go to state 67
    NEG             shift and go to state 68
    LPAREN          shift and go to state 70
    NUMBER_INT      shift and go to state 71
    NUMBER_FLOAT    shift and go to state 72
    FALSE           shift and go to state 73
    TRUE            shift and go to state 74
    ID              shift and go to state 23
    HASH            shift and go to state 24

    unary                          shift and go to state 98
    factor                         shift and go to state 69
    local                          shift and go to state 54

state 69

    (63) unary -> factor .

    TIMES           reduce using rule 63 (unary -> factor .)
    DIVIDE          reduce using rule 63 (unary -> factor .)
    PLUS            reduce using rule 63 (unary -> factor .)
    MINUS           reduce using rule 63 (unary -> factor .)
    EQ              reduce using rule 63 (unary -> factor .)
    NEQ             reduce using rule 63 (unary -> factor .)
    AND             reduce using rule 63 (unary -> factor .)
    SEMICOLON       reduce using rule 63 (unary -> factor .)
    OR              reduce using rule 63 (unary -> factor .)
    RBRACK          reduce using rule 63 (unary -> factor .)
    RPAREN          reduce using rule 63 (unary -> factor .)


state 70

    (64) factor -> LPAREN . boolean RPAREN
    (41) boolean -> . join
    (42) boolean -> . boolean OR join
    (43) join -> . equality
    (44) join -> . join AND equality
    (45) equality -> . relational
    (46) equality -> . equality EQ relational
    (47) equality -> . equality NEQ relational
    (48) relational -> . expression
    (49) relational -> . relational_operator expression
    (54) expression -> . term
    (55) expression -> . expression expression_operator term
    (50) relational_operator -> . LT
    (51) relational_operator -> . LE
    (52) relational_operator -> . GT
    (53) relational_operator -> . GE
    (58) term -> . unary
    (59) term -> . term TIMES unary
    (60) term -> . term DIVIDE unary
    (61) unary -> . NOT unary
    (62) unary -> . NEG unary
    (63) unary -> . factor
    (64) factor -> . LPAREN boolean RPAREN
    (65) factor -> . local
    (66) factor -> . NUMBER_INT
    (67) factor -> . NUMBER_FLOAT
    (68) factor -> . FALSE
    (69) factor -> . TRUE
    (31) local -> . ID
    (32) local -> . HASH ID
    (33) local -> . ID local_aux
    (34) local -> . HASH ID local_aux

    LT              shift and go to state 62
    LE              shift and go to state 63
    GT              shift and go to state 64
    GE              shift and go to state 65
    NOT             shift and go to state 67
    NEG             shift and go to state 68
    LPAREN          shift and go to state 70
    NUMBER_INT      shift and go to state 71
    NUMBER_FLOAT    shift and go to state 72
    FALSE           shift and go to state 73
    TRUE            shift and go to state 74
    ID              shift and go to state 23
    HASH            shift and go to state 24

    boolean                        shift and go to state 99
    join                           shift and go to state 56
    equality                       shift and go to state 57
    relational                     shift and go to state 58
    expression                     shift and go to state 59
    relational_operator            shift and go to state 60
    term                           shift and go to state 61
    unary                          shift and go to state 66
    factor                         shift and go to state 69
    local                          shift and go to state 54

state 71

    (66) factor -> NUMBER_INT .

    TIMES           reduce using rule 66 (factor -> NUMBER_INT .)
    DIVIDE          reduce using rule 66 (factor -> NUMBER_INT .)
    PLUS            reduce using rule 66 (factor -> NUMBER_INT .)
    MINUS           reduce using rule 66 (factor -> NUMBER_INT .)
    EQ              reduce using rule 66 (factor -> NUMBER_INT .)
    NEQ             reduce using rule 66 (factor -> NUMBER_INT .)
    AND             reduce using rule 66 (factor -> NUMBER_INT .)
    SEMICOLON       reduce using rule 66 (factor -> NUMBER_INT .)
    OR              reduce using rule 66 (factor -> NUMBER_INT .)
    RBRACK          reduce using rule 66 (factor -> NUMBER_INT .)
    EQUALS          reduce using rule 66 (factor -> NUMBER_INT .)
    DOT             reduce using rule 66 (factor -> NUMBER_INT .)
    RPAREN          reduce using rule 66 (factor -> NUMBER_INT .)


state 72

    (67) factor -> NUMBER_FLOAT .

    TIMES           reduce using rule 67 (factor -> NUMBER_FLOAT .)
    DIVIDE          reduce using rule 67 (factor -> NUMBER_FLOAT .)
    PLUS            reduce using rule 67 (factor -> NUMBER_FLOAT .)
    MINUS           reduce using rule 67 (factor -> NUMBER_FLOAT .)
    EQ              reduce using rule 67 (factor -> NUMBER_FLOAT .)
    NEQ             reduce using rule 67 (factor -> NUMBER_FLOAT .)
    AND             reduce using rule 67 (factor -> NUMBER_FLOAT .)
    SEMICOLON       reduce using rule 67 (factor -> NUMBER_FLOAT .)
    OR              reduce using rule 67 (factor -> NUMBER_FLOAT .)
    RBRACK          reduce using rule 67 (factor -> NUMBER_FLOAT .)
    EQUALS          reduce using rule 67 (factor -> NUMBER_FLOAT .)
    DOT             reduce using rule 67 (factor -> NUMBER_FLOAT .)
    RPAREN          reduce using rule 67 (factor -> NUMBER_FLOAT .)


state 73

    (68) factor -> FALSE .

    TIMES           reduce using rule 68 (factor -> FALSE .)
    DIVIDE          reduce using rule 68 (factor -> FALSE .)
    PLUS            reduce using rule 68 (factor -> FALSE .)
    MINUS           reduce using rule 68 (factor -> FALSE .)
    EQ              reduce using rule 68 (factor -> FALSE .)
    NEQ             reduce using rule 68 (factor -> FALSE .)
    AND             reduce using rule 68 (factor -> FALSE .)
    SEMICOLON       reduce using rule 68 (factor -> FALSE .)
    OR              reduce using rule 68 (factor -> FALSE .)
    RBRACK          reduce using rule 68 (factor -> FALSE .)
    EQUALS          reduce using rule 68 (factor -> FALSE .)
    DOT             reduce using rule 68 (factor -> FALSE .)
    RPAREN          reduce using rule 68 (factor -> FALSE .)


state 74

    (69) factor -> TRUE .

    TIMES           reduce using rule 69 (factor -> TRUE .)
    DIVIDE          reduce using rule 69 (factor -> TRUE .)
    PLUS            reduce using rule 69 (factor -> TRUE .)
    MINUS           reduce using rule 69 (factor -> TRUE .)
    EQ              reduce using rule 69 (factor -> TRUE .)
    NEQ             reduce using rule 69 (factor -> TRUE .)
    AND             reduce using rule 69 (factor -> TRUE .)
    SEMICOLON       reduce using rule 69 (factor -> TRUE .)
    OR              reduce using rule 69 (factor -> TRUE .)
    RBRACK          reduce using rule 69 (factor -> TRUE .)
    EQUALS          reduce using rule 69 (factor -> TRUE .)
    DOT             reduce using rule 69 (factor -> TRUE .)
    RPAREN          reduce using rule 69 (factor -> TRUE .)


state 75

    (37) offset -> LBRACK boolean . RBRACK offset
    (42) boolean -> boolean . OR join

    RBRACK          shift and go to state 100
    OR              shift and go to state 87


state 76

    (39) field -> DOT factor . field
    (40) field -> DOT factor .
    (39) field -> . DOT factor field
    (40) field -> . DOT factor

  ! shift/reduce conflict for DOT resolved as shift
    EQUALS          reduce using rule 40 (field -> DOT factor .)
    TIMES           reduce using rule 40 (field -> DOT factor .)
    DIVIDE          reduce using rule 40 (field -> DOT factor .)
    PLUS            reduce using rule 40 (field -> DOT factor .)
    MINUS           reduce using rule 40 (field -> DOT factor .)
    EQ              reduce using rule 40 (field -> DOT factor .)
    NEQ             reduce using rule 40 (field -> DOT factor .)
    AND             reduce using rule 40 (field -> DOT factor .)
    SEMICOLON       reduce using rule 40 (field -> DOT factor .)
    OR              reduce using rule 40 (field -> DOT factor .)
    RBRACK          reduce using rule 40 (field -> DOT factor .)
    RPAREN          reduce using rule 40 (field -> DOT factor .)
    DOT             shift and go to state 44

  ! DOT             [ reduce using rule 40 (field -> DOT factor .) ]

    field                          shift and go to state 101

state 77

    (34) local -> HASH ID local_aux .

    EQUALS          reduce using rule 34 (local -> HASH ID local_aux .)
    TIMES           reduce using rule 34 (local -> HASH ID local_aux .)
    DIVIDE          reduce using rule 34 (local -> HASH ID local_aux .)
    PLUS            reduce using rule 34 (local -> HASH ID local_aux .)
    MINUS           reduce using rule 34 (local -> HASH ID local_aux .)
    EQ              reduce using rule 34 (local -> HASH ID local_aux .)
    NEQ             reduce using rule 34 (local -> HASH ID local_aux .)
    AND             reduce using rule 34 (local -> HASH ID local_aux .)
    SEMICOLON       reduce using rule 34 (local -> HASH ID local_aux .)
    OR              reduce using rule 34 (local -> HASH ID local_aux .)
    RBRACK          reduce using rule 34 (local -> HASH ID local_aux .)
    DOT             reduce using rule 34 (local -> HASH ID local_aux .)
    RPAREN          reduce using rule 34 (local -> HASH ID local_aux .)


state 78

    (26) conditional -> IF LPAREN boolean . RPAREN statement conditional_aux
    (42) boolean -> boolean . OR join

    RPAREN          shift and go to state 102
    OR              shift and go to state 87


state 79

    (29) while_loop -> WHILE LPAREN boolean . RPAREN statement
    (42) boolean -> boolean . OR join

    RPAREN          shift and go to state 103
    OR              shift and go to state 87


state 80

    (30) do_while_loop -> DO statement WHILE . LPAREN boolean RPAREN SEMICOLON

    LPAREN          shift and go to state 104


state 81

    (24) print -> PRINT LPAREN boolean . RPAREN SEMICOLON
    (42) boolean -> boolean . OR join

    RPAREN          shift and go to state 105
    OR              shift and go to state 87


state 82

    (25) read -> READ LPAREN local . RPAREN SEMICOLON

    RPAREN          shift and go to state 106


state 83

    (3) declaration -> type ID SEMICOLON declaration .

    BREAK           reduce using rule 3 (declaration -> type ID SEMICOLON declaration .)
    ID              reduce using rule 3 (declaration -> type ID SEMICOLON declaration .)
    HASH            reduce using rule 3 (declaration -> type ID SEMICOLON declaration .)
    IF              reduce using rule 3 (declaration -> type ID SEMICOLON declaration .)
    WHILE           reduce using rule 3 (declaration -> type ID SEMICOLON declaration .)
    DO              reduce using rule 3 (declaration -> type ID SEMICOLON declaration .)
    PRINT           reduce using rule 3 (declaration -> type ID SEMICOLON declaration .)
    READ            reduce using rule 3 (declaration -> type ID SEMICOLON declaration .)
    LBRACE          reduce using rule 3 (declaration -> type ID SEMICOLON declaration .)
    RBRACE          reduce using rule 3 (declaration -> type ID SEMICOLON declaration .)


state 84

    (9) dimensions -> LBRACK NUMBER_INT RBRACK . dimensions
    (10) dimensions -> LBRACK NUMBER_INT RBRACK .
    (9) dimensions -> . LBRACK NUMBER_INT RBRACK dimensions
    (10) dimensions -> . LBRACK NUMBER_INT RBRACK

    ID              reduce using rule 10 (dimensions -> LBRACK NUMBER_INT RBRACK .)
    LBRACK          shift and go to state 33

    dimensions                     shift and go to state 107

state 85

    (8) type -> RECORD LBRACE declaration RBRACE .

    ID              reduce using rule 8 (type -> RECORD LBRACE declaration RBRACE .)


state 86

    (16) statement -> local EQUALS boolean SEMICOLON .

    BREAK           reduce using rule 16 (statement -> local EQUALS boolean SEMICOLON .)
    ID              reduce using rule 16 (statement -> local EQUALS boolean SEMICOLON .)
    HASH            reduce using rule 16 (statement -> local EQUALS boolean SEMICOLON .)
    IF              reduce using rule 16 (statement -> local EQUALS boolean SEMICOLON .)
    WHILE           reduce using rule 16 (statement -> local EQUALS boolean SEMICOLON .)
    DO              reduce using rule 16 (statement -> local EQUALS boolean SEMICOLON .)
    PRINT           reduce using rule 16 (statement -> local EQUALS boolean SEMICOLON .)
    READ            reduce using rule 16 (statement -> local EQUALS boolean SEMICOLON .)
    LBRACE          reduce using rule 16 (statement -> local EQUALS boolean SEMICOLON .)
    RBRACE          reduce using rule 16 (statement -> local EQUALS boolean SEMICOLON .)
    ELSE            reduce using rule 16 (statement -> local EQUALS boolean SEMICOLON .)


state 87

    (42) boolean -> boolean OR . join
    (43) join -> . equality
    (44) join -> . join AND equality
    (45) equality -> . relational
    (46) equality -> . equality EQ relational
    (47) equality -> . equality NEQ relational
    (48) relational -> . expression
    (49) relational -> . relational_operator expression
    (54) expression -> . term
    (55) expression -> . expression expression_operator term
    (50) relational_operator -> . LT
    (51) relational_operator -> . LE
    (52) relational_operator -> . GT
    (53) relational_operator -> . GE
    (58) term -> . unary
    (59) term -> . term TIMES unary
    (60) term -> . term DIVIDE unary
    (61) unary -> . NOT unary
    (62) unary -> . NEG unary
    (63) unary -> . factor
    (64) factor -> . LPAREN boolean RPAREN
    (65) factor -> . local
    (66) factor -> . NUMBER_INT
    (67) factor -> . NUMBER_FLOAT
    (68) factor -> . FALSE
    (69) factor -> . TRUE
    (31) local -> . ID
    (32) local -> . HASH ID
    (33) local -> . ID local_aux
    (34) local -> . HASH ID local_aux

    LT              shift and go to state 62
    LE              shift and go to state 63
    GT              shift and go to state 64
    GE              shift and go to state 65
    NOT             shift and go to state 67
    NEG             shift and go to state 68
    LPAREN          shift and go to state 70
    NUMBER_INT      shift and go to state 71
    NUMBER_FLOAT    shift and go to state 72
    FALSE           shift and go to state 73
    TRUE            shift and go to state 74
    ID              shift and go to state 23
    HASH            shift and go to state 24

    join                           shift and go to state 108
    equality                       shift and go to state 57
    relational                     shift and go to state 58
    expression                     shift and go to state 59
    relational_operator            shift and go to state 60
    term                           shift and go to state 61
    unary                          shift and go to state 66
    factor                         shift and go to state 69
    local                          shift and go to state 54

state 88

    (44) join -> join AND . equality
    (45) equality -> . relational
    (46) equality -> . equality EQ relational
    (47) equality -> . equality NEQ relational
    (48) relational -> . expression
    (49) relational -> . relational_operator expression
    (54) expression -> . term
    (55) expression -> . expression expression_operator term
    (50) relational_operator -> . LT
    (51) relational_operator -> . LE
    (52) relational_operator -> . GT
    (53) relational_operator -> . GE
    (58) term -> . unary
    (59) term -> . term TIMES unary
    (60) term -> . term DIVIDE unary
    (61) unary -> . NOT unary
    (62) unary -> . NEG unary
    (63) unary -> . factor
    (64) factor -> . LPAREN boolean RPAREN
    (65) factor -> . local
    (66) factor -> . NUMBER_INT
    (67) factor -> . NUMBER_FLOAT
    (68) factor -> . FALSE
    (69) factor -> . TRUE
    (31) local -> . ID
    (32) local -> . HASH ID
    (33) local -> . ID local_aux
    (34) local -> . HASH ID local_aux

    LT              shift and go to state 62
    LE              shift and go to state 63
    GT              shift and go to state 64
    GE              shift and go to state 65
    NOT             shift and go to state 67
    NEG             shift and go to state 68
    LPAREN          shift and go to state 70
    NUMBER_INT      shift and go to state 71
    NUMBER_FLOAT    shift and go to state 72
    FALSE           shift and go to state 73
    TRUE            shift and go to state 74
    ID              shift and go to state 23
    HASH            shift and go to state 24

    equality                       shift and go to state 109
    relational                     shift and go to state 58
    expression                     shift and go to state 59
    relational_operator            shift and go to state 60
    term                           shift and go to state 61
    unary                          shift and go to state 66
    factor                         shift and go to state 69
    local                          shift and go to state 54

state 89

    (46) equality -> equality EQ . relational
    (48) relational -> . expression
    (49) relational -> . relational_operator expression
    (54) expression -> . term
    (55) expression -> . expression expression_operator term
    (50) relational_operator -> . LT
    (51) relational_operator -> . LE
    (52) relational_operator -> . GT
    (53) relational_operator -> . GE
    (58) term -> . unary
    (59) term -> . term TIMES unary
    (60) term -> . term DIVIDE unary
    (61) unary -> . NOT unary
    (62) unary -> . NEG unary
    (63) unary -> . factor
    (64) factor -> . LPAREN boolean RPAREN
    (65) factor -> . local
    (66) factor -> . NUMBER_INT
    (67) factor -> . NUMBER_FLOAT
    (68) factor -> . FALSE
    (69) factor -> . TRUE
    (31) local -> . ID
    (32) local -> . HASH ID
    (33) local -> . ID local_aux
    (34) local -> . HASH ID local_aux

    LT              shift and go to state 62
    LE              shift and go to state 63
    GT              shift and go to state 64
    GE              shift and go to state 65
    NOT             shift and go to state 67
    NEG             shift and go to state 68
    LPAREN          shift and go to state 70
    NUMBER_INT      shift and go to state 71
    NUMBER_FLOAT    shift and go to state 72
    FALSE           shift and go to state 73
    TRUE            shift and go to state 74
    ID              shift and go to state 23
    HASH            shift and go to state 24

    relational                     shift and go to state 110
    expression                     shift and go to state 59
    relational_operator            shift and go to state 60
    term                           shift and go to state 61
    unary                          shift and go to state 66
    factor                         shift and go to state 69
    local                          shift and go to state 54

state 90

    (47) equality -> equality NEQ . relational
    (48) relational -> . expression
    (49) relational -> . relational_operator expression
    (54) expression -> . term
    (55) expression -> . expression expression_operator term
    (50) relational_operator -> . LT
    (51) relational_operator -> . LE
    (52) relational_operator -> . GT
    (53) relational_operator -> . GE
    (58) term -> . unary
    (59) term -> . term TIMES unary
    (60) term -> . term DIVIDE unary
    (61) unary -> . NOT unary
    (62) unary -> . NEG unary
    (63) unary -> . factor
    (64) factor -> . LPAREN boolean RPAREN
    (65) factor -> . local
    (66) factor -> . NUMBER_INT
    (67) factor -> . NUMBER_FLOAT
    (68) factor -> . FALSE
    (69) factor -> . TRUE
    (31) local -> . ID
    (32) local -> . HASH ID
    (33) local -> . ID local_aux
    (34) local -> . HASH ID local_aux

    LT              shift and go to state 62
    LE              shift and go to state 63
    GT              shift and go to state 64
    GE              shift and go to state 65
    NOT             shift and go to state 67
    NEG             shift and go to state 68
    LPAREN          shift and go to state 70
    NUMBER_INT      shift and go to state 71
    NUMBER_FLOAT    shift and go to state 72
    FALSE           shift and go to state 73
    TRUE            shift and go to state 74
    ID              shift and go to state 23
    HASH            shift and go to state 24

    relational                     shift and go to state 111
    expression                     shift and go to state 59
    relational_operator            shift and go to state 60
    term                           shift and go to state 61
    unary                          shift and go to state 66
    factor                         shift and go to state 69
    local                          shift and go to state 54

state 91

    (55) expression -> expression expression_operator . term
    (58) term -> . unary
    (59) term -> . term TIMES unary
    (60) term -> . term DIVIDE unary
    (61) unary -> . NOT unary
    (62) unary -> . NEG unary
    (63) unary -> . factor
    (64) factor -> . LPAREN boolean RPAREN
    (65) factor -> . local
    (66) factor -> . NUMBER_INT
    (67) factor -> . NUMBER_FLOAT
    (68) factor -> . FALSE
    (69) factor -> . TRUE
    (31) local -> . ID
    (32) local -> . HASH ID
    (33) local -> . ID local_aux
    (34) local -> . HASH ID local_aux

    NOT             shift and go to state 67
    NEG             shift and go to state 68
    LPAREN          shift and go to state 70
    NUMBER_INT      shift and go to state 71
    NUMBER_FLOAT    shift and go to state 72
    FALSE           shift and go to state 73
    TRUE            shift and go to state 74
    ID              shift and go to state 23
    HASH            shift and go to state 24

    term                           shift and go to state 112
    unary                          shift and go to state 66
    factor                         shift and go to state 69
    local                          shift and go to state 54

state 92

    (56) expression_operator -> PLUS .

    NOT             reduce using rule 56 (expression_operator -> PLUS .)
    NEG             reduce using rule 56 (expression_operator -> PLUS .)
    LPAREN          reduce using rule 56 (expression_operator -> PLUS .)
    NUMBER_INT      reduce using rule 56 (expression_operator -> PLUS .)
    NUMBER_FLOAT    reduce using rule 56 (expression_operator -> PLUS .)
    FALSE           reduce using rule 56 (expression_operator -> PLUS .)
    TRUE            reduce using rule 56 (expression_operator -> PLUS .)
    ID              reduce using rule 56 (expression_operator -> PLUS .)
    HASH            reduce using rule 56 (expression_operator -> PLUS .)


state 93

    (57) expression_operator -> MINUS .

    NOT             reduce using rule 57 (expression_operator -> MINUS .)
    NEG             reduce using rule 57 (expression_operator -> MINUS .)
    LPAREN          reduce using rule 57 (expression_operator -> MINUS .)
    NUMBER_INT      reduce using rule 57 (expression_operator -> MINUS .)
    NUMBER_FLOAT    reduce using rule 57 (expression_operator -> MINUS .)
    FALSE           reduce using rule 57 (expression_operator -> MINUS .)
    TRUE            reduce using rule 57 (expression_operator -> MINUS .)
    ID              reduce using rule 57 (expression_operator -> MINUS .)
    HASH            reduce using rule 57 (expression_operator -> MINUS .)


state 94

    (49) relational -> relational_operator expression .
    (55) expression -> expression . expression_operator term
    (56) expression_operator -> . PLUS
    (57) expression_operator -> . MINUS

    EQ              reduce using rule 49 (relational -> relational_operator expression .)
    NEQ             reduce using rule 49 (relational -> relational_operator expression .)
    AND             reduce using rule 49 (relational -> relational_operator expression .)
    SEMICOLON       reduce using rule 49 (relational -> relational_operator expression .)
    OR              reduce using rule 49 (relational -> relational_operator expression .)
    RBRACK          reduce using rule 49 (relational -> relational_operator expression .)
    RPAREN          reduce using rule 49 (relational -> relational_operator expression .)
    PLUS            shift and go to state 92
    MINUS           shift and go to state 93

    expression_operator            shift and go to state 91

state 95

    (59) term -> term TIMES . unary
    (61) unary -> . NOT unary
    (62) unary -> . NEG unary
    (63) unary -> . factor
    (64) factor -> . LPAREN boolean RPAREN
    (65) factor -> . local
    (66) factor -> . NUMBER_INT
    (67) factor -> . NUMBER_FLOAT
    (68) factor -> . FALSE
    (69) factor -> . TRUE
    (31) local -> . ID
    (32) local -> . HASH ID
    (33) local -> . ID local_aux
    (34) local -> . HASH ID local_aux

    NOT             shift and go to state 67
    NEG             shift and go to state 68
    LPAREN          shift and go to state 70
    NUMBER_INT      shift and go to state 71
    NUMBER_FLOAT    shift and go to state 72
    FALSE           shift and go to state 73
    TRUE            shift and go to state 74
    ID              shift and go to state 23
    HASH            shift and go to state 24

    unary                          shift and go to state 113
    factor                         shift and go to state 69
    local                          shift and go to state 54

state 96

    (60) term -> term DIVIDE . unary
    (61) unary -> . NOT unary
    (62) unary -> . NEG unary
    (63) unary -> . factor
    (64) factor -> . LPAREN boolean RPAREN
    (65) factor -> . local
    (66) factor -> . NUMBER_INT
    (67) factor -> . NUMBER_FLOAT
    (68) factor -> . FALSE
    (69) factor -> . TRUE
    (31) local -> . ID
    (32) local -> . HASH ID
    (33) local -> . ID local_aux
    (34) local -> . HASH ID local_aux

    NOT             shift and go to state 67
    NEG             shift and go to state 68
    LPAREN          shift and go to state 70
    NUMBER_INT      shift and go to state 71
    NUMBER_FLOAT    shift and go to state 72
    FALSE           shift and go to state 73
    TRUE            shift and go to state 74
    ID              shift and go to state 23
    HASH            shift and go to state 24

    unary                          shift and go to state 114
    factor                         shift and go to state 69
    local                          shift and go to state 54

state 97

    (61) unary -> NOT unary .

    TIMES           reduce using rule 61 (unary -> NOT unary .)
    DIVIDE          reduce using rule 61 (unary -> NOT unary .)
    PLUS            reduce using rule 61 (unary -> NOT unary .)
    MINUS           reduce using rule 61 (unary -> NOT unary .)
    EQ              reduce using rule 61 (unary -> NOT unary .)
    NEQ             reduce using rule 61 (unary -> NOT unary .)
    AND             reduce using rule 61 (unary -> NOT unary .)
    SEMICOLON       reduce using rule 61 (unary -> NOT unary .)
    OR              reduce using rule 61 (unary -> NOT unary .)
    RBRACK          reduce using rule 61 (unary -> NOT unary .)
    RPAREN          reduce using rule 61 (unary -> NOT unary .)


state 98

    (62) unary -> NEG unary .

    TIMES           reduce using rule 62 (unary -> NEG unary .)
    DIVIDE          reduce using rule 62 (unary -> NEG unary .)
    PLUS            reduce using rule 62 (unary -> NEG unary .)
    MINUS           reduce using rule 62 (unary -> NEG unary .)
    EQ              reduce using rule 62 (unary -> NEG unary .)
    NEQ             reduce using rule 62 (unary -> NEG unary .)
    AND             reduce using rule 62 (unary -> NEG unary .)
    SEMICOLON       reduce using rule 62 (unary -> NEG unary .)
    OR              reduce using rule 62 (unary -> NEG unary .)
    RBRACK          reduce using rule 62 (unary -> NEG unary .)
    RPAREN          reduce using rule 62 (unary -> NEG unary .)


state 99

    (64) factor -> LPAREN boolean . RPAREN
    (42) boolean -> boolean . OR join

    RPAREN          shift and go to state 115
    OR              shift and go to state 87


state 100

    (37) offset -> LBRACK boolean RBRACK . offset
    (37) offset -> . LBRACK boolean RBRACK offset
    (38) offset -> . empty
    (70) empty -> .

    LBRACK          shift and go to state 42
    EQUALS          reduce using rule 70 (empty -> .)
    TIMES           reduce using rule 70 (empty -> .)
    DIVIDE          reduce using rule 70 (empty -> .)
    PLUS            reduce using rule 70 (empty -> .)
    MINUS           reduce using rule 70 (empty -> .)
    EQ              reduce using rule 70 (empty -> .)
    NEQ             reduce using rule 70 (empty -> .)
    AND             reduce using rule 70 (empty -> .)
    SEMICOLON       reduce using rule 70 (empty -> .)
    OR              reduce using rule 70 (empty -> .)
    RBRACK          reduce using rule 70 (empty -> .)
    DOT             reduce using rule 70 (empty -> .)
    RPAREN          reduce using rule 70 (empty -> .)

    offset                         shift and go to state 116
    empty                          shift and go to state 43

state 101

    (39) field -> DOT factor field .

    EQUALS          reduce using rule 39 (field -> DOT factor field .)
    TIMES           reduce using rule 39 (field -> DOT factor field .)
    DIVIDE          reduce using rule 39 (field -> DOT factor field .)
    PLUS            reduce using rule 39 (field -> DOT factor field .)
    MINUS           reduce using rule 39 (field -> DOT factor field .)
    EQ              reduce using rule 39 (field -> DOT factor field .)
    NEQ             reduce using rule 39 (field -> DOT factor field .)
    AND             reduce using rule 39 (field -> DOT factor field .)
    SEMICOLON       reduce using rule 39 (field -> DOT factor field .)
    OR              reduce using rule 39 (field -> DOT factor field .)
    RBRACK          reduce using rule 39 (field -> DOT factor field .)
    DOT             reduce using rule 39 (field -> DOT factor field .)
    RPAREN          reduce using rule 39 (field -> DOT factor field .)


state 102

    (26) conditional -> IF LPAREN boolean RPAREN . statement conditional_aux
    (16) statement -> . local EQUALS boolean SEMICOLON
    (17) statement -> . conditional
    (18) statement -> . while_loop
    (19) statement -> . do_while_loop
    (20) statement -> . BREAK SEMICOLON
    (21) statement -> . print
    (22) statement -> . read
    (23) statement -> . block
    (31) local -> . ID
    (32) local -> . HASH ID
    (33) local -> . ID local_aux
    (34) local -> . HASH ID local_aux
    (26) conditional -> . IF LPAREN boolean RPAREN statement conditional_aux
    (29) while_loop -> . WHILE LPAREN boolean RPAREN statement
    (30) do_while_loop -> . DO statement WHILE LPAREN boolean RPAREN SEMICOLON
    (24) print -> . PRINT LPAREN boolean RPAREN SEMICOLON
    (25) read -> . READ LPAREN local RPAREN SEMICOLON
    (2) block -> . LBRACE declaration statements RBRACE

    BREAK           shift and go to state 19
    ID              shift and go to state 23
    HASH            shift and go to state 24
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    DO              shift and go to state 27
    PRINT           shift and go to state 28
    READ            shift and go to state 29
    LBRACE          shift and go to state 3

    statement                      shift and go to state 117
    local                          shift and go to state 15
    conditional                    shift and go to state 16
    while_loop                     shift and go to state 17
    do_while_loop                  shift and go to state 18
    print                          shift and go to state 20
    read                           shift and go to state 21
    block                          shift and go to state 22

state 103

    (29) while_loop -> WHILE LPAREN boolean RPAREN . statement
    (16) statement -> . local EQUALS boolean SEMICOLON
    (17) statement -> . conditional
    (18) statement -> . while_loop
    (19) statement -> . do_while_loop
    (20) statement -> . BREAK SEMICOLON
    (21) statement -> . print
    (22) statement -> . read
    (23) statement -> . block
    (31) local -> . ID
    (32) local -> . HASH ID
    (33) local -> . ID local_aux
    (34) local -> . HASH ID local_aux
    (26) conditional -> . IF LPAREN boolean RPAREN statement conditional_aux
    (29) while_loop -> . WHILE LPAREN boolean RPAREN statement
    (30) do_while_loop -> . DO statement WHILE LPAREN boolean RPAREN SEMICOLON
    (24) print -> . PRINT LPAREN boolean RPAREN SEMICOLON
    (25) read -> . READ LPAREN local RPAREN SEMICOLON
    (2) block -> . LBRACE declaration statements RBRACE

    BREAK           shift and go to state 19
    ID              shift and go to state 23
    HASH            shift and go to state 24
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    DO              shift and go to state 27
    PRINT           shift and go to state 28
    READ            shift and go to state 29
    LBRACE          shift and go to state 3

    statement                      shift and go to state 118
    local                          shift and go to state 15
    conditional                    shift and go to state 16
    while_loop                     shift and go to state 17
    do_while_loop                  shift and go to state 18
    print                          shift and go to state 20
    read                           shift and go to state 21
    block                          shift and go to state 22

state 104

    (30) do_while_loop -> DO statement WHILE LPAREN . boolean RPAREN SEMICOLON
    (41) boolean -> . join
    (42) boolean -> . boolean OR join
    (43) join -> . equality
    (44) join -> . join AND equality
    (45) equality -> . relational
    (46) equality -> . equality EQ relational
    (47) equality -> . equality NEQ relational
    (48) relational -> . expression
    (49) relational -> . relational_operator expression
    (54) expression -> . term
    (55) expression -> . expression expression_operator term
    (50) relational_operator -> . LT
    (51) relational_operator -> . LE
    (52) relational_operator -> . GT
    (53) relational_operator -> . GE
    (58) term -> . unary
    (59) term -> . term TIMES unary
    (60) term -> . term DIVIDE unary
    (61) unary -> . NOT unary
    (62) unary -> . NEG unary
    (63) unary -> . factor
    (64) factor -> . LPAREN boolean RPAREN
    (65) factor -> . local
    (66) factor -> . NUMBER_INT
    (67) factor -> . NUMBER_FLOAT
    (68) factor -> . FALSE
    (69) factor -> . TRUE
    (31) local -> . ID
    (32) local -> . HASH ID
    (33) local -> . ID local_aux
    (34) local -> . HASH ID local_aux

    LT              shift and go to state 62
    LE              shift and go to state 63
    GT              shift and go to state 64
    GE              shift and go to state 65
    NOT             shift and go to state 67
    NEG             shift and go to state 68
    LPAREN          shift and go to state 70
    NUMBER_INT      shift and go to state 71
    NUMBER_FLOAT    shift and go to state 72
    FALSE           shift and go to state 73
    TRUE            shift and go to state 74
    ID              shift and go to state 23
    HASH            shift and go to state 24

    boolean                        shift and go to state 119
    join                           shift and go to state 56
    equality                       shift and go to state 57
    relational                     shift and go to state 58
    expression                     shift and go to state 59
    relational_operator            shift and go to state 60
    term                           shift and go to state 61
    unary                          shift and go to state 66
    factor                         shift and go to state 69
    local                          shift and go to state 54

state 105

    (24) print -> PRINT LPAREN boolean RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 120


state 106

    (25) read -> READ LPAREN local RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 121


state 107

    (9) dimensions -> LBRACK NUMBER_INT RBRACK dimensions .

    ID              reduce using rule 9 (dimensions -> LBRACK NUMBER_INT RBRACK dimensions .)


state 108

    (42) boolean -> boolean OR join .
    (44) join -> join . AND equality

    SEMICOLON       reduce using rule 42 (boolean -> boolean OR join .)
    OR              reduce using rule 42 (boolean -> boolean OR join .)
    RBRACK          reduce using rule 42 (boolean -> boolean OR join .)
    RPAREN          reduce using rule 42 (boolean -> boolean OR join .)
    AND             shift and go to state 88


state 109

    (44) join -> join AND equality .
    (46) equality -> equality . EQ relational
    (47) equality -> equality . NEQ relational

    AND             reduce using rule 44 (join -> join AND equality .)
    SEMICOLON       reduce using rule 44 (join -> join AND equality .)
    OR              reduce using rule 44 (join -> join AND equality .)
    RBRACK          reduce using rule 44 (join -> join AND equality .)
    RPAREN          reduce using rule 44 (join -> join AND equality .)
    EQ              shift and go to state 89
    NEQ             shift and go to state 90


state 110

    (46) equality -> equality EQ relational .

    EQ              reduce using rule 46 (equality -> equality EQ relational .)
    NEQ             reduce using rule 46 (equality -> equality EQ relational .)
    AND             reduce using rule 46 (equality -> equality EQ relational .)
    SEMICOLON       reduce using rule 46 (equality -> equality EQ relational .)
    OR              reduce using rule 46 (equality -> equality EQ relational .)
    RBRACK          reduce using rule 46 (equality -> equality EQ relational .)
    RPAREN          reduce using rule 46 (equality -> equality EQ relational .)


state 111

    (47) equality -> equality NEQ relational .

    EQ              reduce using rule 47 (equality -> equality NEQ relational .)
    NEQ             reduce using rule 47 (equality -> equality NEQ relational .)
    AND             reduce using rule 47 (equality -> equality NEQ relational .)
    SEMICOLON       reduce using rule 47 (equality -> equality NEQ relational .)
    OR              reduce using rule 47 (equality -> equality NEQ relational .)
    RBRACK          reduce using rule 47 (equality -> equality NEQ relational .)
    RPAREN          reduce using rule 47 (equality -> equality NEQ relational .)


state 112

    (55) expression -> expression expression_operator term .
    (59) term -> term . TIMES unary
    (60) term -> term . DIVIDE unary

    PLUS            reduce using rule 55 (expression -> expression expression_operator term .)
    MINUS           reduce using rule 55 (expression -> expression expression_operator term .)
    EQ              reduce using rule 55 (expression -> expression expression_operator term .)
    NEQ             reduce using rule 55 (expression -> expression expression_operator term .)
    AND             reduce using rule 55 (expression -> expression expression_operator term .)
    SEMICOLON       reduce using rule 55 (expression -> expression expression_operator term .)
    OR              reduce using rule 55 (expression -> expression expression_operator term .)
    RBRACK          reduce using rule 55 (expression -> expression expression_operator term .)
    RPAREN          reduce using rule 55 (expression -> expression expression_operator term .)
    TIMES           shift and go to state 95
    DIVIDE          shift and go to state 96


state 113

    (59) term -> term TIMES unary .

    TIMES           reduce using rule 59 (term -> term TIMES unary .)
    DIVIDE          reduce using rule 59 (term -> term TIMES unary .)
    PLUS            reduce using rule 59 (term -> term TIMES unary .)
    MINUS           reduce using rule 59 (term -> term TIMES unary .)
    EQ              reduce using rule 59 (term -> term TIMES unary .)
    NEQ             reduce using rule 59 (term -> term TIMES unary .)
    AND             reduce using rule 59 (term -> term TIMES unary .)
    SEMICOLON       reduce using rule 59 (term -> term TIMES unary .)
    OR              reduce using rule 59 (term -> term TIMES unary .)
    RBRACK          reduce using rule 59 (term -> term TIMES unary .)
    RPAREN          reduce using rule 59 (term -> term TIMES unary .)


state 114

    (60) term -> term DIVIDE unary .

    TIMES           reduce using rule 60 (term -> term DIVIDE unary .)
    DIVIDE          reduce using rule 60 (term -> term DIVIDE unary .)
    PLUS            reduce using rule 60 (term -> term DIVIDE unary .)
    MINUS           reduce using rule 60 (term -> term DIVIDE unary .)
    EQ              reduce using rule 60 (term -> term DIVIDE unary .)
    NEQ             reduce using rule 60 (term -> term DIVIDE unary .)
    AND             reduce using rule 60 (term -> term DIVIDE unary .)
    SEMICOLON       reduce using rule 60 (term -> term DIVIDE unary .)
    OR              reduce using rule 60 (term -> term DIVIDE unary .)
    RBRACK          reduce using rule 60 (term -> term DIVIDE unary .)
    RPAREN          reduce using rule 60 (term -> term DIVIDE unary .)


state 115

    (64) factor -> LPAREN boolean RPAREN .

    TIMES           reduce using rule 64 (factor -> LPAREN boolean RPAREN .)
    DIVIDE          reduce using rule 64 (factor -> LPAREN boolean RPAREN .)
    PLUS            reduce using rule 64 (factor -> LPAREN boolean RPAREN .)
    MINUS           reduce using rule 64 (factor -> LPAREN boolean RPAREN .)
    EQ              reduce using rule 64 (factor -> LPAREN boolean RPAREN .)
    NEQ             reduce using rule 64 (factor -> LPAREN boolean RPAREN .)
    AND             reduce using rule 64 (factor -> LPAREN boolean RPAREN .)
    SEMICOLON       reduce using rule 64 (factor -> LPAREN boolean RPAREN .)
    OR              reduce using rule 64 (factor -> LPAREN boolean RPAREN .)
    RBRACK          reduce using rule 64 (factor -> LPAREN boolean RPAREN .)
    EQUALS          reduce using rule 64 (factor -> LPAREN boolean RPAREN .)
    DOT             reduce using rule 64 (factor -> LPAREN boolean RPAREN .)
    RPAREN          reduce using rule 64 (factor -> LPAREN boolean RPAREN .)


state 116

    (37) offset -> LBRACK boolean RBRACK offset .

    EQUALS          reduce using rule 37 (offset -> LBRACK boolean RBRACK offset .)
    TIMES           reduce using rule 37 (offset -> LBRACK boolean RBRACK offset .)
    DIVIDE          reduce using rule 37 (offset -> LBRACK boolean RBRACK offset .)
    PLUS            reduce using rule 37 (offset -> LBRACK boolean RBRACK offset .)
    MINUS           reduce using rule 37 (offset -> LBRACK boolean RBRACK offset .)
    EQ              reduce using rule 37 (offset -> LBRACK boolean RBRACK offset .)
    NEQ             reduce using rule 37 (offset -> LBRACK boolean RBRACK offset .)
    AND             reduce using rule 37 (offset -> LBRACK boolean RBRACK offset .)
    SEMICOLON       reduce using rule 37 (offset -> LBRACK boolean RBRACK offset .)
    OR              reduce using rule 37 (offset -> LBRACK boolean RBRACK offset .)
    RBRACK          reduce using rule 37 (offset -> LBRACK boolean RBRACK offset .)
    DOT             reduce using rule 37 (offset -> LBRACK boolean RBRACK offset .)
    RPAREN          reduce using rule 37 (offset -> LBRACK boolean RBRACK offset .)


state 117

    (26) conditional -> IF LPAREN boolean RPAREN statement . conditional_aux
    (27) conditional_aux -> . ELSE statement
    (28) conditional_aux -> . empty
    (70) empty -> .

  ! shift/reduce conflict for ELSE resolved as shift
    ELSE            shift and go to state 123
    BREAK           reduce using rule 70 (empty -> .)
    ID              reduce using rule 70 (empty -> .)
    HASH            reduce using rule 70 (empty -> .)
    IF              reduce using rule 70 (empty -> .)
    WHILE           reduce using rule 70 (empty -> .)
    DO              reduce using rule 70 (empty -> .)
    PRINT           reduce using rule 70 (empty -> .)
    READ            reduce using rule 70 (empty -> .)
    LBRACE          reduce using rule 70 (empty -> .)
    RBRACE          reduce using rule 70 (empty -> .)

  ! ELSE            [ reduce using rule 70 (empty -> .) ]

    conditional_aux                shift and go to state 122
    empty                          shift and go to state 124

state 118

    (29) while_loop -> WHILE LPAREN boolean RPAREN statement .

    BREAK           reduce using rule 29 (while_loop -> WHILE LPAREN boolean RPAREN statement .)
    ID              reduce using rule 29 (while_loop -> WHILE LPAREN boolean RPAREN statement .)
    HASH            reduce using rule 29 (while_loop -> WHILE LPAREN boolean RPAREN statement .)
    IF              reduce using rule 29 (while_loop -> WHILE LPAREN boolean RPAREN statement .)
    WHILE           reduce using rule 29 (while_loop -> WHILE LPAREN boolean RPAREN statement .)
    DO              reduce using rule 29 (while_loop -> WHILE LPAREN boolean RPAREN statement .)
    PRINT           reduce using rule 29 (while_loop -> WHILE LPAREN boolean RPAREN statement .)
    READ            reduce using rule 29 (while_loop -> WHILE LPAREN boolean RPAREN statement .)
    LBRACE          reduce using rule 29 (while_loop -> WHILE LPAREN boolean RPAREN statement .)
    RBRACE          reduce using rule 29 (while_loop -> WHILE LPAREN boolean RPAREN statement .)
    ELSE            reduce using rule 29 (while_loop -> WHILE LPAREN boolean RPAREN statement .)


state 119

    (30) do_while_loop -> DO statement WHILE LPAREN boolean . RPAREN SEMICOLON
    (42) boolean -> boolean . OR join

    RPAREN          shift and go to state 125
    OR              shift and go to state 87


state 120

    (24) print -> PRINT LPAREN boolean RPAREN SEMICOLON .

    BREAK           reduce using rule 24 (print -> PRINT LPAREN boolean RPAREN SEMICOLON .)
    ID              reduce using rule 24 (print -> PRINT LPAREN boolean RPAREN SEMICOLON .)
    HASH            reduce using rule 24 (print -> PRINT LPAREN boolean RPAREN SEMICOLON .)
    IF              reduce using rule 24 (print -> PRINT LPAREN boolean RPAREN SEMICOLON .)
    WHILE           reduce using rule 24 (print -> PRINT LPAREN boolean RPAREN SEMICOLON .)
    DO              reduce using rule 24 (print -> PRINT LPAREN boolean RPAREN SEMICOLON .)
    PRINT           reduce using rule 24 (print -> PRINT LPAREN boolean RPAREN SEMICOLON .)
    READ            reduce using rule 24 (print -> PRINT LPAREN boolean RPAREN SEMICOLON .)
    LBRACE          reduce using rule 24 (print -> PRINT LPAREN boolean RPAREN SEMICOLON .)
    RBRACE          reduce using rule 24 (print -> PRINT LPAREN boolean RPAREN SEMICOLON .)
    ELSE            reduce using rule 24 (print -> PRINT LPAREN boolean RPAREN SEMICOLON .)


state 121

    (25) read -> READ LPAREN local RPAREN SEMICOLON .

    BREAK           reduce using rule 25 (read -> READ LPAREN local RPAREN SEMICOLON .)
    ID              reduce using rule 25 (read -> READ LPAREN local RPAREN SEMICOLON .)
    HASH            reduce using rule 25 (read -> READ LPAREN local RPAREN SEMICOLON .)
    IF              reduce using rule 25 (read -> READ LPAREN local RPAREN SEMICOLON .)
    WHILE           reduce using rule 25 (read -> READ LPAREN local RPAREN SEMICOLON .)
    DO              reduce using rule 25 (read -> READ LPAREN local RPAREN SEMICOLON .)
    PRINT           reduce using rule 25 (read -> READ LPAREN local RPAREN SEMICOLON .)
    READ            reduce using rule 25 (read -> READ LPAREN local RPAREN SEMICOLON .)
    LBRACE          reduce using rule 25 (read -> READ LPAREN local RPAREN SEMICOLON .)
    RBRACE          reduce using rule 25 (read -> READ LPAREN local RPAREN SEMICOLON .)
    ELSE            reduce using rule 25 (read -> READ LPAREN local RPAREN SEMICOLON .)


state 122

    (26) conditional -> IF LPAREN boolean RPAREN statement conditional_aux .

    BREAK           reduce using rule 26 (conditional -> IF LPAREN boolean RPAREN statement conditional_aux .)
    ID              reduce using rule 26 (conditional -> IF LPAREN boolean RPAREN statement conditional_aux .)
    HASH            reduce using rule 26 (conditional -> IF LPAREN boolean RPAREN statement conditional_aux .)
    IF              reduce using rule 26 (conditional -> IF LPAREN boolean RPAREN statement conditional_aux .)
    WHILE           reduce using rule 26 (conditional -> IF LPAREN boolean RPAREN statement conditional_aux .)
    DO              reduce using rule 26 (conditional -> IF LPAREN boolean RPAREN statement conditional_aux .)
    PRINT           reduce using rule 26 (conditional -> IF LPAREN boolean RPAREN statement conditional_aux .)
    READ            reduce using rule 26 (conditional -> IF LPAREN boolean RPAREN statement conditional_aux .)
    LBRACE          reduce using rule 26 (conditional -> IF LPAREN boolean RPAREN statement conditional_aux .)
    RBRACE          reduce using rule 26 (conditional -> IF LPAREN boolean RPAREN statement conditional_aux .)
    ELSE            reduce using rule 26 (conditional -> IF LPAREN boolean RPAREN statement conditional_aux .)


state 123

    (27) conditional_aux -> ELSE . statement
    (16) statement -> . local EQUALS boolean SEMICOLON
    (17) statement -> . conditional
    (18) statement -> . while_loop
    (19) statement -> . do_while_loop
    (20) statement -> . BREAK SEMICOLON
    (21) statement -> . print
    (22) statement -> . read
    (23) statement -> . block
    (31) local -> . ID
    (32) local -> . HASH ID
    (33) local -> . ID local_aux
    (34) local -> . HASH ID local_aux
    (26) conditional -> . IF LPAREN boolean RPAREN statement conditional_aux
    (29) while_loop -> . WHILE LPAREN boolean RPAREN statement
    (30) do_while_loop -> . DO statement WHILE LPAREN boolean RPAREN SEMICOLON
    (24) print -> . PRINT LPAREN boolean RPAREN SEMICOLON
    (25) read -> . READ LPAREN local RPAREN SEMICOLON
    (2) block -> . LBRACE declaration statements RBRACE

    BREAK           shift and go to state 19
    ID              shift and go to state 23
    HASH            shift and go to state 24
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    DO              shift and go to state 27
    PRINT           shift and go to state 28
    READ            shift and go to state 29
    LBRACE          shift and go to state 3

    statement                      shift and go to state 126
    local                          shift and go to state 15
    conditional                    shift and go to state 16
    while_loop                     shift and go to state 17
    do_while_loop                  shift and go to state 18
    print                          shift and go to state 20
    read                           shift and go to state 21
    block                          shift and go to state 22

state 124

    (28) conditional_aux -> empty .

    ELSE            reduce using rule 28 (conditional_aux -> empty .)
    BREAK           reduce using rule 28 (conditional_aux -> empty .)
    ID              reduce using rule 28 (conditional_aux -> empty .)
    HASH            reduce using rule 28 (conditional_aux -> empty .)
    IF              reduce using rule 28 (conditional_aux -> empty .)
    WHILE           reduce using rule 28 (conditional_aux -> empty .)
    DO              reduce using rule 28 (conditional_aux -> empty .)
    PRINT           reduce using rule 28 (conditional_aux -> empty .)
    READ            reduce using rule 28 (conditional_aux -> empty .)
    LBRACE          reduce using rule 28 (conditional_aux -> empty .)
    RBRACE          reduce using rule 28 (conditional_aux -> empty .)


state 125

    (30) do_while_loop -> DO statement WHILE LPAREN boolean RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 127


state 126

    (27) conditional_aux -> ELSE statement .

    ELSE            reduce using rule 27 (conditional_aux -> ELSE statement .)
    BREAK           reduce using rule 27 (conditional_aux -> ELSE statement .)
    ID              reduce using rule 27 (conditional_aux -> ELSE statement .)
    HASH            reduce using rule 27 (conditional_aux -> ELSE statement .)
    IF              reduce using rule 27 (conditional_aux -> ELSE statement .)
    WHILE           reduce using rule 27 (conditional_aux -> ELSE statement .)
    DO              reduce using rule 27 (conditional_aux -> ELSE statement .)
    PRINT           reduce using rule 27 (conditional_aux -> ELSE statement .)
    READ            reduce using rule 27 (conditional_aux -> ELSE statement .)
    LBRACE          reduce using rule 27 (conditional_aux -> ELSE statement .)
    RBRACE          reduce using rule 27 (conditional_aux -> ELSE statement .)


state 127

    (30) do_while_loop -> DO statement WHILE LPAREN boolean RPAREN SEMICOLON .

    BREAK           reduce using rule 30 (do_while_loop -> DO statement WHILE LPAREN boolean RPAREN SEMICOLON .)
    ID              reduce using rule 30 (do_while_loop -> DO statement WHILE LPAREN boolean RPAREN SEMICOLON .)
    HASH            reduce using rule 30 (do_while_loop -> DO statement WHILE LPAREN boolean RPAREN SEMICOLON .)
    IF              reduce using rule 30 (do_while_loop -> DO statement WHILE LPAREN boolean RPAREN SEMICOLON .)
    WHILE           reduce using rule 30 (do_while_loop -> DO statement WHILE LPAREN boolean RPAREN SEMICOLON .)
    DO              reduce using rule 30 (do_while_loop -> DO statement WHILE LPAREN boolean RPAREN SEMICOLON .)
    PRINT           reduce using rule 30 (do_while_loop -> DO statement WHILE LPAREN boolean RPAREN SEMICOLON .)
    READ            reduce using rule 30 (do_while_loop -> DO statement WHILE LPAREN boolean RPAREN SEMICOLON .)
    LBRACE          reduce using rule 30 (do_while_loop -> DO statement WHILE LPAREN boolean RPAREN SEMICOLON .)
    RBRACE          reduce using rule 30 (do_while_loop -> DO statement WHILE LPAREN boolean RPAREN SEMICOLON .)
    ELSE            reduce using rule 30 (do_while_loop -> DO statement WHILE LPAREN boolean RPAREN SEMICOLON .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for DOT in state 23 resolved as shift
WARNING: shift/reduce conflict for DOT in state 23 resolved as shift
WARNING: shift/reduce conflict for DOT in state 45 resolved as shift
WARNING: shift/reduce conflict for DOT in state 45 resolved as shift
WARNING: shift/reduce conflict for DOT in state 76 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 117 resolved as shift
WARNING: reduce/reduce conflict in state 23 resolved using rule (local -> ID)
WARNING: rejected rule (empty -> <empty>) in state 23
WARNING: reduce/reduce conflict in state 45 resolved using rule (local -> HASH ID)
WARNING: rejected rule (empty -> <empty>) in state 45
