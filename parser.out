Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> block
Rule 2     block -> LBRACE declaration statements RBRACE
Rule 3     declaration -> type ID SEMICOLON declaration
Rule 4     declaration -> empty
Rule 5     type -> basic dimensions
Rule 6     type -> basic HASH
Rule 7     type -> basic
Rule 8     type -> RECORD LBRACE declaration RBRACE
Rule 9     dimensions -> LBRACK NUMBER_INT RBRACK dimensions
Rule 10    dimensions -> LBRACK NUMBER_INT RBRACK
Rule 11    basic -> INT
Rule 12    basic -> CHAR
Rule 13    basic -> BOOL
Rule 14    statements -> statement statements
Rule 15    statements -> empty
Rule 16    statement -> local EQUALS boolean SEMICOLON
Rule 17    statement -> conditional
Rule 18    statement -> while_loop
Rule 19    statement -> do_while_loop
Rule 20    statement -> BREAK SEMICOLON
Rule 21    statement -> print
Rule 22    statement -> read
Rule 23    statement -> block
Rule 24    print -> PRINT LPAREN boolean RPAREN SEMICOLON
Rule 25    read -> READ LPAREN local RPAREN SEMICOLON
Rule 26    conditional -> IF LPAREN boolean RPAREN statement conditional_aux
Rule 27    conditional_aux -> ELSE statement
Rule 28    conditional_aux -> empty
Rule 29    while_loop -> WHILE LPAREN boolean RPAREN statement
Rule 30    do_while_loop -> DO statement WHILE LPAREN boolean RPAREN SEMICOLON
Rule 31    local -> HASH ID local_aux
Rule 32    local -> ID local_aux
Rule 33    local_aux -> offset
Rule 34    local_aux -> field
Rule 35    local_aux -> empty
Rule 36    offset -> LBRACK boolean RBRACK offset
Rule 37    offset -> empty
Rule 38    field -> DOT factor field
Rule 39    field -> DOT factor
Rule 40    boolean -> join boolean_aux
Rule 41    boolean_aux -> OR join boolean_aux
Rule 42    boolean_aux -> empty
Rule 43    join -> equality join_aux
Rule 44    join_aux -> AND equality join_aux
Rule 45    join_aux -> empty
Rule 46    equality -> relational equality_aux
Rule 47    equality_aux -> EQ relational equality_aux
Rule 48    equality_aux -> NEQ relational equality_aux
Rule 49    equality_aux -> empty
Rule 50    relational -> expression relational_operator expression
Rule 51    relational_operator -> LT
Rule 52    relational_operator -> LE
Rule 53    relational_operator -> GT
Rule 54    relational_operator -> GE
Rule 55    expression -> term expression_aux
Rule 56    expression_aux -> expression_operator term expression_aux
Rule 57    expression_aux -> empty
Rule 58    expression_operator -> PLUS
Rule 59    expression_operator -> MINUS
Rule 60    term -> unary term_aux
Rule 61    term_aux -> TIMES unary term_aux
Rule 62    term_aux -> DIVIDE unary term_aux
Rule 63    term_aux -> empty
Rule 64    unary -> NOT unary
Rule 65    unary -> NEG unary
Rule 66    unary -> factor
Rule 67    factor -> LPAREN boolean RPAREN
Rule 68    factor -> local
Rule 69    factor -> NUMBER_INT
Rule 70    factor -> NUMBER_FLOAT
Rule 71    factor -> FALSE
Rule 72    factor -> TRUE
Rule 73    empty -> <empty>

Terminals, with rules where they appear

AND                  : 44
BOOL                 : 13
BREAK                : 20
CHAR                 : 12
DIVIDE               : 62
DO                   : 30
DOT                  : 38 39
ELSE                 : 27
EQ                   : 47
EQUALS               : 16
FALSE                : 71
GE                   : 54
GT                   : 53
HASH                 : 6 31
ID                   : 3 31 32
IF                   : 26
INT                  : 11
LBRACE               : 2 8
LBRACK               : 9 10 36
LE                   : 52
LPAREN               : 24 25 26 29 30 67
LT                   : 51
MINUS                : 59
NEG                  : 65
NEQ                  : 48
NOT                  : 64
NUMBER_FLOAT         : 70
NUMBER_INT           : 9 10 69
OR                   : 41
PLUS                 : 58
PRINT                : 24
RBRACE               : 2 8
RBRACK               : 9 10 36
READ                 : 25
RECORD               : 8
RPAREN               : 24 25 26 29 30 67
SEMICOLON            : 3 16 20 24 25 30
TIMES                : 61
TRUE                 : 72
WHILE                : 29 30
error                : 

Nonterminals, with rules where they appear

basic                : 5 6 7
block                : 1 23
boolean              : 16 24 26 29 30 36 67
boolean_aux          : 40 41
conditional          : 17
conditional_aux      : 26
declaration          : 2 3 8
dimensions           : 5 9
do_while_loop        : 19
empty                : 4 15 28 35 37 42 45 49 57 63
equality             : 43 44
equality_aux         : 46 47 48
expression           : 50 50
expression_aux       : 55 56
expression_operator  : 56
factor               : 38 39 66
field                : 34 38
join                 : 40 41
join_aux             : 43 44
local                : 16 25 68
local_aux            : 31 32
offset               : 33 36
print                : 21
program              : 0
read                 : 22
relational           : 46 47 48
relational_operator  : 50
statement            : 14 26 27 29 30
statements           : 2 14
term                 : 55 56
term_aux             : 60 61 62
type                 : 3
unary                : 60 61 62 64 65
while_loop           : 18

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . block
    (2) block -> . LBRACE declaration statements RBRACE

    LBRACE          shift and go to state 3

    program                        shift and go to state 1
    block                          shift and go to state 2

state 1

    (0) S' -> program .



state 2

    (1) program -> block .

    $end            reduce using rule 1 (program -> block .)


state 3

    (2) block -> LBRACE . declaration statements RBRACE
    (3) declaration -> . type ID SEMICOLON declaration
    (4) declaration -> . empty
    (5) type -> . basic dimensions
    (6) type -> . basic HASH
    (7) type -> . basic
    (8) type -> . RECORD LBRACE declaration RBRACE
    (73) empty -> .
    (11) basic -> . INT
    (12) basic -> . CHAR
    (13) basic -> . BOOL

    RECORD          shift and go to state 8
    BREAK           reduce using rule 73 (empty -> .)
    HASH            reduce using rule 73 (empty -> .)
    ID              reduce using rule 73 (empty -> .)
    IF              reduce using rule 73 (empty -> .)
    WHILE           reduce using rule 73 (empty -> .)
    DO              reduce using rule 73 (empty -> .)
    PRINT           reduce using rule 73 (empty -> .)
    READ            reduce using rule 73 (empty -> .)
    LBRACE          reduce using rule 73 (empty -> .)
    RBRACE          reduce using rule 73 (empty -> .)
    INT             shift and go to state 9
    CHAR            shift and go to state 10
    BOOL            shift and go to state 11

    declaration                    shift and go to state 4
    type                           shift and go to state 5
    empty                          shift and go to state 6
    basic                          shift and go to state 7

state 4

    (2) block -> LBRACE declaration . statements RBRACE
    (14) statements -> . statement statements
    (15) statements -> . empty
    (16) statement -> . local EQUALS boolean SEMICOLON
    (17) statement -> . conditional
    (18) statement -> . while_loop
    (19) statement -> . do_while_loop
    (20) statement -> . BREAK SEMICOLON
    (21) statement -> . print
    (22) statement -> . read
    (23) statement -> . block
    (73) empty -> .
    (31) local -> . HASH ID local_aux
    (32) local -> . ID local_aux
    (26) conditional -> . IF LPAREN boolean RPAREN statement conditional_aux
    (29) while_loop -> . WHILE LPAREN boolean RPAREN statement
    (30) do_while_loop -> . DO statement WHILE LPAREN boolean RPAREN SEMICOLON
    (24) print -> . PRINT LPAREN boolean RPAREN SEMICOLON
    (25) read -> . READ LPAREN local RPAREN SEMICOLON
    (2) block -> . LBRACE declaration statements RBRACE

    BREAK           shift and go to state 19
    RBRACE          reduce using rule 73 (empty -> .)
    HASH            shift and go to state 23
    ID              shift and go to state 24
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    DO              shift and go to state 27
    PRINT           shift and go to state 28
    READ            shift and go to state 29
    LBRACE          shift and go to state 3

    statements                     shift and go to state 12
    statement                      shift and go to state 13
    empty                          shift and go to state 14
    local                          shift and go to state 15
    conditional                    shift and go to state 16
    while_loop                     shift and go to state 17
    do_while_loop                  shift and go to state 18
    print                          shift and go to state 20
    read                           shift and go to state 21
    block                          shift and go to state 22

state 5

    (3) declaration -> type . ID SEMICOLON declaration

    ID              shift and go to state 30


state 6

    (4) declaration -> empty .

    BREAK           reduce using rule 4 (declaration -> empty .)
    HASH            reduce using rule 4 (declaration -> empty .)
    ID              reduce using rule 4 (declaration -> empty .)
    IF              reduce using rule 4 (declaration -> empty .)
    WHILE           reduce using rule 4 (declaration -> empty .)
    DO              reduce using rule 4 (declaration -> empty .)
    PRINT           reduce using rule 4 (declaration -> empty .)
    READ            reduce using rule 4 (declaration -> empty .)
    LBRACE          reduce using rule 4 (declaration -> empty .)
    RBRACE          reduce using rule 4 (declaration -> empty .)


state 7

    (5) type -> basic . dimensions
    (6) type -> basic . HASH
    (7) type -> basic .
    (9) dimensions -> . LBRACK NUMBER_INT RBRACK dimensions
    (10) dimensions -> . LBRACK NUMBER_INT RBRACK

    HASH            shift and go to state 32
    ID              reduce using rule 7 (type -> basic .)
    LBRACK          shift and go to state 33

    dimensions                     shift and go to state 31

state 8

    (8) type -> RECORD . LBRACE declaration RBRACE

    LBRACE          shift and go to state 34


state 9

    (11) basic -> INT .

    HASH            reduce using rule 11 (basic -> INT .)
    LBRACK          reduce using rule 11 (basic -> INT .)
    ID              reduce using rule 11 (basic -> INT .)


state 10

    (12) basic -> CHAR .

    HASH            reduce using rule 12 (basic -> CHAR .)
    LBRACK          reduce using rule 12 (basic -> CHAR .)
    ID              reduce using rule 12 (basic -> CHAR .)


state 11

    (13) basic -> BOOL .

    HASH            reduce using rule 13 (basic -> BOOL .)
    LBRACK          reduce using rule 13 (basic -> BOOL .)
    ID              reduce using rule 13 (basic -> BOOL .)


state 12

    (2) block -> LBRACE declaration statements . RBRACE

    RBRACE          shift and go to state 35


state 13

    (14) statements -> statement . statements
    (14) statements -> . statement statements
    (15) statements -> . empty
    (16) statement -> . local EQUALS boolean SEMICOLON
    (17) statement -> . conditional
    (18) statement -> . while_loop
    (19) statement -> . do_while_loop
    (20) statement -> . BREAK SEMICOLON
    (21) statement -> . print
    (22) statement -> . read
    (23) statement -> . block
    (73) empty -> .
    (31) local -> . HASH ID local_aux
    (32) local -> . ID local_aux
    (26) conditional -> . IF LPAREN boolean RPAREN statement conditional_aux
    (29) while_loop -> . WHILE LPAREN boolean RPAREN statement
    (30) do_while_loop -> . DO statement WHILE LPAREN boolean RPAREN SEMICOLON
    (24) print -> . PRINT LPAREN boolean RPAREN SEMICOLON
    (25) read -> . READ LPAREN local RPAREN SEMICOLON
    (2) block -> . LBRACE declaration statements RBRACE

    BREAK           shift and go to state 19
    RBRACE          reduce using rule 73 (empty -> .)
    HASH            shift and go to state 23
    ID              shift and go to state 24
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    DO              shift and go to state 27
    PRINT           shift and go to state 28
    READ            shift and go to state 29
    LBRACE          shift and go to state 3

    statement                      shift and go to state 13
    statements                     shift and go to state 36
    empty                          shift and go to state 14
    local                          shift and go to state 15
    conditional                    shift and go to state 16
    while_loop                     shift and go to state 17
    do_while_loop                  shift and go to state 18
    print                          shift and go to state 20
    read                           shift and go to state 21
    block                          shift and go to state 22

state 14

    (15) statements -> empty .

    RBRACE          reduce using rule 15 (statements -> empty .)


state 15

    (16) statement -> local . EQUALS boolean SEMICOLON

    EQUALS          shift and go to state 37


state 16

    (17) statement -> conditional .

    BREAK           reduce using rule 17 (statement -> conditional .)
    HASH            reduce using rule 17 (statement -> conditional .)
    ID              reduce using rule 17 (statement -> conditional .)
    IF              reduce using rule 17 (statement -> conditional .)
    WHILE           reduce using rule 17 (statement -> conditional .)
    DO              reduce using rule 17 (statement -> conditional .)
    PRINT           reduce using rule 17 (statement -> conditional .)
    READ            reduce using rule 17 (statement -> conditional .)
    LBRACE          reduce using rule 17 (statement -> conditional .)
    RBRACE          reduce using rule 17 (statement -> conditional .)
    ELSE            reduce using rule 17 (statement -> conditional .)


state 17

    (18) statement -> while_loop .

    BREAK           reduce using rule 18 (statement -> while_loop .)
    HASH            reduce using rule 18 (statement -> while_loop .)
    ID              reduce using rule 18 (statement -> while_loop .)
    IF              reduce using rule 18 (statement -> while_loop .)
    WHILE           reduce using rule 18 (statement -> while_loop .)
    DO              reduce using rule 18 (statement -> while_loop .)
    PRINT           reduce using rule 18 (statement -> while_loop .)
    READ            reduce using rule 18 (statement -> while_loop .)
    LBRACE          reduce using rule 18 (statement -> while_loop .)
    RBRACE          reduce using rule 18 (statement -> while_loop .)
    ELSE            reduce using rule 18 (statement -> while_loop .)


state 18

    (19) statement -> do_while_loop .

    BREAK           reduce using rule 19 (statement -> do_while_loop .)
    HASH            reduce using rule 19 (statement -> do_while_loop .)
    ID              reduce using rule 19 (statement -> do_while_loop .)
    IF              reduce using rule 19 (statement -> do_while_loop .)
    WHILE           reduce using rule 19 (statement -> do_while_loop .)
    DO              reduce using rule 19 (statement -> do_while_loop .)
    PRINT           reduce using rule 19 (statement -> do_while_loop .)
    READ            reduce using rule 19 (statement -> do_while_loop .)
    LBRACE          reduce using rule 19 (statement -> do_while_loop .)
    RBRACE          reduce using rule 19 (statement -> do_while_loop .)
    ELSE            reduce using rule 19 (statement -> do_while_loop .)


state 19

    (20) statement -> BREAK . SEMICOLON

    SEMICOLON       shift and go to state 38


state 20

    (21) statement -> print .

    BREAK           reduce using rule 21 (statement -> print .)
    HASH            reduce using rule 21 (statement -> print .)
    ID              reduce using rule 21 (statement -> print .)
    IF              reduce using rule 21 (statement -> print .)
    WHILE           reduce using rule 21 (statement -> print .)
    DO              reduce using rule 21 (statement -> print .)
    PRINT           reduce using rule 21 (statement -> print .)
    READ            reduce using rule 21 (statement -> print .)
    LBRACE          reduce using rule 21 (statement -> print .)
    RBRACE          reduce using rule 21 (statement -> print .)
    ELSE            reduce using rule 21 (statement -> print .)


state 21

    (22) statement -> read .

    BREAK           reduce using rule 22 (statement -> read .)
    HASH            reduce using rule 22 (statement -> read .)
    ID              reduce using rule 22 (statement -> read .)
    IF              reduce using rule 22 (statement -> read .)
    WHILE           reduce using rule 22 (statement -> read .)
    DO              reduce using rule 22 (statement -> read .)
    PRINT           reduce using rule 22 (statement -> read .)
    READ            reduce using rule 22 (statement -> read .)
    LBRACE          reduce using rule 22 (statement -> read .)
    RBRACE          reduce using rule 22 (statement -> read .)
    ELSE            reduce using rule 22 (statement -> read .)


state 22

    (23) statement -> block .

    BREAK           reduce using rule 23 (statement -> block .)
    HASH            reduce using rule 23 (statement -> block .)
    ID              reduce using rule 23 (statement -> block .)
    IF              reduce using rule 23 (statement -> block .)
    WHILE           reduce using rule 23 (statement -> block .)
    DO              reduce using rule 23 (statement -> block .)
    PRINT           reduce using rule 23 (statement -> block .)
    READ            reduce using rule 23 (statement -> block .)
    LBRACE          reduce using rule 23 (statement -> block .)
    RBRACE          reduce using rule 23 (statement -> block .)
    ELSE            reduce using rule 23 (statement -> block .)


state 23

    (31) local -> HASH . ID local_aux

    ID              shift and go to state 39


state 24

    (32) local -> ID . local_aux
    (33) local_aux -> . offset
    (34) local_aux -> . field
    (35) local_aux -> . empty
    (36) offset -> . LBRACK boolean RBRACK offset
    (37) offset -> . empty
    (38) field -> . DOT factor field
    (39) field -> . DOT factor
    (73) empty -> .

  ! shift/reduce conflict for DOT resolved as shift
    LBRACK          shift and go to state 44
    DOT             shift and go to state 45
    EQUALS          reduce using rule 73 (empty -> .)
    TIMES           reduce using rule 73 (empty -> .)
    DIVIDE          reduce using rule 73 (empty -> .)
    PLUS            reduce using rule 73 (empty -> .)
    MINUS           reduce using rule 73 (empty -> .)
    LT              reduce using rule 73 (empty -> .)
    LE              reduce using rule 73 (empty -> .)
    GT              reduce using rule 73 (empty -> .)
    GE              reduce using rule 73 (empty -> .)
    RPAREN          reduce using rule 73 (empty -> .)
    EQ              reduce using rule 73 (empty -> .)
    NEQ             reduce using rule 73 (empty -> .)
    AND             reduce using rule 73 (empty -> .)
    OR              reduce using rule 73 (empty -> .)
    SEMICOLON       reduce using rule 73 (empty -> .)
    RBRACK          reduce using rule 73 (empty -> .)

  ! DOT             [ reduce using rule 73 (empty -> .) ]

    local_aux                      shift and go to state 40
    offset                         shift and go to state 41
    field                          shift and go to state 42
    empty                          shift and go to state 43

state 25

    (26) conditional -> IF . LPAREN boolean RPAREN statement conditional_aux

    LPAREN          shift and go to state 46


state 26

    (29) while_loop -> WHILE . LPAREN boolean RPAREN statement

    LPAREN          shift and go to state 47


state 27

    (30) do_while_loop -> DO . statement WHILE LPAREN boolean RPAREN SEMICOLON
    (16) statement -> . local EQUALS boolean SEMICOLON
    (17) statement -> . conditional
    (18) statement -> . while_loop
    (19) statement -> . do_while_loop
    (20) statement -> . BREAK SEMICOLON
    (21) statement -> . print
    (22) statement -> . read
    (23) statement -> . block
    (31) local -> . HASH ID local_aux
    (32) local -> . ID local_aux
    (26) conditional -> . IF LPAREN boolean RPAREN statement conditional_aux
    (29) while_loop -> . WHILE LPAREN boolean RPAREN statement
    (30) do_while_loop -> . DO statement WHILE LPAREN boolean RPAREN SEMICOLON
    (24) print -> . PRINT LPAREN boolean RPAREN SEMICOLON
    (25) read -> . READ LPAREN local RPAREN SEMICOLON
    (2) block -> . LBRACE declaration statements RBRACE

    BREAK           shift and go to state 19
    HASH            shift and go to state 23
    ID              shift and go to state 24
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    DO              shift and go to state 27
    PRINT           shift and go to state 28
    READ            shift and go to state 29
    LBRACE          shift and go to state 3

    statement                      shift and go to state 48
    local                          shift and go to state 15
    conditional                    shift and go to state 16
    while_loop                     shift and go to state 17
    do_while_loop                  shift and go to state 18
    print                          shift and go to state 20
    read                           shift and go to state 21
    block                          shift and go to state 22

state 28

    (24) print -> PRINT . LPAREN boolean RPAREN SEMICOLON

    LPAREN          shift and go to state 49


state 29

    (25) read -> READ . LPAREN local RPAREN SEMICOLON

    LPAREN          shift and go to state 50


state 30

    (3) declaration -> type ID . SEMICOLON declaration

    SEMICOLON       shift and go to state 51


state 31

    (5) type -> basic dimensions .

    ID              reduce using rule 5 (type -> basic dimensions .)


state 32

    (6) type -> basic HASH .

    ID              reduce using rule 6 (type -> basic HASH .)


state 33

    (9) dimensions -> LBRACK . NUMBER_INT RBRACK dimensions
    (10) dimensions -> LBRACK . NUMBER_INT RBRACK

    NUMBER_INT      shift and go to state 52


state 34

    (8) type -> RECORD LBRACE . declaration RBRACE
    (3) declaration -> . type ID SEMICOLON declaration
    (4) declaration -> . empty
    (5) type -> . basic dimensions
    (6) type -> . basic HASH
    (7) type -> . basic
    (8) type -> . RECORD LBRACE declaration RBRACE
    (73) empty -> .
    (11) basic -> . INT
    (12) basic -> . CHAR
    (13) basic -> . BOOL

    RECORD          shift and go to state 8
    RBRACE          reduce using rule 73 (empty -> .)
    INT             shift and go to state 9
    CHAR            shift and go to state 10
    BOOL            shift and go to state 11

    declaration                    shift and go to state 53
    type                           shift and go to state 5
    empty                          shift and go to state 6
    basic                          shift and go to state 7

state 35

    (2) block -> LBRACE declaration statements RBRACE .

    $end            reduce using rule 2 (block -> LBRACE declaration statements RBRACE .)
    BREAK           reduce using rule 2 (block -> LBRACE declaration statements RBRACE .)
    HASH            reduce using rule 2 (block -> LBRACE declaration statements RBRACE .)
    ID              reduce using rule 2 (block -> LBRACE declaration statements RBRACE .)
    IF              reduce using rule 2 (block -> LBRACE declaration statements RBRACE .)
    WHILE           reduce using rule 2 (block -> LBRACE declaration statements RBRACE .)
    DO              reduce using rule 2 (block -> LBRACE declaration statements RBRACE .)
    PRINT           reduce using rule 2 (block -> LBRACE declaration statements RBRACE .)
    READ            reduce using rule 2 (block -> LBRACE declaration statements RBRACE .)
    LBRACE          reduce using rule 2 (block -> LBRACE declaration statements RBRACE .)
    RBRACE          reduce using rule 2 (block -> LBRACE declaration statements RBRACE .)
    ELSE            reduce using rule 2 (block -> LBRACE declaration statements RBRACE .)


state 36

    (14) statements -> statement statements .

    RBRACE          reduce using rule 14 (statements -> statement statements .)


state 37

    (16) statement -> local EQUALS . boolean SEMICOLON
    (40) boolean -> . join boolean_aux
    (43) join -> . equality join_aux
    (46) equality -> . relational equality_aux
    (50) relational -> . expression relational_operator expression
    (55) expression -> . term expression_aux
    (60) term -> . unary term_aux
    (64) unary -> . NOT unary
    (65) unary -> . NEG unary
    (66) unary -> . factor
    (67) factor -> . LPAREN boolean RPAREN
    (68) factor -> . local
    (69) factor -> . NUMBER_INT
    (70) factor -> . NUMBER_FLOAT
    (71) factor -> . FALSE
    (72) factor -> . TRUE
    (31) local -> . HASH ID local_aux
    (32) local -> . ID local_aux

    NOT             shift and go to state 62
    NEG             shift and go to state 63
    LPAREN          shift and go to state 65
    NUMBER_INT      shift and go to state 66
    NUMBER_FLOAT    shift and go to state 67
    FALSE           shift and go to state 68
    TRUE            shift and go to state 69
    HASH            shift and go to state 23
    ID              shift and go to state 24

    local                          shift and go to state 54
    boolean                        shift and go to state 55
    join                           shift and go to state 56
    equality                       shift and go to state 57
    relational                     shift and go to state 58
    expression                     shift and go to state 59
    term                           shift and go to state 60
    unary                          shift and go to state 61
    factor                         shift and go to state 64

state 38

    (20) statement -> BREAK SEMICOLON .

    BREAK           reduce using rule 20 (statement -> BREAK SEMICOLON .)
    HASH            reduce using rule 20 (statement -> BREAK SEMICOLON .)
    ID              reduce using rule 20 (statement -> BREAK SEMICOLON .)
    IF              reduce using rule 20 (statement -> BREAK SEMICOLON .)
    WHILE           reduce using rule 20 (statement -> BREAK SEMICOLON .)
    DO              reduce using rule 20 (statement -> BREAK SEMICOLON .)
    PRINT           reduce using rule 20 (statement -> BREAK SEMICOLON .)
    READ            reduce using rule 20 (statement -> BREAK SEMICOLON .)
    LBRACE          reduce using rule 20 (statement -> BREAK SEMICOLON .)
    RBRACE          reduce using rule 20 (statement -> BREAK SEMICOLON .)
    ELSE            reduce using rule 20 (statement -> BREAK SEMICOLON .)


state 39

    (31) local -> HASH ID . local_aux
    (33) local_aux -> . offset
    (34) local_aux -> . field
    (35) local_aux -> . empty
    (36) offset -> . LBRACK boolean RBRACK offset
    (37) offset -> . empty
    (38) field -> . DOT factor field
    (39) field -> . DOT factor
    (73) empty -> .

  ! shift/reduce conflict for DOT resolved as shift
    LBRACK          shift and go to state 44
    DOT             shift and go to state 45
    EQUALS          reduce using rule 73 (empty -> .)
    TIMES           reduce using rule 73 (empty -> .)
    DIVIDE          reduce using rule 73 (empty -> .)
    PLUS            reduce using rule 73 (empty -> .)
    MINUS           reduce using rule 73 (empty -> .)
    LT              reduce using rule 73 (empty -> .)
    LE              reduce using rule 73 (empty -> .)
    GT              reduce using rule 73 (empty -> .)
    GE              reduce using rule 73 (empty -> .)
    RPAREN          reduce using rule 73 (empty -> .)
    EQ              reduce using rule 73 (empty -> .)
    NEQ             reduce using rule 73 (empty -> .)
    AND             reduce using rule 73 (empty -> .)
    OR              reduce using rule 73 (empty -> .)
    SEMICOLON       reduce using rule 73 (empty -> .)
    RBRACK          reduce using rule 73 (empty -> .)

  ! DOT             [ reduce using rule 73 (empty -> .) ]

    local_aux                      shift and go to state 70
    offset                         shift and go to state 41
    field                          shift and go to state 42
    empty                          shift and go to state 43

state 40

    (32) local -> ID local_aux .

    EQUALS          reduce using rule 32 (local -> ID local_aux .)
    TIMES           reduce using rule 32 (local -> ID local_aux .)
    DIVIDE          reduce using rule 32 (local -> ID local_aux .)
    PLUS            reduce using rule 32 (local -> ID local_aux .)
    MINUS           reduce using rule 32 (local -> ID local_aux .)
    LT              reduce using rule 32 (local -> ID local_aux .)
    LE              reduce using rule 32 (local -> ID local_aux .)
    GT              reduce using rule 32 (local -> ID local_aux .)
    GE              reduce using rule 32 (local -> ID local_aux .)
    DOT             reduce using rule 32 (local -> ID local_aux .)
    RPAREN          reduce using rule 32 (local -> ID local_aux .)
    EQ              reduce using rule 32 (local -> ID local_aux .)
    NEQ             reduce using rule 32 (local -> ID local_aux .)
    AND             reduce using rule 32 (local -> ID local_aux .)
    OR              reduce using rule 32 (local -> ID local_aux .)
    SEMICOLON       reduce using rule 32 (local -> ID local_aux .)
    RBRACK          reduce using rule 32 (local -> ID local_aux .)


state 41

    (33) local_aux -> offset .

    EQUALS          reduce using rule 33 (local_aux -> offset .)
    TIMES           reduce using rule 33 (local_aux -> offset .)
    DIVIDE          reduce using rule 33 (local_aux -> offset .)
    PLUS            reduce using rule 33 (local_aux -> offset .)
    MINUS           reduce using rule 33 (local_aux -> offset .)
    LT              reduce using rule 33 (local_aux -> offset .)
    LE              reduce using rule 33 (local_aux -> offset .)
    GT              reduce using rule 33 (local_aux -> offset .)
    GE              reduce using rule 33 (local_aux -> offset .)
    DOT             reduce using rule 33 (local_aux -> offset .)
    RPAREN          reduce using rule 33 (local_aux -> offset .)
    EQ              reduce using rule 33 (local_aux -> offset .)
    NEQ             reduce using rule 33 (local_aux -> offset .)
    AND             reduce using rule 33 (local_aux -> offset .)
    OR              reduce using rule 33 (local_aux -> offset .)
    SEMICOLON       reduce using rule 33 (local_aux -> offset .)
    RBRACK          reduce using rule 33 (local_aux -> offset .)


state 42

    (34) local_aux -> field .

    EQUALS          reduce using rule 34 (local_aux -> field .)
    TIMES           reduce using rule 34 (local_aux -> field .)
    DIVIDE          reduce using rule 34 (local_aux -> field .)
    PLUS            reduce using rule 34 (local_aux -> field .)
    MINUS           reduce using rule 34 (local_aux -> field .)
    LT              reduce using rule 34 (local_aux -> field .)
    LE              reduce using rule 34 (local_aux -> field .)
    GT              reduce using rule 34 (local_aux -> field .)
    GE              reduce using rule 34 (local_aux -> field .)
    DOT             reduce using rule 34 (local_aux -> field .)
    RPAREN          reduce using rule 34 (local_aux -> field .)
    EQ              reduce using rule 34 (local_aux -> field .)
    NEQ             reduce using rule 34 (local_aux -> field .)
    AND             reduce using rule 34 (local_aux -> field .)
    OR              reduce using rule 34 (local_aux -> field .)
    SEMICOLON       reduce using rule 34 (local_aux -> field .)
    RBRACK          reduce using rule 34 (local_aux -> field .)


state 43

    (35) local_aux -> empty .
    (37) offset -> empty .

  ! reduce/reduce conflict for EQUALS resolved using rule 35 (local_aux -> empty .)
  ! reduce/reduce conflict for TIMES resolved using rule 35 (local_aux -> empty .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 35 (local_aux -> empty .)
  ! reduce/reduce conflict for PLUS resolved using rule 35 (local_aux -> empty .)
  ! reduce/reduce conflict for MINUS resolved using rule 35 (local_aux -> empty .)
  ! reduce/reduce conflict for LT resolved using rule 35 (local_aux -> empty .)
  ! reduce/reduce conflict for LE resolved using rule 35 (local_aux -> empty .)
  ! reduce/reduce conflict for GT resolved using rule 35 (local_aux -> empty .)
  ! reduce/reduce conflict for GE resolved using rule 35 (local_aux -> empty .)
  ! reduce/reduce conflict for DOT resolved using rule 35 (local_aux -> empty .)
  ! reduce/reduce conflict for RPAREN resolved using rule 35 (local_aux -> empty .)
  ! reduce/reduce conflict for EQ resolved using rule 35 (local_aux -> empty .)
  ! reduce/reduce conflict for NEQ resolved using rule 35 (local_aux -> empty .)
  ! reduce/reduce conflict for AND resolved using rule 35 (local_aux -> empty .)
  ! reduce/reduce conflict for OR resolved using rule 35 (local_aux -> empty .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 35 (local_aux -> empty .)
  ! reduce/reduce conflict for RBRACK resolved using rule 35 (local_aux -> empty .)
    EQUALS          reduce using rule 35 (local_aux -> empty .)
    TIMES           reduce using rule 35 (local_aux -> empty .)
    DIVIDE          reduce using rule 35 (local_aux -> empty .)
    PLUS            reduce using rule 35 (local_aux -> empty .)
    MINUS           reduce using rule 35 (local_aux -> empty .)
    LT              reduce using rule 35 (local_aux -> empty .)
    LE              reduce using rule 35 (local_aux -> empty .)
    GT              reduce using rule 35 (local_aux -> empty .)
    GE              reduce using rule 35 (local_aux -> empty .)
    DOT             reduce using rule 35 (local_aux -> empty .)
    RPAREN          reduce using rule 35 (local_aux -> empty .)
    EQ              reduce using rule 35 (local_aux -> empty .)
    NEQ             reduce using rule 35 (local_aux -> empty .)
    AND             reduce using rule 35 (local_aux -> empty .)
    OR              reduce using rule 35 (local_aux -> empty .)
    SEMICOLON       reduce using rule 35 (local_aux -> empty .)
    RBRACK          reduce using rule 35 (local_aux -> empty .)

  ! EQUALS          [ reduce using rule 37 (offset -> empty .) ]
  ! TIMES           [ reduce using rule 37 (offset -> empty .) ]
  ! DIVIDE          [ reduce using rule 37 (offset -> empty .) ]
  ! PLUS            [ reduce using rule 37 (offset -> empty .) ]
  ! MINUS           [ reduce using rule 37 (offset -> empty .) ]
  ! LT              [ reduce using rule 37 (offset -> empty .) ]
  ! LE              [ reduce using rule 37 (offset -> empty .) ]
  ! GT              [ reduce using rule 37 (offset -> empty .) ]
  ! GE              [ reduce using rule 37 (offset -> empty .) ]
  ! DOT             [ reduce using rule 37 (offset -> empty .) ]
  ! RPAREN          [ reduce using rule 37 (offset -> empty .) ]
  ! EQ              [ reduce using rule 37 (offset -> empty .) ]
  ! NEQ             [ reduce using rule 37 (offset -> empty .) ]
  ! AND             [ reduce using rule 37 (offset -> empty .) ]
  ! OR              [ reduce using rule 37 (offset -> empty .) ]
  ! SEMICOLON       [ reduce using rule 37 (offset -> empty .) ]
  ! RBRACK          [ reduce using rule 37 (offset -> empty .) ]


state 44

    (36) offset -> LBRACK . boolean RBRACK offset
    (40) boolean -> . join boolean_aux
    (43) join -> . equality join_aux
    (46) equality -> . relational equality_aux
    (50) relational -> . expression relational_operator expression
    (55) expression -> . term expression_aux
    (60) term -> . unary term_aux
    (64) unary -> . NOT unary
    (65) unary -> . NEG unary
    (66) unary -> . factor
    (67) factor -> . LPAREN boolean RPAREN
    (68) factor -> . local
    (69) factor -> . NUMBER_INT
    (70) factor -> . NUMBER_FLOAT
    (71) factor -> . FALSE
    (72) factor -> . TRUE
    (31) local -> . HASH ID local_aux
    (32) local -> . ID local_aux

    NOT             shift and go to state 62
    NEG             shift and go to state 63
    LPAREN          shift and go to state 65
    NUMBER_INT      shift and go to state 66
    NUMBER_FLOAT    shift and go to state 67
    FALSE           shift and go to state 68
    TRUE            shift and go to state 69
    HASH            shift and go to state 23
    ID              shift and go to state 24

    boolean                        shift and go to state 71
    join                           shift and go to state 56
    equality                       shift and go to state 57
    relational                     shift and go to state 58
    expression                     shift and go to state 59
    term                           shift and go to state 60
    unary                          shift and go to state 61
    factor                         shift and go to state 64
    local                          shift and go to state 54

state 45

    (38) field -> DOT . factor field
    (39) field -> DOT . factor
    (67) factor -> . LPAREN boolean RPAREN
    (68) factor -> . local
    (69) factor -> . NUMBER_INT
    (70) factor -> . NUMBER_FLOAT
    (71) factor -> . FALSE
    (72) factor -> . TRUE
    (31) local -> . HASH ID local_aux
    (32) local -> . ID local_aux

    LPAREN          shift and go to state 65
    NUMBER_INT      shift and go to state 66
    NUMBER_FLOAT    shift and go to state 67
    FALSE           shift and go to state 68
    TRUE            shift and go to state 69
    HASH            shift and go to state 23
    ID              shift and go to state 24

    factor                         shift and go to state 72
    local                          shift and go to state 54

state 46

    (26) conditional -> IF LPAREN . boolean RPAREN statement conditional_aux
    (40) boolean -> . join boolean_aux
    (43) join -> . equality join_aux
    (46) equality -> . relational equality_aux
    (50) relational -> . expression relational_operator expression
    (55) expression -> . term expression_aux
    (60) term -> . unary term_aux
    (64) unary -> . NOT unary
    (65) unary -> . NEG unary
    (66) unary -> . factor
    (67) factor -> . LPAREN boolean RPAREN
    (68) factor -> . local
    (69) factor -> . NUMBER_INT
    (70) factor -> . NUMBER_FLOAT
    (71) factor -> . FALSE
    (72) factor -> . TRUE
    (31) local -> . HASH ID local_aux
    (32) local -> . ID local_aux

    NOT             shift and go to state 62
    NEG             shift and go to state 63
    LPAREN          shift and go to state 65
    NUMBER_INT      shift and go to state 66
    NUMBER_FLOAT    shift and go to state 67
    FALSE           shift and go to state 68
    TRUE            shift and go to state 69
    HASH            shift and go to state 23
    ID              shift and go to state 24

    boolean                        shift and go to state 73
    join                           shift and go to state 56
    equality                       shift and go to state 57
    relational                     shift and go to state 58
    expression                     shift and go to state 59
    term                           shift and go to state 60
    unary                          shift and go to state 61
    factor                         shift and go to state 64
    local                          shift and go to state 54

state 47

    (29) while_loop -> WHILE LPAREN . boolean RPAREN statement
    (40) boolean -> . join boolean_aux
    (43) join -> . equality join_aux
    (46) equality -> . relational equality_aux
    (50) relational -> . expression relational_operator expression
    (55) expression -> . term expression_aux
    (60) term -> . unary term_aux
    (64) unary -> . NOT unary
    (65) unary -> . NEG unary
    (66) unary -> . factor
    (67) factor -> . LPAREN boolean RPAREN
    (68) factor -> . local
    (69) factor -> . NUMBER_INT
    (70) factor -> . NUMBER_FLOAT
    (71) factor -> . FALSE
    (72) factor -> . TRUE
    (31) local -> . HASH ID local_aux
    (32) local -> . ID local_aux

    NOT             shift and go to state 62
    NEG             shift and go to state 63
    LPAREN          shift and go to state 65
    NUMBER_INT      shift and go to state 66
    NUMBER_FLOAT    shift and go to state 67
    FALSE           shift and go to state 68
    TRUE            shift and go to state 69
    HASH            shift and go to state 23
    ID              shift and go to state 24

    boolean                        shift and go to state 74
    join                           shift and go to state 56
    equality                       shift and go to state 57
    relational                     shift and go to state 58
    expression                     shift and go to state 59
    term                           shift and go to state 60
    unary                          shift and go to state 61
    factor                         shift and go to state 64
    local                          shift and go to state 54

state 48

    (30) do_while_loop -> DO statement . WHILE LPAREN boolean RPAREN SEMICOLON

    WHILE           shift and go to state 75


state 49

    (24) print -> PRINT LPAREN . boolean RPAREN SEMICOLON
    (40) boolean -> . join boolean_aux
    (43) join -> . equality join_aux
    (46) equality -> . relational equality_aux
    (50) relational -> . expression relational_operator expression
    (55) expression -> . term expression_aux
    (60) term -> . unary term_aux
    (64) unary -> . NOT unary
    (65) unary -> . NEG unary
    (66) unary -> . factor
    (67) factor -> . LPAREN boolean RPAREN
    (68) factor -> . local
    (69) factor -> . NUMBER_INT
    (70) factor -> . NUMBER_FLOAT
    (71) factor -> . FALSE
    (72) factor -> . TRUE
    (31) local -> . HASH ID local_aux
    (32) local -> . ID local_aux

    NOT             shift and go to state 62
    NEG             shift and go to state 63
    LPAREN          shift and go to state 65
    NUMBER_INT      shift and go to state 66
    NUMBER_FLOAT    shift and go to state 67
    FALSE           shift and go to state 68
    TRUE            shift and go to state 69
    HASH            shift and go to state 23
    ID              shift and go to state 24

    boolean                        shift and go to state 76
    join                           shift and go to state 56
    equality                       shift and go to state 57
    relational                     shift and go to state 58
    expression                     shift and go to state 59
    term                           shift and go to state 60
    unary                          shift and go to state 61
    factor                         shift and go to state 64
    local                          shift and go to state 54

state 50

    (25) read -> READ LPAREN . local RPAREN SEMICOLON
    (31) local -> . HASH ID local_aux
    (32) local -> . ID local_aux

    HASH            shift and go to state 23
    ID              shift and go to state 24

    local                          shift and go to state 77

state 51

    (3) declaration -> type ID SEMICOLON . declaration
    (3) declaration -> . type ID SEMICOLON declaration
    (4) declaration -> . empty
    (5) type -> . basic dimensions
    (6) type -> . basic HASH
    (7) type -> . basic
    (8) type -> . RECORD LBRACE declaration RBRACE
    (73) empty -> .
    (11) basic -> . INT
    (12) basic -> . CHAR
    (13) basic -> . BOOL

    RECORD          shift and go to state 8
    BREAK           reduce using rule 73 (empty -> .)
    HASH            reduce using rule 73 (empty -> .)
    ID              reduce using rule 73 (empty -> .)
    IF              reduce using rule 73 (empty -> .)
    WHILE           reduce using rule 73 (empty -> .)
    DO              reduce using rule 73 (empty -> .)
    PRINT           reduce using rule 73 (empty -> .)
    READ            reduce using rule 73 (empty -> .)
    LBRACE          reduce using rule 73 (empty -> .)
    RBRACE          reduce using rule 73 (empty -> .)
    INT             shift and go to state 9
    CHAR            shift and go to state 10
    BOOL            shift and go to state 11

    type                           shift and go to state 5
    declaration                    shift and go to state 78
    empty                          shift and go to state 6
    basic                          shift and go to state 7

state 52

    (9) dimensions -> LBRACK NUMBER_INT . RBRACK dimensions
    (10) dimensions -> LBRACK NUMBER_INT . RBRACK

    RBRACK          shift and go to state 79


state 53

    (8) type -> RECORD LBRACE declaration . RBRACE

    RBRACE          shift and go to state 80


state 54

    (68) factor -> local .

    TIMES           reduce using rule 68 (factor -> local .)
    DIVIDE          reduce using rule 68 (factor -> local .)
    PLUS            reduce using rule 68 (factor -> local .)
    MINUS           reduce using rule 68 (factor -> local .)
    LT              reduce using rule 68 (factor -> local .)
    LE              reduce using rule 68 (factor -> local .)
    GT              reduce using rule 68 (factor -> local .)
    GE              reduce using rule 68 (factor -> local .)
    EQUALS          reduce using rule 68 (factor -> local .)
    DOT             reduce using rule 68 (factor -> local .)
    RPAREN          reduce using rule 68 (factor -> local .)
    EQ              reduce using rule 68 (factor -> local .)
    NEQ             reduce using rule 68 (factor -> local .)
    AND             reduce using rule 68 (factor -> local .)
    OR              reduce using rule 68 (factor -> local .)
    SEMICOLON       reduce using rule 68 (factor -> local .)
    RBRACK          reduce using rule 68 (factor -> local .)


state 55

    (16) statement -> local EQUALS boolean . SEMICOLON

    SEMICOLON       shift and go to state 81


state 56

    (40) boolean -> join . boolean_aux
    (41) boolean_aux -> . OR join boolean_aux
    (42) boolean_aux -> . empty
    (73) empty -> .

    OR              shift and go to state 83
    SEMICOLON       reduce using rule 73 (empty -> .)
    RBRACK          reduce using rule 73 (empty -> .)
    RPAREN          reduce using rule 73 (empty -> .)

    boolean_aux                    shift and go to state 82
    empty                          shift and go to state 84

state 57

    (43) join -> equality . join_aux
    (44) join_aux -> . AND equality join_aux
    (45) join_aux -> . empty
    (73) empty -> .

    AND             shift and go to state 86
    OR              reduce using rule 73 (empty -> .)
    SEMICOLON       reduce using rule 73 (empty -> .)
    RBRACK          reduce using rule 73 (empty -> .)
    RPAREN          reduce using rule 73 (empty -> .)

    join_aux                       shift and go to state 85
    empty                          shift and go to state 87

state 58

    (46) equality -> relational . equality_aux
    (47) equality_aux -> . EQ relational equality_aux
    (48) equality_aux -> . NEQ relational equality_aux
    (49) equality_aux -> . empty
    (73) empty -> .

    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    AND             reduce using rule 73 (empty -> .)
    OR              reduce using rule 73 (empty -> .)
    SEMICOLON       reduce using rule 73 (empty -> .)
    RBRACK          reduce using rule 73 (empty -> .)
    RPAREN          reduce using rule 73 (empty -> .)

    equality_aux                   shift and go to state 88
    empty                          shift and go to state 91

state 59

    (50) relational -> expression . relational_operator expression
    (51) relational_operator -> . LT
    (52) relational_operator -> . LE
    (53) relational_operator -> . GT
    (54) relational_operator -> . GE

    LT              shift and go to state 93
    LE              shift and go to state 94
    GT              shift and go to state 95
    GE              shift and go to state 96

    relational_operator            shift and go to state 92

state 60

    (55) expression -> term . expression_aux
    (56) expression_aux -> . expression_operator term expression_aux
    (57) expression_aux -> . empty
    (58) expression_operator -> . PLUS
    (59) expression_operator -> . MINUS
    (73) empty -> .

    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    LT              reduce using rule 73 (empty -> .)
    LE              reduce using rule 73 (empty -> .)
    GT              reduce using rule 73 (empty -> .)
    GE              reduce using rule 73 (empty -> .)
    EQ              reduce using rule 73 (empty -> .)
    NEQ             reduce using rule 73 (empty -> .)
    AND             reduce using rule 73 (empty -> .)
    OR              reduce using rule 73 (empty -> .)
    SEMICOLON       reduce using rule 73 (empty -> .)
    RBRACK          reduce using rule 73 (empty -> .)
    RPAREN          reduce using rule 73 (empty -> .)

    expression_aux                 shift and go to state 97
    expression_operator            shift and go to state 98
    empty                          shift and go to state 99

state 61

    (60) term -> unary . term_aux
    (61) term_aux -> . TIMES unary term_aux
    (62) term_aux -> . DIVIDE unary term_aux
    (63) term_aux -> . empty
    (73) empty -> .

    TIMES           shift and go to state 103
    DIVIDE          shift and go to state 104
    PLUS            reduce using rule 73 (empty -> .)
    MINUS           reduce using rule 73 (empty -> .)
    LT              reduce using rule 73 (empty -> .)
    LE              reduce using rule 73 (empty -> .)
    GT              reduce using rule 73 (empty -> .)
    GE              reduce using rule 73 (empty -> .)
    EQ              reduce using rule 73 (empty -> .)
    NEQ             reduce using rule 73 (empty -> .)
    AND             reduce using rule 73 (empty -> .)
    OR              reduce using rule 73 (empty -> .)
    SEMICOLON       reduce using rule 73 (empty -> .)
    RBRACK          reduce using rule 73 (empty -> .)
    RPAREN          reduce using rule 73 (empty -> .)

    term_aux                       shift and go to state 102
    empty                          shift and go to state 105

state 62

    (64) unary -> NOT . unary
    (64) unary -> . NOT unary
    (65) unary -> . NEG unary
    (66) unary -> . factor
    (67) factor -> . LPAREN boolean RPAREN
    (68) factor -> . local
    (69) factor -> . NUMBER_INT
    (70) factor -> . NUMBER_FLOAT
    (71) factor -> . FALSE
    (72) factor -> . TRUE
    (31) local -> . HASH ID local_aux
    (32) local -> . ID local_aux

    NOT             shift and go to state 62
    NEG             shift and go to state 63
    LPAREN          shift and go to state 65
    NUMBER_INT      shift and go to state 66
    NUMBER_FLOAT    shift and go to state 67
    FALSE           shift and go to state 68
    TRUE            shift and go to state 69
    HASH            shift and go to state 23
    ID              shift and go to state 24

    unary                          shift and go to state 106
    factor                         shift and go to state 64
    local                          shift and go to state 54

state 63

    (65) unary -> NEG . unary
    (64) unary -> . NOT unary
    (65) unary -> . NEG unary
    (66) unary -> . factor
    (67) factor -> . LPAREN boolean RPAREN
    (68) factor -> . local
    (69) factor -> . NUMBER_INT
    (70) factor -> . NUMBER_FLOAT
    (71) factor -> . FALSE
    (72) factor -> . TRUE
    (31) local -> . HASH ID local_aux
    (32) local -> . ID local_aux

    NOT             shift and go to state 62
    NEG             shift and go to state 63
    LPAREN          shift and go to state 65
    NUMBER_INT      shift and go to state 66
    NUMBER_FLOAT    shift and go to state 67
    FALSE           shift and go to state 68
    TRUE            shift and go to state 69
    HASH            shift and go to state 23
    ID              shift and go to state 24

    unary                          shift and go to state 107
    factor                         shift and go to state 64
    local                          shift and go to state 54

state 64

    (66) unary -> factor .

    TIMES           reduce using rule 66 (unary -> factor .)
    DIVIDE          reduce using rule 66 (unary -> factor .)
    PLUS            reduce using rule 66 (unary -> factor .)
    MINUS           reduce using rule 66 (unary -> factor .)
    LT              reduce using rule 66 (unary -> factor .)
    LE              reduce using rule 66 (unary -> factor .)
    GT              reduce using rule 66 (unary -> factor .)
    GE              reduce using rule 66 (unary -> factor .)
    EQ              reduce using rule 66 (unary -> factor .)
    NEQ             reduce using rule 66 (unary -> factor .)
    AND             reduce using rule 66 (unary -> factor .)
    OR              reduce using rule 66 (unary -> factor .)
    SEMICOLON       reduce using rule 66 (unary -> factor .)
    RBRACK          reduce using rule 66 (unary -> factor .)
    RPAREN          reduce using rule 66 (unary -> factor .)


state 65

    (67) factor -> LPAREN . boolean RPAREN
    (40) boolean -> . join boolean_aux
    (43) join -> . equality join_aux
    (46) equality -> . relational equality_aux
    (50) relational -> . expression relational_operator expression
    (55) expression -> . term expression_aux
    (60) term -> . unary term_aux
    (64) unary -> . NOT unary
    (65) unary -> . NEG unary
    (66) unary -> . factor
    (67) factor -> . LPAREN boolean RPAREN
    (68) factor -> . local
    (69) factor -> . NUMBER_INT
    (70) factor -> . NUMBER_FLOAT
    (71) factor -> . FALSE
    (72) factor -> . TRUE
    (31) local -> . HASH ID local_aux
    (32) local -> . ID local_aux

    NOT             shift and go to state 62
    NEG             shift and go to state 63
    LPAREN          shift and go to state 65
    NUMBER_INT      shift and go to state 66
    NUMBER_FLOAT    shift and go to state 67
    FALSE           shift and go to state 68
    TRUE            shift and go to state 69
    HASH            shift and go to state 23
    ID              shift and go to state 24

    boolean                        shift and go to state 108
    join                           shift and go to state 56
    equality                       shift and go to state 57
    relational                     shift and go to state 58
    expression                     shift and go to state 59
    term                           shift and go to state 60
    unary                          shift and go to state 61
    factor                         shift and go to state 64
    local                          shift and go to state 54

state 66

    (69) factor -> NUMBER_INT .

    TIMES           reduce using rule 69 (factor -> NUMBER_INT .)
    DIVIDE          reduce using rule 69 (factor -> NUMBER_INT .)
    PLUS            reduce using rule 69 (factor -> NUMBER_INT .)
    MINUS           reduce using rule 69 (factor -> NUMBER_INT .)
    LT              reduce using rule 69 (factor -> NUMBER_INT .)
    LE              reduce using rule 69 (factor -> NUMBER_INT .)
    GT              reduce using rule 69 (factor -> NUMBER_INT .)
    GE              reduce using rule 69 (factor -> NUMBER_INT .)
    EQUALS          reduce using rule 69 (factor -> NUMBER_INT .)
    DOT             reduce using rule 69 (factor -> NUMBER_INT .)
    RPAREN          reduce using rule 69 (factor -> NUMBER_INT .)
    EQ              reduce using rule 69 (factor -> NUMBER_INT .)
    NEQ             reduce using rule 69 (factor -> NUMBER_INT .)
    AND             reduce using rule 69 (factor -> NUMBER_INT .)
    OR              reduce using rule 69 (factor -> NUMBER_INT .)
    SEMICOLON       reduce using rule 69 (factor -> NUMBER_INT .)
    RBRACK          reduce using rule 69 (factor -> NUMBER_INT .)


state 67

    (70) factor -> NUMBER_FLOAT .

    TIMES           reduce using rule 70 (factor -> NUMBER_FLOAT .)
    DIVIDE          reduce using rule 70 (factor -> NUMBER_FLOAT .)
    PLUS            reduce using rule 70 (factor -> NUMBER_FLOAT .)
    MINUS           reduce using rule 70 (factor -> NUMBER_FLOAT .)
    LT              reduce using rule 70 (factor -> NUMBER_FLOAT .)
    LE              reduce using rule 70 (factor -> NUMBER_FLOAT .)
    GT              reduce using rule 70 (factor -> NUMBER_FLOAT .)
    GE              reduce using rule 70 (factor -> NUMBER_FLOAT .)
    EQUALS          reduce using rule 70 (factor -> NUMBER_FLOAT .)
    DOT             reduce using rule 70 (factor -> NUMBER_FLOAT .)
    RPAREN          reduce using rule 70 (factor -> NUMBER_FLOAT .)
    EQ              reduce using rule 70 (factor -> NUMBER_FLOAT .)
    NEQ             reduce using rule 70 (factor -> NUMBER_FLOAT .)
    AND             reduce using rule 70 (factor -> NUMBER_FLOAT .)
    OR              reduce using rule 70 (factor -> NUMBER_FLOAT .)
    SEMICOLON       reduce using rule 70 (factor -> NUMBER_FLOAT .)
    RBRACK          reduce using rule 70 (factor -> NUMBER_FLOAT .)


state 68

    (71) factor -> FALSE .

    TIMES           reduce using rule 71 (factor -> FALSE .)
    DIVIDE          reduce using rule 71 (factor -> FALSE .)
    PLUS            reduce using rule 71 (factor -> FALSE .)
    MINUS           reduce using rule 71 (factor -> FALSE .)
    LT              reduce using rule 71 (factor -> FALSE .)
    LE              reduce using rule 71 (factor -> FALSE .)
    GT              reduce using rule 71 (factor -> FALSE .)
    GE              reduce using rule 71 (factor -> FALSE .)
    EQUALS          reduce using rule 71 (factor -> FALSE .)
    DOT             reduce using rule 71 (factor -> FALSE .)
    RPAREN          reduce using rule 71 (factor -> FALSE .)
    EQ              reduce using rule 71 (factor -> FALSE .)
    NEQ             reduce using rule 71 (factor -> FALSE .)
    AND             reduce using rule 71 (factor -> FALSE .)
    OR              reduce using rule 71 (factor -> FALSE .)
    SEMICOLON       reduce using rule 71 (factor -> FALSE .)
    RBRACK          reduce using rule 71 (factor -> FALSE .)


state 69

    (72) factor -> TRUE .

    TIMES           reduce using rule 72 (factor -> TRUE .)
    DIVIDE          reduce using rule 72 (factor -> TRUE .)
    PLUS            reduce using rule 72 (factor -> TRUE .)
    MINUS           reduce using rule 72 (factor -> TRUE .)
    LT              reduce using rule 72 (factor -> TRUE .)
    LE              reduce using rule 72 (factor -> TRUE .)
    GT              reduce using rule 72 (factor -> TRUE .)
    GE              reduce using rule 72 (factor -> TRUE .)
    EQUALS          reduce using rule 72 (factor -> TRUE .)
    DOT             reduce using rule 72 (factor -> TRUE .)
    RPAREN          reduce using rule 72 (factor -> TRUE .)
    EQ              reduce using rule 72 (factor -> TRUE .)
    NEQ             reduce using rule 72 (factor -> TRUE .)
    AND             reduce using rule 72 (factor -> TRUE .)
    OR              reduce using rule 72 (factor -> TRUE .)
    SEMICOLON       reduce using rule 72 (factor -> TRUE .)
    RBRACK          reduce using rule 72 (factor -> TRUE .)


state 70

    (31) local -> HASH ID local_aux .

    EQUALS          reduce using rule 31 (local -> HASH ID local_aux .)
    TIMES           reduce using rule 31 (local -> HASH ID local_aux .)
    DIVIDE          reduce using rule 31 (local -> HASH ID local_aux .)
    PLUS            reduce using rule 31 (local -> HASH ID local_aux .)
    MINUS           reduce using rule 31 (local -> HASH ID local_aux .)
    LT              reduce using rule 31 (local -> HASH ID local_aux .)
    LE              reduce using rule 31 (local -> HASH ID local_aux .)
    GT              reduce using rule 31 (local -> HASH ID local_aux .)
    GE              reduce using rule 31 (local -> HASH ID local_aux .)
    DOT             reduce using rule 31 (local -> HASH ID local_aux .)
    RPAREN          reduce using rule 31 (local -> HASH ID local_aux .)
    EQ              reduce using rule 31 (local -> HASH ID local_aux .)
    NEQ             reduce using rule 31 (local -> HASH ID local_aux .)
    AND             reduce using rule 31 (local -> HASH ID local_aux .)
    OR              reduce using rule 31 (local -> HASH ID local_aux .)
    SEMICOLON       reduce using rule 31 (local -> HASH ID local_aux .)
    RBRACK          reduce using rule 31 (local -> HASH ID local_aux .)


state 71

    (36) offset -> LBRACK boolean . RBRACK offset

    RBRACK          shift and go to state 109


state 72

    (38) field -> DOT factor . field
    (39) field -> DOT factor .
    (38) field -> . DOT factor field
    (39) field -> . DOT factor

  ! shift/reduce conflict for DOT resolved as shift
    EQUALS          reduce using rule 39 (field -> DOT factor .)
    TIMES           reduce using rule 39 (field -> DOT factor .)
    DIVIDE          reduce using rule 39 (field -> DOT factor .)
    PLUS            reduce using rule 39 (field -> DOT factor .)
    MINUS           reduce using rule 39 (field -> DOT factor .)
    LT              reduce using rule 39 (field -> DOT factor .)
    LE              reduce using rule 39 (field -> DOT factor .)
    GT              reduce using rule 39 (field -> DOT factor .)
    GE              reduce using rule 39 (field -> DOT factor .)
    RPAREN          reduce using rule 39 (field -> DOT factor .)
    EQ              reduce using rule 39 (field -> DOT factor .)
    NEQ             reduce using rule 39 (field -> DOT factor .)
    AND             reduce using rule 39 (field -> DOT factor .)
    OR              reduce using rule 39 (field -> DOT factor .)
    SEMICOLON       reduce using rule 39 (field -> DOT factor .)
    RBRACK          reduce using rule 39 (field -> DOT factor .)
    DOT             shift and go to state 45

  ! DOT             [ reduce using rule 39 (field -> DOT factor .) ]

    field                          shift and go to state 110

state 73

    (26) conditional -> IF LPAREN boolean . RPAREN statement conditional_aux

    RPAREN          shift and go to state 111


state 74

    (29) while_loop -> WHILE LPAREN boolean . RPAREN statement

    RPAREN          shift and go to state 112


state 75

    (30) do_while_loop -> DO statement WHILE . LPAREN boolean RPAREN SEMICOLON

    LPAREN          shift and go to state 113


state 76

    (24) print -> PRINT LPAREN boolean . RPAREN SEMICOLON

    RPAREN          shift and go to state 114


state 77

    (25) read -> READ LPAREN local . RPAREN SEMICOLON

    RPAREN          shift and go to state 115


state 78

    (3) declaration -> type ID SEMICOLON declaration .

    BREAK           reduce using rule 3 (declaration -> type ID SEMICOLON declaration .)
    HASH            reduce using rule 3 (declaration -> type ID SEMICOLON declaration .)
    ID              reduce using rule 3 (declaration -> type ID SEMICOLON declaration .)
    IF              reduce using rule 3 (declaration -> type ID SEMICOLON declaration .)
    WHILE           reduce using rule 3 (declaration -> type ID SEMICOLON declaration .)
    DO              reduce using rule 3 (declaration -> type ID SEMICOLON declaration .)
    PRINT           reduce using rule 3 (declaration -> type ID SEMICOLON declaration .)
    READ            reduce using rule 3 (declaration -> type ID SEMICOLON declaration .)
    LBRACE          reduce using rule 3 (declaration -> type ID SEMICOLON declaration .)
    RBRACE          reduce using rule 3 (declaration -> type ID SEMICOLON declaration .)


state 79

    (9) dimensions -> LBRACK NUMBER_INT RBRACK . dimensions
    (10) dimensions -> LBRACK NUMBER_INT RBRACK .
    (9) dimensions -> . LBRACK NUMBER_INT RBRACK dimensions
    (10) dimensions -> . LBRACK NUMBER_INT RBRACK

    ID              reduce using rule 10 (dimensions -> LBRACK NUMBER_INT RBRACK .)
    LBRACK          shift and go to state 33

    dimensions                     shift and go to state 116

state 80

    (8) type -> RECORD LBRACE declaration RBRACE .

    ID              reduce using rule 8 (type -> RECORD LBRACE declaration RBRACE .)


state 81

    (16) statement -> local EQUALS boolean SEMICOLON .

    BREAK           reduce using rule 16 (statement -> local EQUALS boolean SEMICOLON .)
    HASH            reduce using rule 16 (statement -> local EQUALS boolean SEMICOLON .)
    ID              reduce using rule 16 (statement -> local EQUALS boolean SEMICOLON .)
    IF              reduce using rule 16 (statement -> local EQUALS boolean SEMICOLON .)
    WHILE           reduce using rule 16 (statement -> local EQUALS boolean SEMICOLON .)
    DO              reduce using rule 16 (statement -> local EQUALS boolean SEMICOLON .)
    PRINT           reduce using rule 16 (statement -> local EQUALS boolean SEMICOLON .)
    READ            reduce using rule 16 (statement -> local EQUALS boolean SEMICOLON .)
    LBRACE          reduce using rule 16 (statement -> local EQUALS boolean SEMICOLON .)
    RBRACE          reduce using rule 16 (statement -> local EQUALS boolean SEMICOLON .)
    ELSE            reduce using rule 16 (statement -> local EQUALS boolean SEMICOLON .)


state 82

    (40) boolean -> join boolean_aux .

    SEMICOLON       reduce using rule 40 (boolean -> join boolean_aux .)
    RBRACK          reduce using rule 40 (boolean -> join boolean_aux .)
    RPAREN          reduce using rule 40 (boolean -> join boolean_aux .)


state 83

    (41) boolean_aux -> OR . join boolean_aux
    (43) join -> . equality join_aux
    (46) equality -> . relational equality_aux
    (50) relational -> . expression relational_operator expression
    (55) expression -> . term expression_aux
    (60) term -> . unary term_aux
    (64) unary -> . NOT unary
    (65) unary -> . NEG unary
    (66) unary -> . factor
    (67) factor -> . LPAREN boolean RPAREN
    (68) factor -> . local
    (69) factor -> . NUMBER_INT
    (70) factor -> . NUMBER_FLOAT
    (71) factor -> . FALSE
    (72) factor -> . TRUE
    (31) local -> . HASH ID local_aux
    (32) local -> . ID local_aux

    NOT             shift and go to state 62
    NEG             shift and go to state 63
    LPAREN          shift and go to state 65
    NUMBER_INT      shift and go to state 66
    NUMBER_FLOAT    shift and go to state 67
    FALSE           shift and go to state 68
    TRUE            shift and go to state 69
    HASH            shift and go to state 23
    ID              shift and go to state 24

    join                           shift and go to state 117
    equality                       shift and go to state 57
    relational                     shift and go to state 58
    expression                     shift and go to state 59
    term                           shift and go to state 60
    unary                          shift and go to state 61
    factor                         shift and go to state 64
    local                          shift and go to state 54

state 84

    (42) boolean_aux -> empty .

    SEMICOLON       reduce using rule 42 (boolean_aux -> empty .)
    RBRACK          reduce using rule 42 (boolean_aux -> empty .)
    RPAREN          reduce using rule 42 (boolean_aux -> empty .)


state 85

    (43) join -> equality join_aux .

    OR              reduce using rule 43 (join -> equality join_aux .)
    SEMICOLON       reduce using rule 43 (join -> equality join_aux .)
    RBRACK          reduce using rule 43 (join -> equality join_aux .)
    RPAREN          reduce using rule 43 (join -> equality join_aux .)


state 86

    (44) join_aux -> AND . equality join_aux
    (46) equality -> . relational equality_aux
    (50) relational -> . expression relational_operator expression
    (55) expression -> . term expression_aux
    (60) term -> . unary term_aux
    (64) unary -> . NOT unary
    (65) unary -> . NEG unary
    (66) unary -> . factor
    (67) factor -> . LPAREN boolean RPAREN
    (68) factor -> . local
    (69) factor -> . NUMBER_INT
    (70) factor -> . NUMBER_FLOAT
    (71) factor -> . FALSE
    (72) factor -> . TRUE
    (31) local -> . HASH ID local_aux
    (32) local -> . ID local_aux

    NOT             shift and go to state 62
    NEG             shift and go to state 63
    LPAREN          shift and go to state 65
    NUMBER_INT      shift and go to state 66
    NUMBER_FLOAT    shift and go to state 67
    FALSE           shift and go to state 68
    TRUE            shift and go to state 69
    HASH            shift and go to state 23
    ID              shift and go to state 24

    equality                       shift and go to state 118
    relational                     shift and go to state 58
    expression                     shift and go to state 59
    term                           shift and go to state 60
    unary                          shift and go to state 61
    factor                         shift and go to state 64
    local                          shift and go to state 54

state 87

    (45) join_aux -> empty .

    OR              reduce using rule 45 (join_aux -> empty .)
    SEMICOLON       reduce using rule 45 (join_aux -> empty .)
    RBRACK          reduce using rule 45 (join_aux -> empty .)
    RPAREN          reduce using rule 45 (join_aux -> empty .)


state 88

    (46) equality -> relational equality_aux .

    AND             reduce using rule 46 (equality -> relational equality_aux .)
    OR              reduce using rule 46 (equality -> relational equality_aux .)
    SEMICOLON       reduce using rule 46 (equality -> relational equality_aux .)
    RBRACK          reduce using rule 46 (equality -> relational equality_aux .)
    RPAREN          reduce using rule 46 (equality -> relational equality_aux .)


state 89

    (47) equality_aux -> EQ . relational equality_aux
    (50) relational -> . expression relational_operator expression
    (55) expression -> . term expression_aux
    (60) term -> . unary term_aux
    (64) unary -> . NOT unary
    (65) unary -> . NEG unary
    (66) unary -> . factor
    (67) factor -> . LPAREN boolean RPAREN
    (68) factor -> . local
    (69) factor -> . NUMBER_INT
    (70) factor -> . NUMBER_FLOAT
    (71) factor -> . FALSE
    (72) factor -> . TRUE
    (31) local -> . HASH ID local_aux
    (32) local -> . ID local_aux

    NOT             shift and go to state 62
    NEG             shift and go to state 63
    LPAREN          shift and go to state 65
    NUMBER_INT      shift and go to state 66
    NUMBER_FLOAT    shift and go to state 67
    FALSE           shift and go to state 68
    TRUE            shift and go to state 69
    HASH            shift and go to state 23
    ID              shift and go to state 24

    relational                     shift and go to state 119
    expression                     shift and go to state 59
    term                           shift and go to state 60
    unary                          shift and go to state 61
    factor                         shift and go to state 64
    local                          shift and go to state 54

state 90

    (48) equality_aux -> NEQ . relational equality_aux
    (50) relational -> . expression relational_operator expression
    (55) expression -> . term expression_aux
    (60) term -> . unary term_aux
    (64) unary -> . NOT unary
    (65) unary -> . NEG unary
    (66) unary -> . factor
    (67) factor -> . LPAREN boolean RPAREN
    (68) factor -> . local
    (69) factor -> . NUMBER_INT
    (70) factor -> . NUMBER_FLOAT
    (71) factor -> . FALSE
    (72) factor -> . TRUE
    (31) local -> . HASH ID local_aux
    (32) local -> . ID local_aux

    NOT             shift and go to state 62
    NEG             shift and go to state 63
    LPAREN          shift and go to state 65
    NUMBER_INT      shift and go to state 66
    NUMBER_FLOAT    shift and go to state 67
    FALSE           shift and go to state 68
    TRUE            shift and go to state 69
    HASH            shift and go to state 23
    ID              shift and go to state 24

    relational                     shift and go to state 120
    expression                     shift and go to state 59
    term                           shift and go to state 60
    unary                          shift and go to state 61
    factor                         shift and go to state 64
    local                          shift and go to state 54

state 91

    (49) equality_aux -> empty .

    AND             reduce using rule 49 (equality_aux -> empty .)
    OR              reduce using rule 49 (equality_aux -> empty .)
    SEMICOLON       reduce using rule 49 (equality_aux -> empty .)
    RBRACK          reduce using rule 49 (equality_aux -> empty .)
    RPAREN          reduce using rule 49 (equality_aux -> empty .)


state 92

    (50) relational -> expression relational_operator . expression
    (55) expression -> . term expression_aux
    (60) term -> . unary term_aux
    (64) unary -> . NOT unary
    (65) unary -> . NEG unary
    (66) unary -> . factor
    (67) factor -> . LPAREN boolean RPAREN
    (68) factor -> . local
    (69) factor -> . NUMBER_INT
    (70) factor -> . NUMBER_FLOAT
    (71) factor -> . FALSE
    (72) factor -> . TRUE
    (31) local -> . HASH ID local_aux
    (32) local -> . ID local_aux

    NOT             shift and go to state 62
    NEG             shift and go to state 63
    LPAREN          shift and go to state 65
    NUMBER_INT      shift and go to state 66
    NUMBER_FLOAT    shift and go to state 67
    FALSE           shift and go to state 68
    TRUE            shift and go to state 69
    HASH            shift and go to state 23
    ID              shift and go to state 24

    expression                     shift and go to state 121
    term                           shift and go to state 60
    unary                          shift and go to state 61
    factor                         shift and go to state 64
    local                          shift and go to state 54

state 93

    (51) relational_operator -> LT .

    NOT             reduce using rule 51 (relational_operator -> LT .)
    NEG             reduce using rule 51 (relational_operator -> LT .)
    LPAREN          reduce using rule 51 (relational_operator -> LT .)
    NUMBER_INT      reduce using rule 51 (relational_operator -> LT .)
    NUMBER_FLOAT    reduce using rule 51 (relational_operator -> LT .)
    FALSE           reduce using rule 51 (relational_operator -> LT .)
    TRUE            reduce using rule 51 (relational_operator -> LT .)
    HASH            reduce using rule 51 (relational_operator -> LT .)
    ID              reduce using rule 51 (relational_operator -> LT .)


state 94

    (52) relational_operator -> LE .

    NOT             reduce using rule 52 (relational_operator -> LE .)
    NEG             reduce using rule 52 (relational_operator -> LE .)
    LPAREN          reduce using rule 52 (relational_operator -> LE .)
    NUMBER_INT      reduce using rule 52 (relational_operator -> LE .)
    NUMBER_FLOAT    reduce using rule 52 (relational_operator -> LE .)
    FALSE           reduce using rule 52 (relational_operator -> LE .)
    TRUE            reduce using rule 52 (relational_operator -> LE .)
    HASH            reduce using rule 52 (relational_operator -> LE .)
    ID              reduce using rule 52 (relational_operator -> LE .)


state 95

    (53) relational_operator -> GT .

    NOT             reduce using rule 53 (relational_operator -> GT .)
    NEG             reduce using rule 53 (relational_operator -> GT .)
    LPAREN          reduce using rule 53 (relational_operator -> GT .)
    NUMBER_INT      reduce using rule 53 (relational_operator -> GT .)
    NUMBER_FLOAT    reduce using rule 53 (relational_operator -> GT .)
    FALSE           reduce using rule 53 (relational_operator -> GT .)
    TRUE            reduce using rule 53 (relational_operator -> GT .)
    HASH            reduce using rule 53 (relational_operator -> GT .)
    ID              reduce using rule 53 (relational_operator -> GT .)


state 96

    (54) relational_operator -> GE .

    NOT             reduce using rule 54 (relational_operator -> GE .)
    NEG             reduce using rule 54 (relational_operator -> GE .)
    LPAREN          reduce using rule 54 (relational_operator -> GE .)
    NUMBER_INT      reduce using rule 54 (relational_operator -> GE .)
    NUMBER_FLOAT    reduce using rule 54 (relational_operator -> GE .)
    FALSE           reduce using rule 54 (relational_operator -> GE .)
    TRUE            reduce using rule 54 (relational_operator -> GE .)
    HASH            reduce using rule 54 (relational_operator -> GE .)
    ID              reduce using rule 54 (relational_operator -> GE .)


state 97

    (55) expression -> term expression_aux .

    LT              reduce using rule 55 (expression -> term expression_aux .)
    LE              reduce using rule 55 (expression -> term expression_aux .)
    GT              reduce using rule 55 (expression -> term expression_aux .)
    GE              reduce using rule 55 (expression -> term expression_aux .)
    EQ              reduce using rule 55 (expression -> term expression_aux .)
    NEQ             reduce using rule 55 (expression -> term expression_aux .)
    AND             reduce using rule 55 (expression -> term expression_aux .)
    OR              reduce using rule 55 (expression -> term expression_aux .)
    SEMICOLON       reduce using rule 55 (expression -> term expression_aux .)
    RBRACK          reduce using rule 55 (expression -> term expression_aux .)
    RPAREN          reduce using rule 55 (expression -> term expression_aux .)


state 98

    (56) expression_aux -> expression_operator . term expression_aux
    (60) term -> . unary term_aux
    (64) unary -> . NOT unary
    (65) unary -> . NEG unary
    (66) unary -> . factor
    (67) factor -> . LPAREN boolean RPAREN
    (68) factor -> . local
    (69) factor -> . NUMBER_INT
    (70) factor -> . NUMBER_FLOAT
    (71) factor -> . FALSE
    (72) factor -> . TRUE
    (31) local -> . HASH ID local_aux
    (32) local -> . ID local_aux

    NOT             shift and go to state 62
    NEG             shift and go to state 63
    LPAREN          shift and go to state 65
    NUMBER_INT      shift and go to state 66
    NUMBER_FLOAT    shift and go to state 67
    FALSE           shift and go to state 68
    TRUE            shift and go to state 69
    HASH            shift and go to state 23
    ID              shift and go to state 24

    term                           shift and go to state 122
    unary                          shift and go to state 61
    factor                         shift and go to state 64
    local                          shift and go to state 54

state 99

    (57) expression_aux -> empty .

    LT              reduce using rule 57 (expression_aux -> empty .)
    LE              reduce using rule 57 (expression_aux -> empty .)
    GT              reduce using rule 57 (expression_aux -> empty .)
    GE              reduce using rule 57 (expression_aux -> empty .)
    EQ              reduce using rule 57 (expression_aux -> empty .)
    NEQ             reduce using rule 57 (expression_aux -> empty .)
    AND             reduce using rule 57 (expression_aux -> empty .)
    OR              reduce using rule 57 (expression_aux -> empty .)
    SEMICOLON       reduce using rule 57 (expression_aux -> empty .)
    RBRACK          reduce using rule 57 (expression_aux -> empty .)
    RPAREN          reduce using rule 57 (expression_aux -> empty .)


state 100

    (58) expression_operator -> PLUS .

    NOT             reduce using rule 58 (expression_operator -> PLUS .)
    NEG             reduce using rule 58 (expression_operator -> PLUS .)
    LPAREN          reduce using rule 58 (expression_operator -> PLUS .)
    NUMBER_INT      reduce using rule 58 (expression_operator -> PLUS .)
    NUMBER_FLOAT    reduce using rule 58 (expression_operator -> PLUS .)
    FALSE           reduce using rule 58 (expression_operator -> PLUS .)
    TRUE            reduce using rule 58 (expression_operator -> PLUS .)
    HASH            reduce using rule 58 (expression_operator -> PLUS .)
    ID              reduce using rule 58 (expression_operator -> PLUS .)


state 101

    (59) expression_operator -> MINUS .

    NOT             reduce using rule 59 (expression_operator -> MINUS .)
    NEG             reduce using rule 59 (expression_operator -> MINUS .)
    LPAREN          reduce using rule 59 (expression_operator -> MINUS .)
    NUMBER_INT      reduce using rule 59 (expression_operator -> MINUS .)
    NUMBER_FLOAT    reduce using rule 59 (expression_operator -> MINUS .)
    FALSE           reduce using rule 59 (expression_operator -> MINUS .)
    TRUE            reduce using rule 59 (expression_operator -> MINUS .)
    HASH            reduce using rule 59 (expression_operator -> MINUS .)
    ID              reduce using rule 59 (expression_operator -> MINUS .)


state 102

    (60) term -> unary term_aux .

    PLUS            reduce using rule 60 (term -> unary term_aux .)
    MINUS           reduce using rule 60 (term -> unary term_aux .)
    LT              reduce using rule 60 (term -> unary term_aux .)
    LE              reduce using rule 60 (term -> unary term_aux .)
    GT              reduce using rule 60 (term -> unary term_aux .)
    GE              reduce using rule 60 (term -> unary term_aux .)
    EQ              reduce using rule 60 (term -> unary term_aux .)
    NEQ             reduce using rule 60 (term -> unary term_aux .)
    AND             reduce using rule 60 (term -> unary term_aux .)
    OR              reduce using rule 60 (term -> unary term_aux .)
    SEMICOLON       reduce using rule 60 (term -> unary term_aux .)
    RBRACK          reduce using rule 60 (term -> unary term_aux .)
    RPAREN          reduce using rule 60 (term -> unary term_aux .)


state 103

    (61) term_aux -> TIMES . unary term_aux
    (64) unary -> . NOT unary
    (65) unary -> . NEG unary
    (66) unary -> . factor
    (67) factor -> . LPAREN boolean RPAREN
    (68) factor -> . local
    (69) factor -> . NUMBER_INT
    (70) factor -> . NUMBER_FLOAT
    (71) factor -> . FALSE
    (72) factor -> . TRUE
    (31) local -> . HASH ID local_aux
    (32) local -> . ID local_aux

    NOT             shift and go to state 62
    NEG             shift and go to state 63
    LPAREN          shift and go to state 65
    NUMBER_INT      shift and go to state 66
    NUMBER_FLOAT    shift and go to state 67
    FALSE           shift and go to state 68
    TRUE            shift and go to state 69
    HASH            shift and go to state 23
    ID              shift and go to state 24

    unary                          shift and go to state 123
    factor                         shift and go to state 64
    local                          shift and go to state 54

state 104

    (62) term_aux -> DIVIDE . unary term_aux
    (64) unary -> . NOT unary
    (65) unary -> . NEG unary
    (66) unary -> . factor
    (67) factor -> . LPAREN boolean RPAREN
    (68) factor -> . local
    (69) factor -> . NUMBER_INT
    (70) factor -> . NUMBER_FLOAT
    (71) factor -> . FALSE
    (72) factor -> . TRUE
    (31) local -> . HASH ID local_aux
    (32) local -> . ID local_aux

    NOT             shift and go to state 62
    NEG             shift and go to state 63
    LPAREN          shift and go to state 65
    NUMBER_INT      shift and go to state 66
    NUMBER_FLOAT    shift and go to state 67
    FALSE           shift and go to state 68
    TRUE            shift and go to state 69
    HASH            shift and go to state 23
    ID              shift and go to state 24

    unary                          shift and go to state 124
    factor                         shift and go to state 64
    local                          shift and go to state 54

state 105

    (63) term_aux -> empty .

    PLUS            reduce using rule 63 (term_aux -> empty .)
    MINUS           reduce using rule 63 (term_aux -> empty .)
    LT              reduce using rule 63 (term_aux -> empty .)
    LE              reduce using rule 63 (term_aux -> empty .)
    GT              reduce using rule 63 (term_aux -> empty .)
    GE              reduce using rule 63 (term_aux -> empty .)
    EQ              reduce using rule 63 (term_aux -> empty .)
    NEQ             reduce using rule 63 (term_aux -> empty .)
    AND             reduce using rule 63 (term_aux -> empty .)
    OR              reduce using rule 63 (term_aux -> empty .)
    SEMICOLON       reduce using rule 63 (term_aux -> empty .)
    RBRACK          reduce using rule 63 (term_aux -> empty .)
    RPAREN          reduce using rule 63 (term_aux -> empty .)


state 106

    (64) unary -> NOT unary .

    TIMES           reduce using rule 64 (unary -> NOT unary .)
    DIVIDE          reduce using rule 64 (unary -> NOT unary .)
    PLUS            reduce using rule 64 (unary -> NOT unary .)
    MINUS           reduce using rule 64 (unary -> NOT unary .)
    LT              reduce using rule 64 (unary -> NOT unary .)
    LE              reduce using rule 64 (unary -> NOT unary .)
    GT              reduce using rule 64 (unary -> NOT unary .)
    GE              reduce using rule 64 (unary -> NOT unary .)
    EQ              reduce using rule 64 (unary -> NOT unary .)
    NEQ             reduce using rule 64 (unary -> NOT unary .)
    AND             reduce using rule 64 (unary -> NOT unary .)
    OR              reduce using rule 64 (unary -> NOT unary .)
    SEMICOLON       reduce using rule 64 (unary -> NOT unary .)
    RBRACK          reduce using rule 64 (unary -> NOT unary .)
    RPAREN          reduce using rule 64 (unary -> NOT unary .)


state 107

    (65) unary -> NEG unary .

    TIMES           reduce using rule 65 (unary -> NEG unary .)
    DIVIDE          reduce using rule 65 (unary -> NEG unary .)
    PLUS            reduce using rule 65 (unary -> NEG unary .)
    MINUS           reduce using rule 65 (unary -> NEG unary .)
    LT              reduce using rule 65 (unary -> NEG unary .)
    LE              reduce using rule 65 (unary -> NEG unary .)
    GT              reduce using rule 65 (unary -> NEG unary .)
    GE              reduce using rule 65 (unary -> NEG unary .)
    EQ              reduce using rule 65 (unary -> NEG unary .)
    NEQ             reduce using rule 65 (unary -> NEG unary .)
    AND             reduce using rule 65 (unary -> NEG unary .)
    OR              reduce using rule 65 (unary -> NEG unary .)
    SEMICOLON       reduce using rule 65 (unary -> NEG unary .)
    RBRACK          reduce using rule 65 (unary -> NEG unary .)
    RPAREN          reduce using rule 65 (unary -> NEG unary .)


state 108

    (67) factor -> LPAREN boolean . RPAREN

    RPAREN          shift and go to state 125


state 109

    (36) offset -> LBRACK boolean RBRACK . offset
    (36) offset -> . LBRACK boolean RBRACK offset
    (37) offset -> . empty
    (73) empty -> .

    LBRACK          shift and go to state 44
    EQUALS          reduce using rule 73 (empty -> .)
    TIMES           reduce using rule 73 (empty -> .)
    DIVIDE          reduce using rule 73 (empty -> .)
    PLUS            reduce using rule 73 (empty -> .)
    MINUS           reduce using rule 73 (empty -> .)
    LT              reduce using rule 73 (empty -> .)
    LE              reduce using rule 73 (empty -> .)
    GT              reduce using rule 73 (empty -> .)
    GE              reduce using rule 73 (empty -> .)
    DOT             reduce using rule 73 (empty -> .)
    RPAREN          reduce using rule 73 (empty -> .)
    EQ              reduce using rule 73 (empty -> .)
    NEQ             reduce using rule 73 (empty -> .)
    AND             reduce using rule 73 (empty -> .)
    OR              reduce using rule 73 (empty -> .)
    SEMICOLON       reduce using rule 73 (empty -> .)
    RBRACK          reduce using rule 73 (empty -> .)

    offset                         shift and go to state 126
    empty                          shift and go to state 127

state 110

    (38) field -> DOT factor field .

    EQUALS          reduce using rule 38 (field -> DOT factor field .)
    TIMES           reduce using rule 38 (field -> DOT factor field .)
    DIVIDE          reduce using rule 38 (field -> DOT factor field .)
    PLUS            reduce using rule 38 (field -> DOT factor field .)
    MINUS           reduce using rule 38 (field -> DOT factor field .)
    LT              reduce using rule 38 (field -> DOT factor field .)
    LE              reduce using rule 38 (field -> DOT factor field .)
    GT              reduce using rule 38 (field -> DOT factor field .)
    GE              reduce using rule 38 (field -> DOT factor field .)
    DOT             reduce using rule 38 (field -> DOT factor field .)
    RPAREN          reduce using rule 38 (field -> DOT factor field .)
    EQ              reduce using rule 38 (field -> DOT factor field .)
    NEQ             reduce using rule 38 (field -> DOT factor field .)
    AND             reduce using rule 38 (field -> DOT factor field .)
    OR              reduce using rule 38 (field -> DOT factor field .)
    SEMICOLON       reduce using rule 38 (field -> DOT factor field .)
    RBRACK          reduce using rule 38 (field -> DOT factor field .)


state 111

    (26) conditional -> IF LPAREN boolean RPAREN . statement conditional_aux
    (16) statement -> . local EQUALS boolean SEMICOLON
    (17) statement -> . conditional
    (18) statement -> . while_loop
    (19) statement -> . do_while_loop
    (20) statement -> . BREAK SEMICOLON
    (21) statement -> . print
    (22) statement -> . read
    (23) statement -> . block
    (31) local -> . HASH ID local_aux
    (32) local -> . ID local_aux
    (26) conditional -> . IF LPAREN boolean RPAREN statement conditional_aux
    (29) while_loop -> . WHILE LPAREN boolean RPAREN statement
    (30) do_while_loop -> . DO statement WHILE LPAREN boolean RPAREN SEMICOLON
    (24) print -> . PRINT LPAREN boolean RPAREN SEMICOLON
    (25) read -> . READ LPAREN local RPAREN SEMICOLON
    (2) block -> . LBRACE declaration statements RBRACE

    BREAK           shift and go to state 19
    HASH            shift and go to state 23
    ID              shift and go to state 24
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    DO              shift and go to state 27
    PRINT           shift and go to state 28
    READ            shift and go to state 29
    LBRACE          shift and go to state 3

    statement                      shift and go to state 128
    local                          shift and go to state 15
    conditional                    shift and go to state 16
    while_loop                     shift and go to state 17
    do_while_loop                  shift and go to state 18
    print                          shift and go to state 20
    read                           shift and go to state 21
    block                          shift and go to state 22

state 112

    (29) while_loop -> WHILE LPAREN boolean RPAREN . statement
    (16) statement -> . local EQUALS boolean SEMICOLON
    (17) statement -> . conditional
    (18) statement -> . while_loop
    (19) statement -> . do_while_loop
    (20) statement -> . BREAK SEMICOLON
    (21) statement -> . print
    (22) statement -> . read
    (23) statement -> . block
    (31) local -> . HASH ID local_aux
    (32) local -> . ID local_aux
    (26) conditional -> . IF LPAREN boolean RPAREN statement conditional_aux
    (29) while_loop -> . WHILE LPAREN boolean RPAREN statement
    (30) do_while_loop -> . DO statement WHILE LPAREN boolean RPAREN SEMICOLON
    (24) print -> . PRINT LPAREN boolean RPAREN SEMICOLON
    (25) read -> . READ LPAREN local RPAREN SEMICOLON
    (2) block -> . LBRACE declaration statements RBRACE

    BREAK           shift and go to state 19
    HASH            shift and go to state 23
    ID              shift and go to state 24
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    DO              shift and go to state 27
    PRINT           shift and go to state 28
    READ            shift and go to state 29
    LBRACE          shift and go to state 3

    statement                      shift and go to state 129
    local                          shift and go to state 15
    conditional                    shift and go to state 16
    while_loop                     shift and go to state 17
    do_while_loop                  shift and go to state 18
    print                          shift and go to state 20
    read                           shift and go to state 21
    block                          shift and go to state 22

state 113

    (30) do_while_loop -> DO statement WHILE LPAREN . boolean RPAREN SEMICOLON
    (40) boolean -> . join boolean_aux
    (43) join -> . equality join_aux
    (46) equality -> . relational equality_aux
    (50) relational -> . expression relational_operator expression
    (55) expression -> . term expression_aux
    (60) term -> . unary term_aux
    (64) unary -> . NOT unary
    (65) unary -> . NEG unary
    (66) unary -> . factor
    (67) factor -> . LPAREN boolean RPAREN
    (68) factor -> . local
    (69) factor -> . NUMBER_INT
    (70) factor -> . NUMBER_FLOAT
    (71) factor -> . FALSE
    (72) factor -> . TRUE
    (31) local -> . HASH ID local_aux
    (32) local -> . ID local_aux

    NOT             shift and go to state 62
    NEG             shift and go to state 63
    LPAREN          shift and go to state 65
    NUMBER_INT      shift and go to state 66
    NUMBER_FLOAT    shift and go to state 67
    FALSE           shift and go to state 68
    TRUE            shift and go to state 69
    HASH            shift and go to state 23
    ID              shift and go to state 24

    boolean                        shift and go to state 130
    join                           shift and go to state 56
    equality                       shift and go to state 57
    relational                     shift and go to state 58
    expression                     shift and go to state 59
    term                           shift and go to state 60
    unary                          shift and go to state 61
    factor                         shift and go to state 64
    local                          shift and go to state 54

state 114

    (24) print -> PRINT LPAREN boolean RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 131


state 115

    (25) read -> READ LPAREN local RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 132


state 116

    (9) dimensions -> LBRACK NUMBER_INT RBRACK dimensions .

    ID              reduce using rule 9 (dimensions -> LBRACK NUMBER_INT RBRACK dimensions .)


state 117

    (41) boolean_aux -> OR join . boolean_aux
    (41) boolean_aux -> . OR join boolean_aux
    (42) boolean_aux -> . empty
    (73) empty -> .

    OR              shift and go to state 83
    SEMICOLON       reduce using rule 73 (empty -> .)
    RBRACK          reduce using rule 73 (empty -> .)
    RPAREN          reduce using rule 73 (empty -> .)

    boolean_aux                    shift and go to state 133
    empty                          shift and go to state 84

state 118

    (44) join_aux -> AND equality . join_aux
    (44) join_aux -> . AND equality join_aux
    (45) join_aux -> . empty
    (73) empty -> .

    AND             shift and go to state 86
    OR              reduce using rule 73 (empty -> .)
    SEMICOLON       reduce using rule 73 (empty -> .)
    RBRACK          reduce using rule 73 (empty -> .)
    RPAREN          reduce using rule 73 (empty -> .)

    join_aux                       shift and go to state 134
    empty                          shift and go to state 87

state 119

    (47) equality_aux -> EQ relational . equality_aux
    (47) equality_aux -> . EQ relational equality_aux
    (48) equality_aux -> . NEQ relational equality_aux
    (49) equality_aux -> . empty
    (73) empty -> .

    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    AND             reduce using rule 73 (empty -> .)
    OR              reduce using rule 73 (empty -> .)
    SEMICOLON       reduce using rule 73 (empty -> .)
    RBRACK          reduce using rule 73 (empty -> .)
    RPAREN          reduce using rule 73 (empty -> .)

    equality_aux                   shift and go to state 135
    empty                          shift and go to state 91

state 120

    (48) equality_aux -> NEQ relational . equality_aux
    (47) equality_aux -> . EQ relational equality_aux
    (48) equality_aux -> . NEQ relational equality_aux
    (49) equality_aux -> . empty
    (73) empty -> .

    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    AND             reduce using rule 73 (empty -> .)
    OR              reduce using rule 73 (empty -> .)
    SEMICOLON       reduce using rule 73 (empty -> .)
    RBRACK          reduce using rule 73 (empty -> .)
    RPAREN          reduce using rule 73 (empty -> .)

    equality_aux                   shift and go to state 136
    empty                          shift and go to state 91

state 121

    (50) relational -> expression relational_operator expression .

    EQ              reduce using rule 50 (relational -> expression relational_operator expression .)
    NEQ             reduce using rule 50 (relational -> expression relational_operator expression .)
    AND             reduce using rule 50 (relational -> expression relational_operator expression .)
    OR              reduce using rule 50 (relational -> expression relational_operator expression .)
    SEMICOLON       reduce using rule 50 (relational -> expression relational_operator expression .)
    RBRACK          reduce using rule 50 (relational -> expression relational_operator expression .)
    RPAREN          reduce using rule 50 (relational -> expression relational_operator expression .)


state 122

    (56) expression_aux -> expression_operator term . expression_aux
    (56) expression_aux -> . expression_operator term expression_aux
    (57) expression_aux -> . empty
    (58) expression_operator -> . PLUS
    (59) expression_operator -> . MINUS
    (73) empty -> .

    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    LT              reduce using rule 73 (empty -> .)
    LE              reduce using rule 73 (empty -> .)
    GT              reduce using rule 73 (empty -> .)
    GE              reduce using rule 73 (empty -> .)
    EQ              reduce using rule 73 (empty -> .)
    NEQ             reduce using rule 73 (empty -> .)
    AND             reduce using rule 73 (empty -> .)
    OR              reduce using rule 73 (empty -> .)
    SEMICOLON       reduce using rule 73 (empty -> .)
    RBRACK          reduce using rule 73 (empty -> .)
    RPAREN          reduce using rule 73 (empty -> .)

    expression_operator            shift and go to state 98
    expression_aux                 shift and go to state 137
    empty                          shift and go to state 99

state 123

    (61) term_aux -> TIMES unary . term_aux
    (61) term_aux -> . TIMES unary term_aux
    (62) term_aux -> . DIVIDE unary term_aux
    (63) term_aux -> . empty
    (73) empty -> .

    TIMES           shift and go to state 103
    DIVIDE          shift and go to state 104
    PLUS            reduce using rule 73 (empty -> .)
    MINUS           reduce using rule 73 (empty -> .)
    LT              reduce using rule 73 (empty -> .)
    LE              reduce using rule 73 (empty -> .)
    GT              reduce using rule 73 (empty -> .)
    GE              reduce using rule 73 (empty -> .)
    EQ              reduce using rule 73 (empty -> .)
    NEQ             reduce using rule 73 (empty -> .)
    AND             reduce using rule 73 (empty -> .)
    OR              reduce using rule 73 (empty -> .)
    SEMICOLON       reduce using rule 73 (empty -> .)
    RBRACK          reduce using rule 73 (empty -> .)
    RPAREN          reduce using rule 73 (empty -> .)

    term_aux                       shift and go to state 138
    empty                          shift and go to state 105

state 124

    (62) term_aux -> DIVIDE unary . term_aux
    (61) term_aux -> . TIMES unary term_aux
    (62) term_aux -> . DIVIDE unary term_aux
    (63) term_aux -> . empty
    (73) empty -> .

    TIMES           shift and go to state 103
    DIVIDE          shift and go to state 104
    PLUS            reduce using rule 73 (empty -> .)
    MINUS           reduce using rule 73 (empty -> .)
    LT              reduce using rule 73 (empty -> .)
    LE              reduce using rule 73 (empty -> .)
    GT              reduce using rule 73 (empty -> .)
    GE              reduce using rule 73 (empty -> .)
    EQ              reduce using rule 73 (empty -> .)
    NEQ             reduce using rule 73 (empty -> .)
    AND             reduce using rule 73 (empty -> .)
    OR              reduce using rule 73 (empty -> .)
    SEMICOLON       reduce using rule 73 (empty -> .)
    RBRACK          reduce using rule 73 (empty -> .)
    RPAREN          reduce using rule 73 (empty -> .)

    term_aux                       shift and go to state 139
    empty                          shift and go to state 105

state 125

    (67) factor -> LPAREN boolean RPAREN .

    TIMES           reduce using rule 67 (factor -> LPAREN boolean RPAREN .)
    DIVIDE          reduce using rule 67 (factor -> LPAREN boolean RPAREN .)
    PLUS            reduce using rule 67 (factor -> LPAREN boolean RPAREN .)
    MINUS           reduce using rule 67 (factor -> LPAREN boolean RPAREN .)
    LT              reduce using rule 67 (factor -> LPAREN boolean RPAREN .)
    LE              reduce using rule 67 (factor -> LPAREN boolean RPAREN .)
    GT              reduce using rule 67 (factor -> LPAREN boolean RPAREN .)
    GE              reduce using rule 67 (factor -> LPAREN boolean RPAREN .)
    EQUALS          reduce using rule 67 (factor -> LPAREN boolean RPAREN .)
    DOT             reduce using rule 67 (factor -> LPAREN boolean RPAREN .)
    RPAREN          reduce using rule 67 (factor -> LPAREN boolean RPAREN .)
    EQ              reduce using rule 67 (factor -> LPAREN boolean RPAREN .)
    NEQ             reduce using rule 67 (factor -> LPAREN boolean RPAREN .)
    AND             reduce using rule 67 (factor -> LPAREN boolean RPAREN .)
    OR              reduce using rule 67 (factor -> LPAREN boolean RPAREN .)
    SEMICOLON       reduce using rule 67 (factor -> LPAREN boolean RPAREN .)
    RBRACK          reduce using rule 67 (factor -> LPAREN boolean RPAREN .)


state 126

    (36) offset -> LBRACK boolean RBRACK offset .

    EQUALS          reduce using rule 36 (offset -> LBRACK boolean RBRACK offset .)
    TIMES           reduce using rule 36 (offset -> LBRACK boolean RBRACK offset .)
    DIVIDE          reduce using rule 36 (offset -> LBRACK boolean RBRACK offset .)
    PLUS            reduce using rule 36 (offset -> LBRACK boolean RBRACK offset .)
    MINUS           reduce using rule 36 (offset -> LBRACK boolean RBRACK offset .)
    LT              reduce using rule 36 (offset -> LBRACK boolean RBRACK offset .)
    LE              reduce using rule 36 (offset -> LBRACK boolean RBRACK offset .)
    GT              reduce using rule 36 (offset -> LBRACK boolean RBRACK offset .)
    GE              reduce using rule 36 (offset -> LBRACK boolean RBRACK offset .)
    DOT             reduce using rule 36 (offset -> LBRACK boolean RBRACK offset .)
    RPAREN          reduce using rule 36 (offset -> LBRACK boolean RBRACK offset .)
    EQ              reduce using rule 36 (offset -> LBRACK boolean RBRACK offset .)
    NEQ             reduce using rule 36 (offset -> LBRACK boolean RBRACK offset .)
    AND             reduce using rule 36 (offset -> LBRACK boolean RBRACK offset .)
    OR              reduce using rule 36 (offset -> LBRACK boolean RBRACK offset .)
    SEMICOLON       reduce using rule 36 (offset -> LBRACK boolean RBRACK offset .)
    RBRACK          reduce using rule 36 (offset -> LBRACK boolean RBRACK offset .)


state 127

    (37) offset -> empty .

    EQUALS          reduce using rule 37 (offset -> empty .)
    TIMES           reduce using rule 37 (offset -> empty .)
    DIVIDE          reduce using rule 37 (offset -> empty .)
    PLUS            reduce using rule 37 (offset -> empty .)
    MINUS           reduce using rule 37 (offset -> empty .)
    LT              reduce using rule 37 (offset -> empty .)
    LE              reduce using rule 37 (offset -> empty .)
    GT              reduce using rule 37 (offset -> empty .)
    GE              reduce using rule 37 (offset -> empty .)
    DOT             reduce using rule 37 (offset -> empty .)
    RPAREN          reduce using rule 37 (offset -> empty .)
    EQ              reduce using rule 37 (offset -> empty .)
    NEQ             reduce using rule 37 (offset -> empty .)
    AND             reduce using rule 37 (offset -> empty .)
    OR              reduce using rule 37 (offset -> empty .)
    SEMICOLON       reduce using rule 37 (offset -> empty .)
    RBRACK          reduce using rule 37 (offset -> empty .)


state 128

    (26) conditional -> IF LPAREN boolean RPAREN statement . conditional_aux
    (27) conditional_aux -> . ELSE statement
    (28) conditional_aux -> . empty
    (73) empty -> .

  ! shift/reduce conflict for ELSE resolved as shift
    ELSE            shift and go to state 141
    BREAK           reduce using rule 73 (empty -> .)
    HASH            reduce using rule 73 (empty -> .)
    ID              reduce using rule 73 (empty -> .)
    IF              reduce using rule 73 (empty -> .)
    WHILE           reduce using rule 73 (empty -> .)
    DO              reduce using rule 73 (empty -> .)
    PRINT           reduce using rule 73 (empty -> .)
    READ            reduce using rule 73 (empty -> .)
    LBRACE          reduce using rule 73 (empty -> .)
    RBRACE          reduce using rule 73 (empty -> .)

  ! ELSE            [ reduce using rule 73 (empty -> .) ]

    conditional_aux                shift and go to state 140
    empty                          shift and go to state 142

state 129

    (29) while_loop -> WHILE LPAREN boolean RPAREN statement .

    BREAK           reduce using rule 29 (while_loop -> WHILE LPAREN boolean RPAREN statement .)
    HASH            reduce using rule 29 (while_loop -> WHILE LPAREN boolean RPAREN statement .)
    ID              reduce using rule 29 (while_loop -> WHILE LPAREN boolean RPAREN statement .)
    IF              reduce using rule 29 (while_loop -> WHILE LPAREN boolean RPAREN statement .)
    WHILE           reduce using rule 29 (while_loop -> WHILE LPAREN boolean RPAREN statement .)
    DO              reduce using rule 29 (while_loop -> WHILE LPAREN boolean RPAREN statement .)
    PRINT           reduce using rule 29 (while_loop -> WHILE LPAREN boolean RPAREN statement .)
    READ            reduce using rule 29 (while_loop -> WHILE LPAREN boolean RPAREN statement .)
    LBRACE          reduce using rule 29 (while_loop -> WHILE LPAREN boolean RPAREN statement .)
    RBRACE          reduce using rule 29 (while_loop -> WHILE LPAREN boolean RPAREN statement .)
    ELSE            reduce using rule 29 (while_loop -> WHILE LPAREN boolean RPAREN statement .)


state 130

    (30) do_while_loop -> DO statement WHILE LPAREN boolean . RPAREN SEMICOLON

    RPAREN          shift and go to state 143


state 131

    (24) print -> PRINT LPAREN boolean RPAREN SEMICOLON .

    BREAK           reduce using rule 24 (print -> PRINT LPAREN boolean RPAREN SEMICOLON .)
    HASH            reduce using rule 24 (print -> PRINT LPAREN boolean RPAREN SEMICOLON .)
    ID              reduce using rule 24 (print -> PRINT LPAREN boolean RPAREN SEMICOLON .)
    IF              reduce using rule 24 (print -> PRINT LPAREN boolean RPAREN SEMICOLON .)
    WHILE           reduce using rule 24 (print -> PRINT LPAREN boolean RPAREN SEMICOLON .)
    DO              reduce using rule 24 (print -> PRINT LPAREN boolean RPAREN SEMICOLON .)
    PRINT           reduce using rule 24 (print -> PRINT LPAREN boolean RPAREN SEMICOLON .)
    READ            reduce using rule 24 (print -> PRINT LPAREN boolean RPAREN SEMICOLON .)
    LBRACE          reduce using rule 24 (print -> PRINT LPAREN boolean RPAREN SEMICOLON .)
    RBRACE          reduce using rule 24 (print -> PRINT LPAREN boolean RPAREN SEMICOLON .)
    ELSE            reduce using rule 24 (print -> PRINT LPAREN boolean RPAREN SEMICOLON .)


state 132

    (25) read -> READ LPAREN local RPAREN SEMICOLON .

    BREAK           reduce using rule 25 (read -> READ LPAREN local RPAREN SEMICOLON .)
    HASH            reduce using rule 25 (read -> READ LPAREN local RPAREN SEMICOLON .)
    ID              reduce using rule 25 (read -> READ LPAREN local RPAREN SEMICOLON .)
    IF              reduce using rule 25 (read -> READ LPAREN local RPAREN SEMICOLON .)
    WHILE           reduce using rule 25 (read -> READ LPAREN local RPAREN SEMICOLON .)
    DO              reduce using rule 25 (read -> READ LPAREN local RPAREN SEMICOLON .)
    PRINT           reduce using rule 25 (read -> READ LPAREN local RPAREN SEMICOLON .)
    READ            reduce using rule 25 (read -> READ LPAREN local RPAREN SEMICOLON .)
    LBRACE          reduce using rule 25 (read -> READ LPAREN local RPAREN SEMICOLON .)
    RBRACE          reduce using rule 25 (read -> READ LPAREN local RPAREN SEMICOLON .)
    ELSE            reduce using rule 25 (read -> READ LPAREN local RPAREN SEMICOLON .)


state 133

    (41) boolean_aux -> OR join boolean_aux .

    SEMICOLON       reduce using rule 41 (boolean_aux -> OR join boolean_aux .)
    RBRACK          reduce using rule 41 (boolean_aux -> OR join boolean_aux .)
    RPAREN          reduce using rule 41 (boolean_aux -> OR join boolean_aux .)


state 134

    (44) join_aux -> AND equality join_aux .

    OR              reduce using rule 44 (join_aux -> AND equality join_aux .)
    SEMICOLON       reduce using rule 44 (join_aux -> AND equality join_aux .)
    RBRACK          reduce using rule 44 (join_aux -> AND equality join_aux .)
    RPAREN          reduce using rule 44 (join_aux -> AND equality join_aux .)


state 135

    (47) equality_aux -> EQ relational equality_aux .

    AND             reduce using rule 47 (equality_aux -> EQ relational equality_aux .)
    OR              reduce using rule 47 (equality_aux -> EQ relational equality_aux .)
    SEMICOLON       reduce using rule 47 (equality_aux -> EQ relational equality_aux .)
    RBRACK          reduce using rule 47 (equality_aux -> EQ relational equality_aux .)
    RPAREN          reduce using rule 47 (equality_aux -> EQ relational equality_aux .)


state 136

    (48) equality_aux -> NEQ relational equality_aux .

    AND             reduce using rule 48 (equality_aux -> NEQ relational equality_aux .)
    OR              reduce using rule 48 (equality_aux -> NEQ relational equality_aux .)
    SEMICOLON       reduce using rule 48 (equality_aux -> NEQ relational equality_aux .)
    RBRACK          reduce using rule 48 (equality_aux -> NEQ relational equality_aux .)
    RPAREN          reduce using rule 48 (equality_aux -> NEQ relational equality_aux .)


state 137

    (56) expression_aux -> expression_operator term expression_aux .

    LT              reduce using rule 56 (expression_aux -> expression_operator term expression_aux .)
    LE              reduce using rule 56 (expression_aux -> expression_operator term expression_aux .)
    GT              reduce using rule 56 (expression_aux -> expression_operator term expression_aux .)
    GE              reduce using rule 56 (expression_aux -> expression_operator term expression_aux .)
    EQ              reduce using rule 56 (expression_aux -> expression_operator term expression_aux .)
    NEQ             reduce using rule 56 (expression_aux -> expression_operator term expression_aux .)
    AND             reduce using rule 56 (expression_aux -> expression_operator term expression_aux .)
    OR              reduce using rule 56 (expression_aux -> expression_operator term expression_aux .)
    SEMICOLON       reduce using rule 56 (expression_aux -> expression_operator term expression_aux .)
    RBRACK          reduce using rule 56 (expression_aux -> expression_operator term expression_aux .)
    RPAREN          reduce using rule 56 (expression_aux -> expression_operator term expression_aux .)


state 138

    (61) term_aux -> TIMES unary term_aux .

    PLUS            reduce using rule 61 (term_aux -> TIMES unary term_aux .)
    MINUS           reduce using rule 61 (term_aux -> TIMES unary term_aux .)
    LT              reduce using rule 61 (term_aux -> TIMES unary term_aux .)
    LE              reduce using rule 61 (term_aux -> TIMES unary term_aux .)
    GT              reduce using rule 61 (term_aux -> TIMES unary term_aux .)
    GE              reduce using rule 61 (term_aux -> TIMES unary term_aux .)
    EQ              reduce using rule 61 (term_aux -> TIMES unary term_aux .)
    NEQ             reduce using rule 61 (term_aux -> TIMES unary term_aux .)
    AND             reduce using rule 61 (term_aux -> TIMES unary term_aux .)
    OR              reduce using rule 61 (term_aux -> TIMES unary term_aux .)
    SEMICOLON       reduce using rule 61 (term_aux -> TIMES unary term_aux .)
    RBRACK          reduce using rule 61 (term_aux -> TIMES unary term_aux .)
    RPAREN          reduce using rule 61 (term_aux -> TIMES unary term_aux .)


state 139

    (62) term_aux -> DIVIDE unary term_aux .

    PLUS            reduce using rule 62 (term_aux -> DIVIDE unary term_aux .)
    MINUS           reduce using rule 62 (term_aux -> DIVIDE unary term_aux .)
    LT              reduce using rule 62 (term_aux -> DIVIDE unary term_aux .)
    LE              reduce using rule 62 (term_aux -> DIVIDE unary term_aux .)
    GT              reduce using rule 62 (term_aux -> DIVIDE unary term_aux .)
    GE              reduce using rule 62 (term_aux -> DIVIDE unary term_aux .)
    EQ              reduce using rule 62 (term_aux -> DIVIDE unary term_aux .)
    NEQ             reduce using rule 62 (term_aux -> DIVIDE unary term_aux .)
    AND             reduce using rule 62 (term_aux -> DIVIDE unary term_aux .)
    OR              reduce using rule 62 (term_aux -> DIVIDE unary term_aux .)
    SEMICOLON       reduce using rule 62 (term_aux -> DIVIDE unary term_aux .)
    RBRACK          reduce using rule 62 (term_aux -> DIVIDE unary term_aux .)
    RPAREN          reduce using rule 62 (term_aux -> DIVIDE unary term_aux .)


state 140

    (26) conditional -> IF LPAREN boolean RPAREN statement conditional_aux .

    BREAK           reduce using rule 26 (conditional -> IF LPAREN boolean RPAREN statement conditional_aux .)
    HASH            reduce using rule 26 (conditional -> IF LPAREN boolean RPAREN statement conditional_aux .)
    ID              reduce using rule 26 (conditional -> IF LPAREN boolean RPAREN statement conditional_aux .)
    IF              reduce using rule 26 (conditional -> IF LPAREN boolean RPAREN statement conditional_aux .)
    WHILE           reduce using rule 26 (conditional -> IF LPAREN boolean RPAREN statement conditional_aux .)
    DO              reduce using rule 26 (conditional -> IF LPAREN boolean RPAREN statement conditional_aux .)
    PRINT           reduce using rule 26 (conditional -> IF LPAREN boolean RPAREN statement conditional_aux .)
    READ            reduce using rule 26 (conditional -> IF LPAREN boolean RPAREN statement conditional_aux .)
    LBRACE          reduce using rule 26 (conditional -> IF LPAREN boolean RPAREN statement conditional_aux .)
    RBRACE          reduce using rule 26 (conditional -> IF LPAREN boolean RPAREN statement conditional_aux .)
    ELSE            reduce using rule 26 (conditional -> IF LPAREN boolean RPAREN statement conditional_aux .)


state 141

    (27) conditional_aux -> ELSE . statement
    (16) statement -> . local EQUALS boolean SEMICOLON
    (17) statement -> . conditional
    (18) statement -> . while_loop
    (19) statement -> . do_while_loop
    (20) statement -> . BREAK SEMICOLON
    (21) statement -> . print
    (22) statement -> . read
    (23) statement -> . block
    (31) local -> . HASH ID local_aux
    (32) local -> . ID local_aux
    (26) conditional -> . IF LPAREN boolean RPAREN statement conditional_aux
    (29) while_loop -> . WHILE LPAREN boolean RPAREN statement
    (30) do_while_loop -> . DO statement WHILE LPAREN boolean RPAREN SEMICOLON
    (24) print -> . PRINT LPAREN boolean RPAREN SEMICOLON
    (25) read -> . READ LPAREN local RPAREN SEMICOLON
    (2) block -> . LBRACE declaration statements RBRACE

    BREAK           shift and go to state 19
    HASH            shift and go to state 23
    ID              shift and go to state 24
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    DO              shift and go to state 27
    PRINT           shift and go to state 28
    READ            shift and go to state 29
    LBRACE          shift and go to state 3

    statement                      shift and go to state 144
    local                          shift and go to state 15
    conditional                    shift and go to state 16
    while_loop                     shift and go to state 17
    do_while_loop                  shift and go to state 18
    print                          shift and go to state 20
    read                           shift and go to state 21
    block                          shift and go to state 22

state 142

    (28) conditional_aux -> empty .

    ELSE            reduce using rule 28 (conditional_aux -> empty .)
    BREAK           reduce using rule 28 (conditional_aux -> empty .)
    HASH            reduce using rule 28 (conditional_aux -> empty .)
    ID              reduce using rule 28 (conditional_aux -> empty .)
    IF              reduce using rule 28 (conditional_aux -> empty .)
    WHILE           reduce using rule 28 (conditional_aux -> empty .)
    DO              reduce using rule 28 (conditional_aux -> empty .)
    PRINT           reduce using rule 28 (conditional_aux -> empty .)
    READ            reduce using rule 28 (conditional_aux -> empty .)
    LBRACE          reduce using rule 28 (conditional_aux -> empty .)
    RBRACE          reduce using rule 28 (conditional_aux -> empty .)


state 143

    (30) do_while_loop -> DO statement WHILE LPAREN boolean RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 145


state 144

    (27) conditional_aux -> ELSE statement .

    ELSE            reduce using rule 27 (conditional_aux -> ELSE statement .)
    BREAK           reduce using rule 27 (conditional_aux -> ELSE statement .)
    HASH            reduce using rule 27 (conditional_aux -> ELSE statement .)
    ID              reduce using rule 27 (conditional_aux -> ELSE statement .)
    IF              reduce using rule 27 (conditional_aux -> ELSE statement .)
    WHILE           reduce using rule 27 (conditional_aux -> ELSE statement .)
    DO              reduce using rule 27 (conditional_aux -> ELSE statement .)
    PRINT           reduce using rule 27 (conditional_aux -> ELSE statement .)
    READ            reduce using rule 27 (conditional_aux -> ELSE statement .)
    LBRACE          reduce using rule 27 (conditional_aux -> ELSE statement .)
    RBRACE          reduce using rule 27 (conditional_aux -> ELSE statement .)


state 145

    (30) do_while_loop -> DO statement WHILE LPAREN boolean RPAREN SEMICOLON .

    BREAK           reduce using rule 30 (do_while_loop -> DO statement WHILE LPAREN boolean RPAREN SEMICOLON .)
    HASH            reduce using rule 30 (do_while_loop -> DO statement WHILE LPAREN boolean RPAREN SEMICOLON .)
    ID              reduce using rule 30 (do_while_loop -> DO statement WHILE LPAREN boolean RPAREN SEMICOLON .)
    IF              reduce using rule 30 (do_while_loop -> DO statement WHILE LPAREN boolean RPAREN SEMICOLON .)
    WHILE           reduce using rule 30 (do_while_loop -> DO statement WHILE LPAREN boolean RPAREN SEMICOLON .)
    DO              reduce using rule 30 (do_while_loop -> DO statement WHILE LPAREN boolean RPAREN SEMICOLON .)
    PRINT           reduce using rule 30 (do_while_loop -> DO statement WHILE LPAREN boolean RPAREN SEMICOLON .)
    READ            reduce using rule 30 (do_while_loop -> DO statement WHILE LPAREN boolean RPAREN SEMICOLON .)
    LBRACE          reduce using rule 30 (do_while_loop -> DO statement WHILE LPAREN boolean RPAREN SEMICOLON .)
    RBRACE          reduce using rule 30 (do_while_loop -> DO statement WHILE LPAREN boolean RPAREN SEMICOLON .)
    ELSE            reduce using rule 30 (do_while_loop -> DO statement WHILE LPAREN boolean RPAREN SEMICOLON .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for DOT in state 24 resolved as shift
WARNING: shift/reduce conflict for DOT in state 39 resolved as shift
WARNING: shift/reduce conflict for DOT in state 72 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 128 resolved as shift
WARNING: reduce/reduce conflict in state 43 resolved using rule (local_aux -> empty)
WARNING: rejected rule (offset -> empty) in state 43
