Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> block
Rule 2     block -> LBRACE declaration statements RBRACE
Rule 3     declaration -> type ID SEMICOLON declaration
Rule 4     declaration -> empty
Rule 5     type -> basic dimensions
Rule 6     type -> basic HASH
Rule 7     type -> basic
Rule 8     type -> RECORD LBRACE declaration RBRACE
Rule 9     dimensions -> LBRACK NUMBER_INT RBRACK dimensions
Rule 10    dimensions -> LBRACK NUMBER_INT RBRACK
Rule 11    basic -> INT
Rule 12    basic -> CHAR
Rule 13    basic -> BOOL
Rule 14    statements -> statement statements
Rule 15    statements -> empty
Rule 16    statement -> local EQUALS boolean SEMICOLON
Rule 17    statement -> conditional
Rule 18    statement -> while_loop
Rule 19    statement -> do_while_loop
Rule 20    statement -> BREAK SEMICOLON
Rule 21    statement -> print
Rule 22    statement -> read
Rule 23    statement -> block
Rule 24    print -> PRINT LPAREN boolean RPAREN SEMICOLON
Rule 25    read -> READ LPAREN local RPAREN SEMICOLON
Rule 26    conditional -> IF LPAREN boolean RPAREN statement conditional_aux
Rule 27    conditional_aux -> ELSE statement
Rule 28    conditional_aux -> empty
Rule 29    while_loop -> WHILE LPAREN boolean RPAREN statement
Rule 30    do_while_loop -> DO statement WHILE LPAREN boolean RPAREN SEMICOLON
Rule 31    local -> HASH ID local_aux
Rule 32    local -> ID local_aux
Rule 33    local_aux -> offset
Rule 34    local_aux -> field
Rule 35    local_aux -> empty
Rule 36    offset -> LBRACK boolean RBRACK offset
Rule 37    offset -> empty
Rule 38    field -> DOT factor field
Rule 39    field -> DOT factor
Rule 40    boolean -> join
Rule 41    boolean -> boolean OR join
Rule 42    join -> equality
Rule 43    join -> join AND equality
Rule 44    equality -> relational
Rule 45    equality -> equality EQ relational
Rule 46    equality -> equality NEQ relational
Rule 47    relational -> expression
Rule 48    relational -> relational_operator expression
Rule 49    relational_operator -> LT
Rule 50    relational_operator -> LE
Rule 51    relational_operator -> GT
Rule 52    relational_operator -> GE
Rule 53    expression -> term expression_aux
Rule 54    expression_aux -> expression_operator term expression_aux
Rule 55    expression_aux -> empty
Rule 56    expression_operator -> PLUS
Rule 57    expression_operator -> MINUS
Rule 58    term -> unary
Rule 59    term -> term TIMES unary
Rule 60    term -> term DIVIDE unary
Rule 61    unary -> NOT unary
Rule 62    unary -> NEG unary
Rule 63    unary -> factor
Rule 64    factor -> LPAREN boolean RPAREN
Rule 65    factor -> local
Rule 66    factor -> NUMBER_INT
Rule 67    factor -> NUMBER_FLOAT
Rule 68    factor -> FALSE
Rule 69    factor -> TRUE
Rule 70    empty -> <empty>

Terminals, with rules where they appear

AND                  : 43
BOOL                 : 13
BREAK                : 20
CHAR                 : 12
DIVIDE               : 60
DO                   : 30
DOT                  : 38 39
ELSE                 : 27
EQ                   : 45
EQUALS               : 16
FALSE                : 68
GE                   : 52
GT                   : 51
HASH                 : 6 31
ID                   : 3 31 32
IF                   : 26
INT                  : 11
LBRACE               : 2 8
LBRACK               : 9 10 36
LE                   : 50
LPAREN               : 24 25 26 29 30 64
LT                   : 49
MINUS                : 57
NEG                  : 62
NEQ                  : 46
NOT                  : 61
NUMBER_FLOAT         : 67
NUMBER_INT           : 9 10 66
OR                   : 41
PLUS                 : 56
PRINT                : 24
RBRACE               : 2 8
RBRACK               : 9 10 36
READ                 : 25
RECORD               : 8
RPAREN               : 24 25 26 29 30 64
SEMICOLON            : 3 16 20 24 25 30
TIMES                : 59
TRUE                 : 69
WHILE                : 29 30
error                : 

Nonterminals, with rules where they appear

basic                : 5 6 7
block                : 1 23
boolean              : 16 24 26 29 30 36 41 64
conditional          : 17
conditional_aux      : 26
declaration          : 2 3 8
dimensions           : 5 9
do_while_loop        : 19
empty                : 4 15 28 35 37 55
equality             : 42 43 45 46
expression           : 47 48
expression_aux       : 53 54
expression_operator  : 54
factor               : 38 39 63
field                : 34 38
join                 : 40 41 43
local                : 16 25 65
local_aux            : 31 32
offset               : 33 36
print                : 21
program              : 0
read                 : 22
relational           : 44 45 46
relational_operator  : 48
statement            : 14 26 27 29 30
statements           : 2 14
term                 : 53 54 59 60
type                 : 3
unary                : 58 59 60 61 62
while_loop           : 18

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . block
    (2) block -> . LBRACE declaration statements RBRACE

    LBRACE          shift and go to state 3

    program                        shift and go to state 1
    block                          shift and go to state 2

state 1

    (0) S' -> program .



state 2

    (1) program -> block .

    $end            reduce using rule 1 (program -> block .)


state 3

    (2) block -> LBRACE . declaration statements RBRACE
    (3) declaration -> . type ID SEMICOLON declaration
    (4) declaration -> . empty
    (5) type -> . basic dimensions
    (6) type -> . basic HASH
    (7) type -> . basic
    (8) type -> . RECORD LBRACE declaration RBRACE
    (70) empty -> .
    (11) basic -> . INT
    (12) basic -> . CHAR
    (13) basic -> . BOOL

    RECORD          shift and go to state 8
    BREAK           reduce using rule 70 (empty -> .)
    HASH            reduce using rule 70 (empty -> .)
    ID              reduce using rule 70 (empty -> .)
    IF              reduce using rule 70 (empty -> .)
    WHILE           reduce using rule 70 (empty -> .)
    DO              reduce using rule 70 (empty -> .)
    PRINT           reduce using rule 70 (empty -> .)
    READ            reduce using rule 70 (empty -> .)
    LBRACE          reduce using rule 70 (empty -> .)
    RBRACE          reduce using rule 70 (empty -> .)
    INT             shift and go to state 9
    CHAR            shift and go to state 10
    BOOL            shift and go to state 11

    declaration                    shift and go to state 4
    type                           shift and go to state 5
    empty                          shift and go to state 6
    basic                          shift and go to state 7

state 4

    (2) block -> LBRACE declaration . statements RBRACE
    (14) statements -> . statement statements
    (15) statements -> . empty
    (16) statement -> . local EQUALS boolean SEMICOLON
    (17) statement -> . conditional
    (18) statement -> . while_loop
    (19) statement -> . do_while_loop
    (20) statement -> . BREAK SEMICOLON
    (21) statement -> . print
    (22) statement -> . read
    (23) statement -> . block
    (70) empty -> .
    (31) local -> . HASH ID local_aux
    (32) local -> . ID local_aux
    (26) conditional -> . IF LPAREN boolean RPAREN statement conditional_aux
    (29) while_loop -> . WHILE LPAREN boolean RPAREN statement
    (30) do_while_loop -> . DO statement WHILE LPAREN boolean RPAREN SEMICOLON
    (24) print -> . PRINT LPAREN boolean RPAREN SEMICOLON
    (25) read -> . READ LPAREN local RPAREN SEMICOLON
    (2) block -> . LBRACE declaration statements RBRACE

    BREAK           shift and go to state 19
    RBRACE          reduce using rule 70 (empty -> .)
    HASH            shift and go to state 23
    ID              shift and go to state 24
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    DO              shift and go to state 27
    PRINT           shift and go to state 28
    READ            shift and go to state 29
    LBRACE          shift and go to state 3

    statements                     shift and go to state 12
    statement                      shift and go to state 13
    empty                          shift and go to state 14
    local                          shift and go to state 15
    conditional                    shift and go to state 16
    while_loop                     shift and go to state 17
    do_while_loop                  shift and go to state 18
    print                          shift and go to state 20
    read                           shift and go to state 21
    block                          shift and go to state 22

state 5

    (3) declaration -> type . ID SEMICOLON declaration

    ID              shift and go to state 30


state 6

    (4) declaration -> empty .

    BREAK           reduce using rule 4 (declaration -> empty .)
    HASH            reduce using rule 4 (declaration -> empty .)
    ID              reduce using rule 4 (declaration -> empty .)
    IF              reduce using rule 4 (declaration -> empty .)
    WHILE           reduce using rule 4 (declaration -> empty .)
    DO              reduce using rule 4 (declaration -> empty .)
    PRINT           reduce using rule 4 (declaration -> empty .)
    READ            reduce using rule 4 (declaration -> empty .)
    LBRACE          reduce using rule 4 (declaration -> empty .)
    RBRACE          reduce using rule 4 (declaration -> empty .)


state 7

    (5) type -> basic . dimensions
    (6) type -> basic . HASH
    (7) type -> basic .
    (9) dimensions -> . LBRACK NUMBER_INT RBRACK dimensions
    (10) dimensions -> . LBRACK NUMBER_INT RBRACK

    HASH            shift and go to state 32
    ID              reduce using rule 7 (type -> basic .)
    LBRACK          shift and go to state 33

    dimensions                     shift and go to state 31

state 8

    (8) type -> RECORD . LBRACE declaration RBRACE

    LBRACE          shift and go to state 34


state 9

    (11) basic -> INT .

    HASH            reduce using rule 11 (basic -> INT .)
    LBRACK          reduce using rule 11 (basic -> INT .)
    ID              reduce using rule 11 (basic -> INT .)


state 10

    (12) basic -> CHAR .

    HASH            reduce using rule 12 (basic -> CHAR .)
    LBRACK          reduce using rule 12 (basic -> CHAR .)
    ID              reduce using rule 12 (basic -> CHAR .)


state 11

    (13) basic -> BOOL .

    HASH            reduce using rule 13 (basic -> BOOL .)
    LBRACK          reduce using rule 13 (basic -> BOOL .)
    ID              reduce using rule 13 (basic -> BOOL .)


state 12

    (2) block -> LBRACE declaration statements . RBRACE

    RBRACE          shift and go to state 35


state 13

    (14) statements -> statement . statements
    (14) statements -> . statement statements
    (15) statements -> . empty
    (16) statement -> . local EQUALS boolean SEMICOLON
    (17) statement -> . conditional
    (18) statement -> . while_loop
    (19) statement -> . do_while_loop
    (20) statement -> . BREAK SEMICOLON
    (21) statement -> . print
    (22) statement -> . read
    (23) statement -> . block
    (70) empty -> .
    (31) local -> . HASH ID local_aux
    (32) local -> . ID local_aux
    (26) conditional -> . IF LPAREN boolean RPAREN statement conditional_aux
    (29) while_loop -> . WHILE LPAREN boolean RPAREN statement
    (30) do_while_loop -> . DO statement WHILE LPAREN boolean RPAREN SEMICOLON
    (24) print -> . PRINT LPAREN boolean RPAREN SEMICOLON
    (25) read -> . READ LPAREN local RPAREN SEMICOLON
    (2) block -> . LBRACE declaration statements RBRACE

    BREAK           shift and go to state 19
    RBRACE          reduce using rule 70 (empty -> .)
    HASH            shift and go to state 23
    ID              shift and go to state 24
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    DO              shift and go to state 27
    PRINT           shift and go to state 28
    READ            shift and go to state 29
    LBRACE          shift and go to state 3

    statement                      shift and go to state 13
    statements                     shift and go to state 36
    empty                          shift and go to state 14
    local                          shift and go to state 15
    conditional                    shift and go to state 16
    while_loop                     shift and go to state 17
    do_while_loop                  shift and go to state 18
    print                          shift and go to state 20
    read                           shift and go to state 21
    block                          shift and go to state 22

state 14

    (15) statements -> empty .

    RBRACE          reduce using rule 15 (statements -> empty .)


state 15

    (16) statement -> local . EQUALS boolean SEMICOLON

    EQUALS          shift and go to state 37


state 16

    (17) statement -> conditional .

    BREAK           reduce using rule 17 (statement -> conditional .)
    HASH            reduce using rule 17 (statement -> conditional .)
    ID              reduce using rule 17 (statement -> conditional .)
    IF              reduce using rule 17 (statement -> conditional .)
    WHILE           reduce using rule 17 (statement -> conditional .)
    DO              reduce using rule 17 (statement -> conditional .)
    PRINT           reduce using rule 17 (statement -> conditional .)
    READ            reduce using rule 17 (statement -> conditional .)
    LBRACE          reduce using rule 17 (statement -> conditional .)
    RBRACE          reduce using rule 17 (statement -> conditional .)
    ELSE            reduce using rule 17 (statement -> conditional .)


state 17

    (18) statement -> while_loop .

    BREAK           reduce using rule 18 (statement -> while_loop .)
    HASH            reduce using rule 18 (statement -> while_loop .)
    ID              reduce using rule 18 (statement -> while_loop .)
    IF              reduce using rule 18 (statement -> while_loop .)
    WHILE           reduce using rule 18 (statement -> while_loop .)
    DO              reduce using rule 18 (statement -> while_loop .)
    PRINT           reduce using rule 18 (statement -> while_loop .)
    READ            reduce using rule 18 (statement -> while_loop .)
    LBRACE          reduce using rule 18 (statement -> while_loop .)
    RBRACE          reduce using rule 18 (statement -> while_loop .)
    ELSE            reduce using rule 18 (statement -> while_loop .)


state 18

    (19) statement -> do_while_loop .

    BREAK           reduce using rule 19 (statement -> do_while_loop .)
    HASH            reduce using rule 19 (statement -> do_while_loop .)
    ID              reduce using rule 19 (statement -> do_while_loop .)
    IF              reduce using rule 19 (statement -> do_while_loop .)
    WHILE           reduce using rule 19 (statement -> do_while_loop .)
    DO              reduce using rule 19 (statement -> do_while_loop .)
    PRINT           reduce using rule 19 (statement -> do_while_loop .)
    READ            reduce using rule 19 (statement -> do_while_loop .)
    LBRACE          reduce using rule 19 (statement -> do_while_loop .)
    RBRACE          reduce using rule 19 (statement -> do_while_loop .)
    ELSE            reduce using rule 19 (statement -> do_while_loop .)


state 19

    (20) statement -> BREAK . SEMICOLON

    SEMICOLON       shift and go to state 38


state 20

    (21) statement -> print .

    BREAK           reduce using rule 21 (statement -> print .)
    HASH            reduce using rule 21 (statement -> print .)
    ID              reduce using rule 21 (statement -> print .)
    IF              reduce using rule 21 (statement -> print .)
    WHILE           reduce using rule 21 (statement -> print .)
    DO              reduce using rule 21 (statement -> print .)
    PRINT           reduce using rule 21 (statement -> print .)
    READ            reduce using rule 21 (statement -> print .)
    LBRACE          reduce using rule 21 (statement -> print .)
    RBRACE          reduce using rule 21 (statement -> print .)
    ELSE            reduce using rule 21 (statement -> print .)


state 21

    (22) statement -> read .

    BREAK           reduce using rule 22 (statement -> read .)
    HASH            reduce using rule 22 (statement -> read .)
    ID              reduce using rule 22 (statement -> read .)
    IF              reduce using rule 22 (statement -> read .)
    WHILE           reduce using rule 22 (statement -> read .)
    DO              reduce using rule 22 (statement -> read .)
    PRINT           reduce using rule 22 (statement -> read .)
    READ            reduce using rule 22 (statement -> read .)
    LBRACE          reduce using rule 22 (statement -> read .)
    RBRACE          reduce using rule 22 (statement -> read .)
    ELSE            reduce using rule 22 (statement -> read .)


state 22

    (23) statement -> block .

    BREAK           reduce using rule 23 (statement -> block .)
    HASH            reduce using rule 23 (statement -> block .)
    ID              reduce using rule 23 (statement -> block .)
    IF              reduce using rule 23 (statement -> block .)
    WHILE           reduce using rule 23 (statement -> block .)
    DO              reduce using rule 23 (statement -> block .)
    PRINT           reduce using rule 23 (statement -> block .)
    READ            reduce using rule 23 (statement -> block .)
    LBRACE          reduce using rule 23 (statement -> block .)
    RBRACE          reduce using rule 23 (statement -> block .)
    ELSE            reduce using rule 23 (statement -> block .)


state 23

    (31) local -> HASH . ID local_aux

    ID              shift and go to state 39


state 24

    (32) local -> ID . local_aux
    (33) local_aux -> . offset
    (34) local_aux -> . field
    (35) local_aux -> . empty
    (36) offset -> . LBRACK boolean RBRACK offset
    (37) offset -> . empty
    (38) field -> . DOT factor field
    (39) field -> . DOT factor
    (70) empty -> .

  ! shift/reduce conflict for DOT resolved as shift
    LBRACK          shift and go to state 44
    DOT             shift and go to state 45
    EQUALS          reduce using rule 70 (empty -> .)
    TIMES           reduce using rule 70 (empty -> .)
    DIVIDE          reduce using rule 70 (empty -> .)
    PLUS            reduce using rule 70 (empty -> .)
    MINUS           reduce using rule 70 (empty -> .)
    EQ              reduce using rule 70 (empty -> .)
    NEQ             reduce using rule 70 (empty -> .)
    AND             reduce using rule 70 (empty -> .)
    SEMICOLON       reduce using rule 70 (empty -> .)
    OR              reduce using rule 70 (empty -> .)
    RBRACK          reduce using rule 70 (empty -> .)
    RPAREN          reduce using rule 70 (empty -> .)

  ! DOT             [ reduce using rule 70 (empty -> .) ]

    local_aux                      shift and go to state 40
    offset                         shift and go to state 41
    field                          shift and go to state 42
    empty                          shift and go to state 43

state 25

    (26) conditional -> IF . LPAREN boolean RPAREN statement conditional_aux

    LPAREN          shift and go to state 46


state 26

    (29) while_loop -> WHILE . LPAREN boolean RPAREN statement

    LPAREN          shift and go to state 47


state 27

    (30) do_while_loop -> DO . statement WHILE LPAREN boolean RPAREN SEMICOLON
    (16) statement -> . local EQUALS boolean SEMICOLON
    (17) statement -> . conditional
    (18) statement -> . while_loop
    (19) statement -> . do_while_loop
    (20) statement -> . BREAK SEMICOLON
    (21) statement -> . print
    (22) statement -> . read
    (23) statement -> . block
    (31) local -> . HASH ID local_aux
    (32) local -> . ID local_aux
    (26) conditional -> . IF LPAREN boolean RPAREN statement conditional_aux
    (29) while_loop -> . WHILE LPAREN boolean RPAREN statement
    (30) do_while_loop -> . DO statement WHILE LPAREN boolean RPAREN SEMICOLON
    (24) print -> . PRINT LPAREN boolean RPAREN SEMICOLON
    (25) read -> . READ LPAREN local RPAREN SEMICOLON
    (2) block -> . LBRACE declaration statements RBRACE

    BREAK           shift and go to state 19
    HASH            shift and go to state 23
    ID              shift and go to state 24
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    DO              shift and go to state 27
    PRINT           shift and go to state 28
    READ            shift and go to state 29
    LBRACE          shift and go to state 3

    statement                      shift and go to state 48
    local                          shift and go to state 15
    conditional                    shift and go to state 16
    while_loop                     shift and go to state 17
    do_while_loop                  shift and go to state 18
    print                          shift and go to state 20
    read                           shift and go to state 21
    block                          shift and go to state 22

state 28

    (24) print -> PRINT . LPAREN boolean RPAREN SEMICOLON

    LPAREN          shift and go to state 49


state 29

    (25) read -> READ . LPAREN local RPAREN SEMICOLON

    LPAREN          shift and go to state 50


state 30

    (3) declaration -> type ID . SEMICOLON declaration

    SEMICOLON       shift and go to state 51


state 31

    (5) type -> basic dimensions .

    ID              reduce using rule 5 (type -> basic dimensions .)


state 32

    (6) type -> basic HASH .

    ID              reduce using rule 6 (type -> basic HASH .)


state 33

    (9) dimensions -> LBRACK . NUMBER_INT RBRACK dimensions
    (10) dimensions -> LBRACK . NUMBER_INT RBRACK

    NUMBER_INT      shift and go to state 52


state 34

    (8) type -> RECORD LBRACE . declaration RBRACE
    (3) declaration -> . type ID SEMICOLON declaration
    (4) declaration -> . empty
    (5) type -> . basic dimensions
    (6) type -> . basic HASH
    (7) type -> . basic
    (8) type -> . RECORD LBRACE declaration RBRACE
    (70) empty -> .
    (11) basic -> . INT
    (12) basic -> . CHAR
    (13) basic -> . BOOL

    RECORD          shift and go to state 8
    RBRACE          reduce using rule 70 (empty -> .)
    INT             shift and go to state 9
    CHAR            shift and go to state 10
    BOOL            shift and go to state 11

    declaration                    shift and go to state 53
    type                           shift and go to state 5
    empty                          shift and go to state 6
    basic                          shift and go to state 7

state 35

    (2) block -> LBRACE declaration statements RBRACE .

    $end            reduce using rule 2 (block -> LBRACE declaration statements RBRACE .)
    BREAK           reduce using rule 2 (block -> LBRACE declaration statements RBRACE .)
    HASH            reduce using rule 2 (block -> LBRACE declaration statements RBRACE .)
    ID              reduce using rule 2 (block -> LBRACE declaration statements RBRACE .)
    IF              reduce using rule 2 (block -> LBRACE declaration statements RBRACE .)
    WHILE           reduce using rule 2 (block -> LBRACE declaration statements RBRACE .)
    DO              reduce using rule 2 (block -> LBRACE declaration statements RBRACE .)
    PRINT           reduce using rule 2 (block -> LBRACE declaration statements RBRACE .)
    READ            reduce using rule 2 (block -> LBRACE declaration statements RBRACE .)
    LBRACE          reduce using rule 2 (block -> LBRACE declaration statements RBRACE .)
    RBRACE          reduce using rule 2 (block -> LBRACE declaration statements RBRACE .)
    ELSE            reduce using rule 2 (block -> LBRACE declaration statements RBRACE .)


state 36

    (14) statements -> statement statements .

    RBRACE          reduce using rule 14 (statements -> statement statements .)


state 37

    (16) statement -> local EQUALS . boolean SEMICOLON
    (40) boolean -> . join
    (41) boolean -> . boolean OR join
    (42) join -> . equality
    (43) join -> . join AND equality
    (44) equality -> . relational
    (45) equality -> . equality EQ relational
    (46) equality -> . equality NEQ relational
    (47) relational -> . expression
    (48) relational -> . relational_operator expression
    (53) expression -> . term expression_aux
    (49) relational_operator -> . LT
    (50) relational_operator -> . LE
    (51) relational_operator -> . GT
    (52) relational_operator -> . GE
    (58) term -> . unary
    (59) term -> . term TIMES unary
    (60) term -> . term DIVIDE unary
    (61) unary -> . NOT unary
    (62) unary -> . NEG unary
    (63) unary -> . factor
    (64) factor -> . LPAREN boolean RPAREN
    (65) factor -> . local
    (66) factor -> . NUMBER_INT
    (67) factor -> . NUMBER_FLOAT
    (68) factor -> . FALSE
    (69) factor -> . TRUE
    (31) local -> . HASH ID local_aux
    (32) local -> . ID local_aux

    LT              shift and go to state 62
    LE              shift and go to state 63
    GT              shift and go to state 64
    GE              shift and go to state 65
    NOT             shift and go to state 67
    NEG             shift and go to state 68
    LPAREN          shift and go to state 70
    NUMBER_INT      shift and go to state 71
    NUMBER_FLOAT    shift and go to state 72
    FALSE           shift and go to state 73
    TRUE            shift and go to state 74
    HASH            shift and go to state 23
    ID              shift and go to state 24

    local                          shift and go to state 54
    boolean                        shift and go to state 55
    join                           shift and go to state 56
    equality                       shift and go to state 57
    relational                     shift and go to state 58
    expression                     shift and go to state 59
    relational_operator            shift and go to state 60
    term                           shift and go to state 61
    unary                          shift and go to state 66
    factor                         shift and go to state 69

state 38

    (20) statement -> BREAK SEMICOLON .

    BREAK           reduce using rule 20 (statement -> BREAK SEMICOLON .)
    HASH            reduce using rule 20 (statement -> BREAK SEMICOLON .)
    ID              reduce using rule 20 (statement -> BREAK SEMICOLON .)
    IF              reduce using rule 20 (statement -> BREAK SEMICOLON .)
    WHILE           reduce using rule 20 (statement -> BREAK SEMICOLON .)
    DO              reduce using rule 20 (statement -> BREAK SEMICOLON .)
    PRINT           reduce using rule 20 (statement -> BREAK SEMICOLON .)
    READ            reduce using rule 20 (statement -> BREAK SEMICOLON .)
    LBRACE          reduce using rule 20 (statement -> BREAK SEMICOLON .)
    RBRACE          reduce using rule 20 (statement -> BREAK SEMICOLON .)
    ELSE            reduce using rule 20 (statement -> BREAK SEMICOLON .)


state 39

    (31) local -> HASH ID . local_aux
    (33) local_aux -> . offset
    (34) local_aux -> . field
    (35) local_aux -> . empty
    (36) offset -> . LBRACK boolean RBRACK offset
    (37) offset -> . empty
    (38) field -> . DOT factor field
    (39) field -> . DOT factor
    (70) empty -> .

  ! shift/reduce conflict for DOT resolved as shift
    LBRACK          shift and go to state 44
    DOT             shift and go to state 45
    EQUALS          reduce using rule 70 (empty -> .)
    TIMES           reduce using rule 70 (empty -> .)
    DIVIDE          reduce using rule 70 (empty -> .)
    PLUS            reduce using rule 70 (empty -> .)
    MINUS           reduce using rule 70 (empty -> .)
    EQ              reduce using rule 70 (empty -> .)
    NEQ             reduce using rule 70 (empty -> .)
    AND             reduce using rule 70 (empty -> .)
    SEMICOLON       reduce using rule 70 (empty -> .)
    OR              reduce using rule 70 (empty -> .)
    RBRACK          reduce using rule 70 (empty -> .)
    RPAREN          reduce using rule 70 (empty -> .)

  ! DOT             [ reduce using rule 70 (empty -> .) ]

    local_aux                      shift and go to state 75
    offset                         shift and go to state 41
    field                          shift and go to state 42
    empty                          shift and go to state 43

state 40

    (32) local -> ID local_aux .

    EQUALS          reduce using rule 32 (local -> ID local_aux .)
    TIMES           reduce using rule 32 (local -> ID local_aux .)
    DIVIDE          reduce using rule 32 (local -> ID local_aux .)
    PLUS            reduce using rule 32 (local -> ID local_aux .)
    MINUS           reduce using rule 32 (local -> ID local_aux .)
    EQ              reduce using rule 32 (local -> ID local_aux .)
    NEQ             reduce using rule 32 (local -> ID local_aux .)
    AND             reduce using rule 32 (local -> ID local_aux .)
    SEMICOLON       reduce using rule 32 (local -> ID local_aux .)
    OR              reduce using rule 32 (local -> ID local_aux .)
    RBRACK          reduce using rule 32 (local -> ID local_aux .)
    DOT             reduce using rule 32 (local -> ID local_aux .)
    RPAREN          reduce using rule 32 (local -> ID local_aux .)


state 41

    (33) local_aux -> offset .

    EQUALS          reduce using rule 33 (local_aux -> offset .)
    TIMES           reduce using rule 33 (local_aux -> offset .)
    DIVIDE          reduce using rule 33 (local_aux -> offset .)
    PLUS            reduce using rule 33 (local_aux -> offset .)
    MINUS           reduce using rule 33 (local_aux -> offset .)
    EQ              reduce using rule 33 (local_aux -> offset .)
    NEQ             reduce using rule 33 (local_aux -> offset .)
    AND             reduce using rule 33 (local_aux -> offset .)
    SEMICOLON       reduce using rule 33 (local_aux -> offset .)
    OR              reduce using rule 33 (local_aux -> offset .)
    RBRACK          reduce using rule 33 (local_aux -> offset .)
    DOT             reduce using rule 33 (local_aux -> offset .)
    RPAREN          reduce using rule 33 (local_aux -> offset .)


state 42

    (34) local_aux -> field .

    EQUALS          reduce using rule 34 (local_aux -> field .)
    TIMES           reduce using rule 34 (local_aux -> field .)
    DIVIDE          reduce using rule 34 (local_aux -> field .)
    PLUS            reduce using rule 34 (local_aux -> field .)
    MINUS           reduce using rule 34 (local_aux -> field .)
    EQ              reduce using rule 34 (local_aux -> field .)
    NEQ             reduce using rule 34 (local_aux -> field .)
    AND             reduce using rule 34 (local_aux -> field .)
    SEMICOLON       reduce using rule 34 (local_aux -> field .)
    OR              reduce using rule 34 (local_aux -> field .)
    RBRACK          reduce using rule 34 (local_aux -> field .)
    DOT             reduce using rule 34 (local_aux -> field .)
    RPAREN          reduce using rule 34 (local_aux -> field .)


state 43

    (35) local_aux -> empty .
    (37) offset -> empty .

  ! reduce/reduce conflict for EQUALS resolved using rule 35 (local_aux -> empty .)
  ! reduce/reduce conflict for TIMES resolved using rule 35 (local_aux -> empty .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 35 (local_aux -> empty .)
  ! reduce/reduce conflict for PLUS resolved using rule 35 (local_aux -> empty .)
  ! reduce/reduce conflict for MINUS resolved using rule 35 (local_aux -> empty .)
  ! reduce/reduce conflict for EQ resolved using rule 35 (local_aux -> empty .)
  ! reduce/reduce conflict for NEQ resolved using rule 35 (local_aux -> empty .)
  ! reduce/reduce conflict for AND resolved using rule 35 (local_aux -> empty .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 35 (local_aux -> empty .)
  ! reduce/reduce conflict for OR resolved using rule 35 (local_aux -> empty .)
  ! reduce/reduce conflict for RBRACK resolved using rule 35 (local_aux -> empty .)
  ! reduce/reduce conflict for DOT resolved using rule 35 (local_aux -> empty .)
  ! reduce/reduce conflict for RPAREN resolved using rule 35 (local_aux -> empty .)
    EQUALS          reduce using rule 35 (local_aux -> empty .)
    TIMES           reduce using rule 35 (local_aux -> empty .)
    DIVIDE          reduce using rule 35 (local_aux -> empty .)
    PLUS            reduce using rule 35 (local_aux -> empty .)
    MINUS           reduce using rule 35 (local_aux -> empty .)
    EQ              reduce using rule 35 (local_aux -> empty .)
    NEQ             reduce using rule 35 (local_aux -> empty .)
    AND             reduce using rule 35 (local_aux -> empty .)
    SEMICOLON       reduce using rule 35 (local_aux -> empty .)
    OR              reduce using rule 35 (local_aux -> empty .)
    RBRACK          reduce using rule 35 (local_aux -> empty .)
    DOT             reduce using rule 35 (local_aux -> empty .)
    RPAREN          reduce using rule 35 (local_aux -> empty .)

  ! EQUALS          [ reduce using rule 37 (offset -> empty .) ]
  ! TIMES           [ reduce using rule 37 (offset -> empty .) ]
  ! DIVIDE          [ reduce using rule 37 (offset -> empty .) ]
  ! PLUS            [ reduce using rule 37 (offset -> empty .) ]
  ! MINUS           [ reduce using rule 37 (offset -> empty .) ]
  ! EQ              [ reduce using rule 37 (offset -> empty .) ]
  ! NEQ             [ reduce using rule 37 (offset -> empty .) ]
  ! AND             [ reduce using rule 37 (offset -> empty .) ]
  ! SEMICOLON       [ reduce using rule 37 (offset -> empty .) ]
  ! OR              [ reduce using rule 37 (offset -> empty .) ]
  ! RBRACK          [ reduce using rule 37 (offset -> empty .) ]
  ! DOT             [ reduce using rule 37 (offset -> empty .) ]
  ! RPAREN          [ reduce using rule 37 (offset -> empty .) ]


state 44

    (36) offset -> LBRACK . boolean RBRACK offset
    (40) boolean -> . join
    (41) boolean -> . boolean OR join
    (42) join -> . equality
    (43) join -> . join AND equality
    (44) equality -> . relational
    (45) equality -> . equality EQ relational
    (46) equality -> . equality NEQ relational
    (47) relational -> . expression
    (48) relational -> . relational_operator expression
    (53) expression -> . term expression_aux
    (49) relational_operator -> . LT
    (50) relational_operator -> . LE
    (51) relational_operator -> . GT
    (52) relational_operator -> . GE
    (58) term -> . unary
    (59) term -> . term TIMES unary
    (60) term -> . term DIVIDE unary
    (61) unary -> . NOT unary
    (62) unary -> . NEG unary
    (63) unary -> . factor
    (64) factor -> . LPAREN boolean RPAREN
    (65) factor -> . local
    (66) factor -> . NUMBER_INT
    (67) factor -> . NUMBER_FLOAT
    (68) factor -> . FALSE
    (69) factor -> . TRUE
    (31) local -> . HASH ID local_aux
    (32) local -> . ID local_aux

    LT              shift and go to state 62
    LE              shift and go to state 63
    GT              shift and go to state 64
    GE              shift and go to state 65
    NOT             shift and go to state 67
    NEG             shift and go to state 68
    LPAREN          shift and go to state 70
    NUMBER_INT      shift and go to state 71
    NUMBER_FLOAT    shift and go to state 72
    FALSE           shift and go to state 73
    TRUE            shift and go to state 74
    HASH            shift and go to state 23
    ID              shift and go to state 24

    boolean                        shift and go to state 76
    join                           shift and go to state 56
    equality                       shift and go to state 57
    relational                     shift and go to state 58
    expression                     shift and go to state 59
    relational_operator            shift and go to state 60
    term                           shift and go to state 61
    unary                          shift and go to state 66
    factor                         shift and go to state 69
    local                          shift and go to state 54

state 45

    (38) field -> DOT . factor field
    (39) field -> DOT . factor
    (64) factor -> . LPAREN boolean RPAREN
    (65) factor -> . local
    (66) factor -> . NUMBER_INT
    (67) factor -> . NUMBER_FLOAT
    (68) factor -> . FALSE
    (69) factor -> . TRUE
    (31) local -> . HASH ID local_aux
    (32) local -> . ID local_aux

    LPAREN          shift and go to state 70
    NUMBER_INT      shift and go to state 71
    NUMBER_FLOAT    shift and go to state 72
    FALSE           shift and go to state 73
    TRUE            shift and go to state 74
    HASH            shift and go to state 23
    ID              shift and go to state 24

    factor                         shift and go to state 77
    local                          shift and go to state 54

state 46

    (26) conditional -> IF LPAREN . boolean RPAREN statement conditional_aux
    (40) boolean -> . join
    (41) boolean -> . boolean OR join
    (42) join -> . equality
    (43) join -> . join AND equality
    (44) equality -> . relational
    (45) equality -> . equality EQ relational
    (46) equality -> . equality NEQ relational
    (47) relational -> . expression
    (48) relational -> . relational_operator expression
    (53) expression -> . term expression_aux
    (49) relational_operator -> . LT
    (50) relational_operator -> . LE
    (51) relational_operator -> . GT
    (52) relational_operator -> . GE
    (58) term -> . unary
    (59) term -> . term TIMES unary
    (60) term -> . term DIVIDE unary
    (61) unary -> . NOT unary
    (62) unary -> . NEG unary
    (63) unary -> . factor
    (64) factor -> . LPAREN boolean RPAREN
    (65) factor -> . local
    (66) factor -> . NUMBER_INT
    (67) factor -> . NUMBER_FLOAT
    (68) factor -> . FALSE
    (69) factor -> . TRUE
    (31) local -> . HASH ID local_aux
    (32) local -> . ID local_aux

    LT              shift and go to state 62
    LE              shift and go to state 63
    GT              shift and go to state 64
    GE              shift and go to state 65
    NOT             shift and go to state 67
    NEG             shift and go to state 68
    LPAREN          shift and go to state 70
    NUMBER_INT      shift and go to state 71
    NUMBER_FLOAT    shift and go to state 72
    FALSE           shift and go to state 73
    TRUE            shift and go to state 74
    HASH            shift and go to state 23
    ID              shift and go to state 24

    boolean                        shift and go to state 78
    join                           shift and go to state 56
    equality                       shift and go to state 57
    relational                     shift and go to state 58
    expression                     shift and go to state 59
    relational_operator            shift and go to state 60
    term                           shift and go to state 61
    unary                          shift and go to state 66
    factor                         shift and go to state 69
    local                          shift and go to state 54

state 47

    (29) while_loop -> WHILE LPAREN . boolean RPAREN statement
    (40) boolean -> . join
    (41) boolean -> . boolean OR join
    (42) join -> . equality
    (43) join -> . join AND equality
    (44) equality -> . relational
    (45) equality -> . equality EQ relational
    (46) equality -> . equality NEQ relational
    (47) relational -> . expression
    (48) relational -> . relational_operator expression
    (53) expression -> . term expression_aux
    (49) relational_operator -> . LT
    (50) relational_operator -> . LE
    (51) relational_operator -> . GT
    (52) relational_operator -> . GE
    (58) term -> . unary
    (59) term -> . term TIMES unary
    (60) term -> . term DIVIDE unary
    (61) unary -> . NOT unary
    (62) unary -> . NEG unary
    (63) unary -> . factor
    (64) factor -> . LPAREN boolean RPAREN
    (65) factor -> . local
    (66) factor -> . NUMBER_INT
    (67) factor -> . NUMBER_FLOAT
    (68) factor -> . FALSE
    (69) factor -> . TRUE
    (31) local -> . HASH ID local_aux
    (32) local -> . ID local_aux

    LT              shift and go to state 62
    LE              shift and go to state 63
    GT              shift and go to state 64
    GE              shift and go to state 65
    NOT             shift and go to state 67
    NEG             shift and go to state 68
    LPAREN          shift and go to state 70
    NUMBER_INT      shift and go to state 71
    NUMBER_FLOAT    shift and go to state 72
    FALSE           shift and go to state 73
    TRUE            shift and go to state 74
    HASH            shift and go to state 23
    ID              shift and go to state 24

    boolean                        shift and go to state 79
    join                           shift and go to state 56
    equality                       shift and go to state 57
    relational                     shift and go to state 58
    expression                     shift and go to state 59
    relational_operator            shift and go to state 60
    term                           shift and go to state 61
    unary                          shift and go to state 66
    factor                         shift and go to state 69
    local                          shift and go to state 54

state 48

    (30) do_while_loop -> DO statement . WHILE LPAREN boolean RPAREN SEMICOLON

    WHILE           shift and go to state 80


state 49

    (24) print -> PRINT LPAREN . boolean RPAREN SEMICOLON
    (40) boolean -> . join
    (41) boolean -> . boolean OR join
    (42) join -> . equality
    (43) join -> . join AND equality
    (44) equality -> . relational
    (45) equality -> . equality EQ relational
    (46) equality -> . equality NEQ relational
    (47) relational -> . expression
    (48) relational -> . relational_operator expression
    (53) expression -> . term expression_aux
    (49) relational_operator -> . LT
    (50) relational_operator -> . LE
    (51) relational_operator -> . GT
    (52) relational_operator -> . GE
    (58) term -> . unary
    (59) term -> . term TIMES unary
    (60) term -> . term DIVIDE unary
    (61) unary -> . NOT unary
    (62) unary -> . NEG unary
    (63) unary -> . factor
    (64) factor -> . LPAREN boolean RPAREN
    (65) factor -> . local
    (66) factor -> . NUMBER_INT
    (67) factor -> . NUMBER_FLOAT
    (68) factor -> . FALSE
    (69) factor -> . TRUE
    (31) local -> . HASH ID local_aux
    (32) local -> . ID local_aux

    LT              shift and go to state 62
    LE              shift and go to state 63
    GT              shift and go to state 64
    GE              shift and go to state 65
    NOT             shift and go to state 67
    NEG             shift and go to state 68
    LPAREN          shift and go to state 70
    NUMBER_INT      shift and go to state 71
    NUMBER_FLOAT    shift and go to state 72
    FALSE           shift and go to state 73
    TRUE            shift and go to state 74
    HASH            shift and go to state 23
    ID              shift and go to state 24

    boolean                        shift and go to state 81
    join                           shift and go to state 56
    equality                       shift and go to state 57
    relational                     shift and go to state 58
    expression                     shift and go to state 59
    relational_operator            shift and go to state 60
    term                           shift and go to state 61
    unary                          shift and go to state 66
    factor                         shift and go to state 69
    local                          shift and go to state 54

state 50

    (25) read -> READ LPAREN . local RPAREN SEMICOLON
    (31) local -> . HASH ID local_aux
    (32) local -> . ID local_aux

    HASH            shift and go to state 23
    ID              shift and go to state 24

    local                          shift and go to state 82

state 51

    (3) declaration -> type ID SEMICOLON . declaration
    (3) declaration -> . type ID SEMICOLON declaration
    (4) declaration -> . empty
    (5) type -> . basic dimensions
    (6) type -> . basic HASH
    (7) type -> . basic
    (8) type -> . RECORD LBRACE declaration RBRACE
    (70) empty -> .
    (11) basic -> . INT
    (12) basic -> . CHAR
    (13) basic -> . BOOL

    RECORD          shift and go to state 8
    BREAK           reduce using rule 70 (empty -> .)
    HASH            reduce using rule 70 (empty -> .)
    ID              reduce using rule 70 (empty -> .)
    IF              reduce using rule 70 (empty -> .)
    WHILE           reduce using rule 70 (empty -> .)
    DO              reduce using rule 70 (empty -> .)
    PRINT           reduce using rule 70 (empty -> .)
    READ            reduce using rule 70 (empty -> .)
    LBRACE          reduce using rule 70 (empty -> .)
    RBRACE          reduce using rule 70 (empty -> .)
    INT             shift and go to state 9
    CHAR            shift and go to state 10
    BOOL            shift and go to state 11

    type                           shift and go to state 5
    declaration                    shift and go to state 83
    empty                          shift and go to state 6
    basic                          shift and go to state 7

state 52

    (9) dimensions -> LBRACK NUMBER_INT . RBRACK dimensions
    (10) dimensions -> LBRACK NUMBER_INT . RBRACK

    RBRACK          shift and go to state 84


state 53

    (8) type -> RECORD LBRACE declaration . RBRACE

    RBRACE          shift and go to state 85


state 54

    (65) factor -> local .

    TIMES           reduce using rule 65 (factor -> local .)
    DIVIDE          reduce using rule 65 (factor -> local .)
    PLUS            reduce using rule 65 (factor -> local .)
    MINUS           reduce using rule 65 (factor -> local .)
    EQ              reduce using rule 65 (factor -> local .)
    NEQ             reduce using rule 65 (factor -> local .)
    AND             reduce using rule 65 (factor -> local .)
    SEMICOLON       reduce using rule 65 (factor -> local .)
    OR              reduce using rule 65 (factor -> local .)
    RBRACK          reduce using rule 65 (factor -> local .)
    EQUALS          reduce using rule 65 (factor -> local .)
    DOT             reduce using rule 65 (factor -> local .)
    RPAREN          reduce using rule 65 (factor -> local .)


state 55

    (16) statement -> local EQUALS boolean . SEMICOLON
    (41) boolean -> boolean . OR join

    SEMICOLON       shift and go to state 86
    OR              shift and go to state 87


state 56

    (40) boolean -> join .
    (43) join -> join . AND equality

    SEMICOLON       reduce using rule 40 (boolean -> join .)
    OR              reduce using rule 40 (boolean -> join .)
    RBRACK          reduce using rule 40 (boolean -> join .)
    RPAREN          reduce using rule 40 (boolean -> join .)
    AND             shift and go to state 88


state 57

    (42) join -> equality .
    (45) equality -> equality . EQ relational
    (46) equality -> equality . NEQ relational

    AND             reduce using rule 42 (join -> equality .)
    SEMICOLON       reduce using rule 42 (join -> equality .)
    OR              reduce using rule 42 (join -> equality .)
    RBRACK          reduce using rule 42 (join -> equality .)
    RPAREN          reduce using rule 42 (join -> equality .)
    EQ              shift and go to state 89
    NEQ             shift and go to state 90


state 58

    (44) equality -> relational .

    EQ              reduce using rule 44 (equality -> relational .)
    NEQ             reduce using rule 44 (equality -> relational .)
    AND             reduce using rule 44 (equality -> relational .)
    SEMICOLON       reduce using rule 44 (equality -> relational .)
    OR              reduce using rule 44 (equality -> relational .)
    RBRACK          reduce using rule 44 (equality -> relational .)
    RPAREN          reduce using rule 44 (equality -> relational .)


state 59

    (47) relational -> expression .

    EQ              reduce using rule 47 (relational -> expression .)
    NEQ             reduce using rule 47 (relational -> expression .)
    AND             reduce using rule 47 (relational -> expression .)
    SEMICOLON       reduce using rule 47 (relational -> expression .)
    OR              reduce using rule 47 (relational -> expression .)
    RBRACK          reduce using rule 47 (relational -> expression .)
    RPAREN          reduce using rule 47 (relational -> expression .)


state 60

    (48) relational -> relational_operator . expression
    (53) expression -> . term expression_aux
    (58) term -> . unary
    (59) term -> . term TIMES unary
    (60) term -> . term DIVIDE unary
    (61) unary -> . NOT unary
    (62) unary -> . NEG unary
    (63) unary -> . factor
    (64) factor -> . LPAREN boolean RPAREN
    (65) factor -> . local
    (66) factor -> . NUMBER_INT
    (67) factor -> . NUMBER_FLOAT
    (68) factor -> . FALSE
    (69) factor -> . TRUE
    (31) local -> . HASH ID local_aux
    (32) local -> . ID local_aux

    NOT             shift and go to state 67
    NEG             shift and go to state 68
    LPAREN          shift and go to state 70
    NUMBER_INT      shift and go to state 71
    NUMBER_FLOAT    shift and go to state 72
    FALSE           shift and go to state 73
    TRUE            shift and go to state 74
    HASH            shift and go to state 23
    ID              shift and go to state 24

    expression                     shift and go to state 91
    term                           shift and go to state 61
    unary                          shift and go to state 66
    factor                         shift and go to state 69
    local                          shift and go to state 54

state 61

    (53) expression -> term . expression_aux
    (59) term -> term . TIMES unary
    (60) term -> term . DIVIDE unary
    (54) expression_aux -> . expression_operator term expression_aux
    (55) expression_aux -> . empty
    (56) expression_operator -> . PLUS
    (57) expression_operator -> . MINUS
    (70) empty -> .

    TIMES           shift and go to state 93
    DIVIDE          shift and go to state 94
    PLUS            shift and go to state 97
    MINUS           shift and go to state 98
    EQ              reduce using rule 70 (empty -> .)
    NEQ             reduce using rule 70 (empty -> .)
    AND             reduce using rule 70 (empty -> .)
    SEMICOLON       reduce using rule 70 (empty -> .)
    OR              reduce using rule 70 (empty -> .)
    RBRACK          reduce using rule 70 (empty -> .)
    RPAREN          reduce using rule 70 (empty -> .)

    expression_aux                 shift and go to state 92
    expression_operator            shift and go to state 95
    empty                          shift and go to state 96

state 62

    (49) relational_operator -> LT .

    NOT             reduce using rule 49 (relational_operator -> LT .)
    NEG             reduce using rule 49 (relational_operator -> LT .)
    LPAREN          reduce using rule 49 (relational_operator -> LT .)
    NUMBER_INT      reduce using rule 49 (relational_operator -> LT .)
    NUMBER_FLOAT    reduce using rule 49 (relational_operator -> LT .)
    FALSE           reduce using rule 49 (relational_operator -> LT .)
    TRUE            reduce using rule 49 (relational_operator -> LT .)
    HASH            reduce using rule 49 (relational_operator -> LT .)
    ID              reduce using rule 49 (relational_operator -> LT .)


state 63

    (50) relational_operator -> LE .

    NOT             reduce using rule 50 (relational_operator -> LE .)
    NEG             reduce using rule 50 (relational_operator -> LE .)
    LPAREN          reduce using rule 50 (relational_operator -> LE .)
    NUMBER_INT      reduce using rule 50 (relational_operator -> LE .)
    NUMBER_FLOAT    reduce using rule 50 (relational_operator -> LE .)
    FALSE           reduce using rule 50 (relational_operator -> LE .)
    TRUE            reduce using rule 50 (relational_operator -> LE .)
    HASH            reduce using rule 50 (relational_operator -> LE .)
    ID              reduce using rule 50 (relational_operator -> LE .)


state 64

    (51) relational_operator -> GT .

    NOT             reduce using rule 51 (relational_operator -> GT .)
    NEG             reduce using rule 51 (relational_operator -> GT .)
    LPAREN          reduce using rule 51 (relational_operator -> GT .)
    NUMBER_INT      reduce using rule 51 (relational_operator -> GT .)
    NUMBER_FLOAT    reduce using rule 51 (relational_operator -> GT .)
    FALSE           reduce using rule 51 (relational_operator -> GT .)
    TRUE            reduce using rule 51 (relational_operator -> GT .)
    HASH            reduce using rule 51 (relational_operator -> GT .)
    ID              reduce using rule 51 (relational_operator -> GT .)


state 65

    (52) relational_operator -> GE .

    NOT             reduce using rule 52 (relational_operator -> GE .)
    NEG             reduce using rule 52 (relational_operator -> GE .)
    LPAREN          reduce using rule 52 (relational_operator -> GE .)
    NUMBER_INT      reduce using rule 52 (relational_operator -> GE .)
    NUMBER_FLOAT    reduce using rule 52 (relational_operator -> GE .)
    FALSE           reduce using rule 52 (relational_operator -> GE .)
    TRUE            reduce using rule 52 (relational_operator -> GE .)
    HASH            reduce using rule 52 (relational_operator -> GE .)
    ID              reduce using rule 52 (relational_operator -> GE .)


state 66

    (58) term -> unary .

    TIMES           reduce using rule 58 (term -> unary .)
    DIVIDE          reduce using rule 58 (term -> unary .)
    PLUS            reduce using rule 58 (term -> unary .)
    MINUS           reduce using rule 58 (term -> unary .)
    EQ              reduce using rule 58 (term -> unary .)
    NEQ             reduce using rule 58 (term -> unary .)
    AND             reduce using rule 58 (term -> unary .)
    SEMICOLON       reduce using rule 58 (term -> unary .)
    OR              reduce using rule 58 (term -> unary .)
    RBRACK          reduce using rule 58 (term -> unary .)
    RPAREN          reduce using rule 58 (term -> unary .)


state 67

    (61) unary -> NOT . unary
    (61) unary -> . NOT unary
    (62) unary -> . NEG unary
    (63) unary -> . factor
    (64) factor -> . LPAREN boolean RPAREN
    (65) factor -> . local
    (66) factor -> . NUMBER_INT
    (67) factor -> . NUMBER_FLOAT
    (68) factor -> . FALSE
    (69) factor -> . TRUE
    (31) local -> . HASH ID local_aux
    (32) local -> . ID local_aux

    NOT             shift and go to state 67
    NEG             shift and go to state 68
    LPAREN          shift and go to state 70
    NUMBER_INT      shift and go to state 71
    NUMBER_FLOAT    shift and go to state 72
    FALSE           shift and go to state 73
    TRUE            shift and go to state 74
    HASH            shift and go to state 23
    ID              shift and go to state 24

    unary                          shift and go to state 99
    factor                         shift and go to state 69
    local                          shift and go to state 54

state 68

    (62) unary -> NEG . unary
    (61) unary -> . NOT unary
    (62) unary -> . NEG unary
    (63) unary -> . factor
    (64) factor -> . LPAREN boolean RPAREN
    (65) factor -> . local
    (66) factor -> . NUMBER_INT
    (67) factor -> . NUMBER_FLOAT
    (68) factor -> . FALSE
    (69) factor -> . TRUE
    (31) local -> . HASH ID local_aux
    (32) local -> . ID local_aux

    NOT             shift and go to state 67
    NEG             shift and go to state 68
    LPAREN          shift and go to state 70
    NUMBER_INT      shift and go to state 71
    NUMBER_FLOAT    shift and go to state 72
    FALSE           shift and go to state 73
    TRUE            shift and go to state 74
    HASH            shift and go to state 23
    ID              shift and go to state 24

    unary                          shift and go to state 100
    factor                         shift and go to state 69
    local                          shift and go to state 54

state 69

    (63) unary -> factor .

    TIMES           reduce using rule 63 (unary -> factor .)
    DIVIDE          reduce using rule 63 (unary -> factor .)
    PLUS            reduce using rule 63 (unary -> factor .)
    MINUS           reduce using rule 63 (unary -> factor .)
    EQ              reduce using rule 63 (unary -> factor .)
    NEQ             reduce using rule 63 (unary -> factor .)
    AND             reduce using rule 63 (unary -> factor .)
    SEMICOLON       reduce using rule 63 (unary -> factor .)
    OR              reduce using rule 63 (unary -> factor .)
    RBRACK          reduce using rule 63 (unary -> factor .)
    RPAREN          reduce using rule 63 (unary -> factor .)


state 70

    (64) factor -> LPAREN . boolean RPAREN
    (40) boolean -> . join
    (41) boolean -> . boolean OR join
    (42) join -> . equality
    (43) join -> . join AND equality
    (44) equality -> . relational
    (45) equality -> . equality EQ relational
    (46) equality -> . equality NEQ relational
    (47) relational -> . expression
    (48) relational -> . relational_operator expression
    (53) expression -> . term expression_aux
    (49) relational_operator -> . LT
    (50) relational_operator -> . LE
    (51) relational_operator -> . GT
    (52) relational_operator -> . GE
    (58) term -> . unary
    (59) term -> . term TIMES unary
    (60) term -> . term DIVIDE unary
    (61) unary -> . NOT unary
    (62) unary -> . NEG unary
    (63) unary -> . factor
    (64) factor -> . LPAREN boolean RPAREN
    (65) factor -> . local
    (66) factor -> . NUMBER_INT
    (67) factor -> . NUMBER_FLOAT
    (68) factor -> . FALSE
    (69) factor -> . TRUE
    (31) local -> . HASH ID local_aux
    (32) local -> . ID local_aux

    LT              shift and go to state 62
    LE              shift and go to state 63
    GT              shift and go to state 64
    GE              shift and go to state 65
    NOT             shift and go to state 67
    NEG             shift and go to state 68
    LPAREN          shift and go to state 70
    NUMBER_INT      shift and go to state 71
    NUMBER_FLOAT    shift and go to state 72
    FALSE           shift and go to state 73
    TRUE            shift and go to state 74
    HASH            shift and go to state 23
    ID              shift and go to state 24

    boolean                        shift and go to state 101
    join                           shift and go to state 56
    equality                       shift and go to state 57
    relational                     shift and go to state 58
    expression                     shift and go to state 59
    relational_operator            shift and go to state 60
    term                           shift and go to state 61
    unary                          shift and go to state 66
    factor                         shift and go to state 69
    local                          shift and go to state 54

state 71

    (66) factor -> NUMBER_INT .

    TIMES           reduce using rule 66 (factor -> NUMBER_INT .)
    DIVIDE          reduce using rule 66 (factor -> NUMBER_INT .)
    PLUS            reduce using rule 66 (factor -> NUMBER_INT .)
    MINUS           reduce using rule 66 (factor -> NUMBER_INT .)
    EQ              reduce using rule 66 (factor -> NUMBER_INT .)
    NEQ             reduce using rule 66 (factor -> NUMBER_INT .)
    AND             reduce using rule 66 (factor -> NUMBER_INT .)
    SEMICOLON       reduce using rule 66 (factor -> NUMBER_INT .)
    OR              reduce using rule 66 (factor -> NUMBER_INT .)
    RBRACK          reduce using rule 66 (factor -> NUMBER_INT .)
    EQUALS          reduce using rule 66 (factor -> NUMBER_INT .)
    DOT             reduce using rule 66 (factor -> NUMBER_INT .)
    RPAREN          reduce using rule 66 (factor -> NUMBER_INT .)


state 72

    (67) factor -> NUMBER_FLOAT .

    TIMES           reduce using rule 67 (factor -> NUMBER_FLOAT .)
    DIVIDE          reduce using rule 67 (factor -> NUMBER_FLOAT .)
    PLUS            reduce using rule 67 (factor -> NUMBER_FLOAT .)
    MINUS           reduce using rule 67 (factor -> NUMBER_FLOAT .)
    EQ              reduce using rule 67 (factor -> NUMBER_FLOAT .)
    NEQ             reduce using rule 67 (factor -> NUMBER_FLOAT .)
    AND             reduce using rule 67 (factor -> NUMBER_FLOAT .)
    SEMICOLON       reduce using rule 67 (factor -> NUMBER_FLOAT .)
    OR              reduce using rule 67 (factor -> NUMBER_FLOAT .)
    RBRACK          reduce using rule 67 (factor -> NUMBER_FLOAT .)
    EQUALS          reduce using rule 67 (factor -> NUMBER_FLOAT .)
    DOT             reduce using rule 67 (factor -> NUMBER_FLOAT .)
    RPAREN          reduce using rule 67 (factor -> NUMBER_FLOAT .)


state 73

    (68) factor -> FALSE .

    TIMES           reduce using rule 68 (factor -> FALSE .)
    DIVIDE          reduce using rule 68 (factor -> FALSE .)
    PLUS            reduce using rule 68 (factor -> FALSE .)
    MINUS           reduce using rule 68 (factor -> FALSE .)
    EQ              reduce using rule 68 (factor -> FALSE .)
    NEQ             reduce using rule 68 (factor -> FALSE .)
    AND             reduce using rule 68 (factor -> FALSE .)
    SEMICOLON       reduce using rule 68 (factor -> FALSE .)
    OR              reduce using rule 68 (factor -> FALSE .)
    RBRACK          reduce using rule 68 (factor -> FALSE .)
    EQUALS          reduce using rule 68 (factor -> FALSE .)
    DOT             reduce using rule 68 (factor -> FALSE .)
    RPAREN          reduce using rule 68 (factor -> FALSE .)


state 74

    (69) factor -> TRUE .

    TIMES           reduce using rule 69 (factor -> TRUE .)
    DIVIDE          reduce using rule 69 (factor -> TRUE .)
    PLUS            reduce using rule 69 (factor -> TRUE .)
    MINUS           reduce using rule 69 (factor -> TRUE .)
    EQ              reduce using rule 69 (factor -> TRUE .)
    NEQ             reduce using rule 69 (factor -> TRUE .)
    AND             reduce using rule 69 (factor -> TRUE .)
    SEMICOLON       reduce using rule 69 (factor -> TRUE .)
    OR              reduce using rule 69 (factor -> TRUE .)
    RBRACK          reduce using rule 69 (factor -> TRUE .)
    EQUALS          reduce using rule 69 (factor -> TRUE .)
    DOT             reduce using rule 69 (factor -> TRUE .)
    RPAREN          reduce using rule 69 (factor -> TRUE .)


state 75

    (31) local -> HASH ID local_aux .

    EQUALS          reduce using rule 31 (local -> HASH ID local_aux .)
    TIMES           reduce using rule 31 (local -> HASH ID local_aux .)
    DIVIDE          reduce using rule 31 (local -> HASH ID local_aux .)
    PLUS            reduce using rule 31 (local -> HASH ID local_aux .)
    MINUS           reduce using rule 31 (local -> HASH ID local_aux .)
    EQ              reduce using rule 31 (local -> HASH ID local_aux .)
    NEQ             reduce using rule 31 (local -> HASH ID local_aux .)
    AND             reduce using rule 31 (local -> HASH ID local_aux .)
    SEMICOLON       reduce using rule 31 (local -> HASH ID local_aux .)
    OR              reduce using rule 31 (local -> HASH ID local_aux .)
    RBRACK          reduce using rule 31 (local -> HASH ID local_aux .)
    DOT             reduce using rule 31 (local -> HASH ID local_aux .)
    RPAREN          reduce using rule 31 (local -> HASH ID local_aux .)


state 76

    (36) offset -> LBRACK boolean . RBRACK offset
    (41) boolean -> boolean . OR join

    RBRACK          shift and go to state 102
    OR              shift and go to state 87


state 77

    (38) field -> DOT factor . field
    (39) field -> DOT factor .
    (38) field -> . DOT factor field
    (39) field -> . DOT factor

  ! shift/reduce conflict for DOT resolved as shift
    EQUALS          reduce using rule 39 (field -> DOT factor .)
    TIMES           reduce using rule 39 (field -> DOT factor .)
    DIVIDE          reduce using rule 39 (field -> DOT factor .)
    PLUS            reduce using rule 39 (field -> DOT factor .)
    MINUS           reduce using rule 39 (field -> DOT factor .)
    EQ              reduce using rule 39 (field -> DOT factor .)
    NEQ             reduce using rule 39 (field -> DOT factor .)
    AND             reduce using rule 39 (field -> DOT factor .)
    SEMICOLON       reduce using rule 39 (field -> DOT factor .)
    OR              reduce using rule 39 (field -> DOT factor .)
    RBRACK          reduce using rule 39 (field -> DOT factor .)
    RPAREN          reduce using rule 39 (field -> DOT factor .)
    DOT             shift and go to state 45

  ! DOT             [ reduce using rule 39 (field -> DOT factor .) ]

    field                          shift and go to state 103

state 78

    (26) conditional -> IF LPAREN boolean . RPAREN statement conditional_aux
    (41) boolean -> boolean . OR join

    RPAREN          shift and go to state 104
    OR              shift and go to state 87


state 79

    (29) while_loop -> WHILE LPAREN boolean . RPAREN statement
    (41) boolean -> boolean . OR join

    RPAREN          shift and go to state 105
    OR              shift and go to state 87


state 80

    (30) do_while_loop -> DO statement WHILE . LPAREN boolean RPAREN SEMICOLON

    LPAREN          shift and go to state 106


state 81

    (24) print -> PRINT LPAREN boolean . RPAREN SEMICOLON
    (41) boolean -> boolean . OR join

    RPAREN          shift and go to state 107
    OR              shift and go to state 87


state 82

    (25) read -> READ LPAREN local . RPAREN SEMICOLON

    RPAREN          shift and go to state 108


state 83

    (3) declaration -> type ID SEMICOLON declaration .

    BREAK           reduce using rule 3 (declaration -> type ID SEMICOLON declaration .)
    HASH            reduce using rule 3 (declaration -> type ID SEMICOLON declaration .)
    ID              reduce using rule 3 (declaration -> type ID SEMICOLON declaration .)
    IF              reduce using rule 3 (declaration -> type ID SEMICOLON declaration .)
    WHILE           reduce using rule 3 (declaration -> type ID SEMICOLON declaration .)
    DO              reduce using rule 3 (declaration -> type ID SEMICOLON declaration .)
    PRINT           reduce using rule 3 (declaration -> type ID SEMICOLON declaration .)
    READ            reduce using rule 3 (declaration -> type ID SEMICOLON declaration .)
    LBRACE          reduce using rule 3 (declaration -> type ID SEMICOLON declaration .)
    RBRACE          reduce using rule 3 (declaration -> type ID SEMICOLON declaration .)


state 84

    (9) dimensions -> LBRACK NUMBER_INT RBRACK . dimensions
    (10) dimensions -> LBRACK NUMBER_INT RBRACK .
    (9) dimensions -> . LBRACK NUMBER_INT RBRACK dimensions
    (10) dimensions -> . LBRACK NUMBER_INT RBRACK

    ID              reduce using rule 10 (dimensions -> LBRACK NUMBER_INT RBRACK .)
    LBRACK          shift and go to state 33

    dimensions                     shift and go to state 109

state 85

    (8) type -> RECORD LBRACE declaration RBRACE .

    ID              reduce using rule 8 (type -> RECORD LBRACE declaration RBRACE .)


state 86

    (16) statement -> local EQUALS boolean SEMICOLON .

    BREAK           reduce using rule 16 (statement -> local EQUALS boolean SEMICOLON .)
    HASH            reduce using rule 16 (statement -> local EQUALS boolean SEMICOLON .)
    ID              reduce using rule 16 (statement -> local EQUALS boolean SEMICOLON .)
    IF              reduce using rule 16 (statement -> local EQUALS boolean SEMICOLON .)
    WHILE           reduce using rule 16 (statement -> local EQUALS boolean SEMICOLON .)
    DO              reduce using rule 16 (statement -> local EQUALS boolean SEMICOLON .)
    PRINT           reduce using rule 16 (statement -> local EQUALS boolean SEMICOLON .)
    READ            reduce using rule 16 (statement -> local EQUALS boolean SEMICOLON .)
    LBRACE          reduce using rule 16 (statement -> local EQUALS boolean SEMICOLON .)
    RBRACE          reduce using rule 16 (statement -> local EQUALS boolean SEMICOLON .)
    ELSE            reduce using rule 16 (statement -> local EQUALS boolean SEMICOLON .)


state 87

    (41) boolean -> boolean OR . join
    (42) join -> . equality
    (43) join -> . join AND equality
    (44) equality -> . relational
    (45) equality -> . equality EQ relational
    (46) equality -> . equality NEQ relational
    (47) relational -> . expression
    (48) relational -> . relational_operator expression
    (53) expression -> . term expression_aux
    (49) relational_operator -> . LT
    (50) relational_operator -> . LE
    (51) relational_operator -> . GT
    (52) relational_operator -> . GE
    (58) term -> . unary
    (59) term -> . term TIMES unary
    (60) term -> . term DIVIDE unary
    (61) unary -> . NOT unary
    (62) unary -> . NEG unary
    (63) unary -> . factor
    (64) factor -> . LPAREN boolean RPAREN
    (65) factor -> . local
    (66) factor -> . NUMBER_INT
    (67) factor -> . NUMBER_FLOAT
    (68) factor -> . FALSE
    (69) factor -> . TRUE
    (31) local -> . HASH ID local_aux
    (32) local -> . ID local_aux

    LT              shift and go to state 62
    LE              shift and go to state 63
    GT              shift and go to state 64
    GE              shift and go to state 65
    NOT             shift and go to state 67
    NEG             shift and go to state 68
    LPAREN          shift and go to state 70
    NUMBER_INT      shift and go to state 71
    NUMBER_FLOAT    shift and go to state 72
    FALSE           shift and go to state 73
    TRUE            shift and go to state 74
    HASH            shift and go to state 23
    ID              shift and go to state 24

    join                           shift and go to state 110
    equality                       shift and go to state 57
    relational                     shift and go to state 58
    expression                     shift and go to state 59
    relational_operator            shift and go to state 60
    term                           shift and go to state 61
    unary                          shift and go to state 66
    factor                         shift and go to state 69
    local                          shift and go to state 54

state 88

    (43) join -> join AND . equality
    (44) equality -> . relational
    (45) equality -> . equality EQ relational
    (46) equality -> . equality NEQ relational
    (47) relational -> . expression
    (48) relational -> . relational_operator expression
    (53) expression -> . term expression_aux
    (49) relational_operator -> . LT
    (50) relational_operator -> . LE
    (51) relational_operator -> . GT
    (52) relational_operator -> . GE
    (58) term -> . unary
    (59) term -> . term TIMES unary
    (60) term -> . term DIVIDE unary
    (61) unary -> . NOT unary
    (62) unary -> . NEG unary
    (63) unary -> . factor
    (64) factor -> . LPAREN boolean RPAREN
    (65) factor -> . local
    (66) factor -> . NUMBER_INT
    (67) factor -> . NUMBER_FLOAT
    (68) factor -> . FALSE
    (69) factor -> . TRUE
    (31) local -> . HASH ID local_aux
    (32) local -> . ID local_aux

    LT              shift and go to state 62
    LE              shift and go to state 63
    GT              shift and go to state 64
    GE              shift and go to state 65
    NOT             shift and go to state 67
    NEG             shift and go to state 68
    LPAREN          shift and go to state 70
    NUMBER_INT      shift and go to state 71
    NUMBER_FLOAT    shift and go to state 72
    FALSE           shift and go to state 73
    TRUE            shift and go to state 74
    HASH            shift and go to state 23
    ID              shift and go to state 24

    equality                       shift and go to state 111
    relational                     shift and go to state 58
    expression                     shift and go to state 59
    relational_operator            shift and go to state 60
    term                           shift and go to state 61
    unary                          shift and go to state 66
    factor                         shift and go to state 69
    local                          shift and go to state 54

state 89

    (45) equality -> equality EQ . relational
    (47) relational -> . expression
    (48) relational -> . relational_operator expression
    (53) expression -> . term expression_aux
    (49) relational_operator -> . LT
    (50) relational_operator -> . LE
    (51) relational_operator -> . GT
    (52) relational_operator -> . GE
    (58) term -> . unary
    (59) term -> . term TIMES unary
    (60) term -> . term DIVIDE unary
    (61) unary -> . NOT unary
    (62) unary -> . NEG unary
    (63) unary -> . factor
    (64) factor -> . LPAREN boolean RPAREN
    (65) factor -> . local
    (66) factor -> . NUMBER_INT
    (67) factor -> . NUMBER_FLOAT
    (68) factor -> . FALSE
    (69) factor -> . TRUE
    (31) local -> . HASH ID local_aux
    (32) local -> . ID local_aux

    LT              shift and go to state 62
    LE              shift and go to state 63
    GT              shift and go to state 64
    GE              shift and go to state 65
    NOT             shift and go to state 67
    NEG             shift and go to state 68
    LPAREN          shift and go to state 70
    NUMBER_INT      shift and go to state 71
    NUMBER_FLOAT    shift and go to state 72
    FALSE           shift and go to state 73
    TRUE            shift and go to state 74
    HASH            shift and go to state 23
    ID              shift and go to state 24

    relational                     shift and go to state 112
    expression                     shift and go to state 59
    relational_operator            shift and go to state 60
    term                           shift and go to state 61
    unary                          shift and go to state 66
    factor                         shift and go to state 69
    local                          shift and go to state 54

state 90

    (46) equality -> equality NEQ . relational
    (47) relational -> . expression
    (48) relational -> . relational_operator expression
    (53) expression -> . term expression_aux
    (49) relational_operator -> . LT
    (50) relational_operator -> . LE
    (51) relational_operator -> . GT
    (52) relational_operator -> . GE
    (58) term -> . unary
    (59) term -> . term TIMES unary
    (60) term -> . term DIVIDE unary
    (61) unary -> . NOT unary
    (62) unary -> . NEG unary
    (63) unary -> . factor
    (64) factor -> . LPAREN boolean RPAREN
    (65) factor -> . local
    (66) factor -> . NUMBER_INT
    (67) factor -> . NUMBER_FLOAT
    (68) factor -> . FALSE
    (69) factor -> . TRUE
    (31) local -> . HASH ID local_aux
    (32) local -> . ID local_aux

    LT              shift and go to state 62
    LE              shift and go to state 63
    GT              shift and go to state 64
    GE              shift and go to state 65
    NOT             shift and go to state 67
    NEG             shift and go to state 68
    LPAREN          shift and go to state 70
    NUMBER_INT      shift and go to state 71
    NUMBER_FLOAT    shift and go to state 72
    FALSE           shift and go to state 73
    TRUE            shift and go to state 74
    HASH            shift and go to state 23
    ID              shift and go to state 24

    relational                     shift and go to state 113
    expression                     shift and go to state 59
    relational_operator            shift and go to state 60
    term                           shift and go to state 61
    unary                          shift and go to state 66
    factor                         shift and go to state 69
    local                          shift and go to state 54

state 91

    (48) relational -> relational_operator expression .

    EQ              reduce using rule 48 (relational -> relational_operator expression .)
    NEQ             reduce using rule 48 (relational -> relational_operator expression .)
    AND             reduce using rule 48 (relational -> relational_operator expression .)
    SEMICOLON       reduce using rule 48 (relational -> relational_operator expression .)
    OR              reduce using rule 48 (relational -> relational_operator expression .)
    RBRACK          reduce using rule 48 (relational -> relational_operator expression .)
    RPAREN          reduce using rule 48 (relational -> relational_operator expression .)


state 92

    (53) expression -> term expression_aux .

    EQ              reduce using rule 53 (expression -> term expression_aux .)
    NEQ             reduce using rule 53 (expression -> term expression_aux .)
    AND             reduce using rule 53 (expression -> term expression_aux .)
    SEMICOLON       reduce using rule 53 (expression -> term expression_aux .)
    OR              reduce using rule 53 (expression -> term expression_aux .)
    RBRACK          reduce using rule 53 (expression -> term expression_aux .)
    RPAREN          reduce using rule 53 (expression -> term expression_aux .)


state 93

    (59) term -> term TIMES . unary
    (61) unary -> . NOT unary
    (62) unary -> . NEG unary
    (63) unary -> . factor
    (64) factor -> . LPAREN boolean RPAREN
    (65) factor -> . local
    (66) factor -> . NUMBER_INT
    (67) factor -> . NUMBER_FLOAT
    (68) factor -> . FALSE
    (69) factor -> . TRUE
    (31) local -> . HASH ID local_aux
    (32) local -> . ID local_aux

    NOT             shift and go to state 67
    NEG             shift and go to state 68
    LPAREN          shift and go to state 70
    NUMBER_INT      shift and go to state 71
    NUMBER_FLOAT    shift and go to state 72
    FALSE           shift and go to state 73
    TRUE            shift and go to state 74
    HASH            shift and go to state 23
    ID              shift and go to state 24

    unary                          shift and go to state 114
    factor                         shift and go to state 69
    local                          shift and go to state 54

state 94

    (60) term -> term DIVIDE . unary
    (61) unary -> . NOT unary
    (62) unary -> . NEG unary
    (63) unary -> . factor
    (64) factor -> . LPAREN boolean RPAREN
    (65) factor -> . local
    (66) factor -> . NUMBER_INT
    (67) factor -> . NUMBER_FLOAT
    (68) factor -> . FALSE
    (69) factor -> . TRUE
    (31) local -> . HASH ID local_aux
    (32) local -> . ID local_aux

    NOT             shift and go to state 67
    NEG             shift and go to state 68
    LPAREN          shift and go to state 70
    NUMBER_INT      shift and go to state 71
    NUMBER_FLOAT    shift and go to state 72
    FALSE           shift and go to state 73
    TRUE            shift and go to state 74
    HASH            shift and go to state 23
    ID              shift and go to state 24

    unary                          shift and go to state 115
    factor                         shift and go to state 69
    local                          shift and go to state 54

state 95

    (54) expression_aux -> expression_operator . term expression_aux
    (58) term -> . unary
    (59) term -> . term TIMES unary
    (60) term -> . term DIVIDE unary
    (61) unary -> . NOT unary
    (62) unary -> . NEG unary
    (63) unary -> . factor
    (64) factor -> . LPAREN boolean RPAREN
    (65) factor -> . local
    (66) factor -> . NUMBER_INT
    (67) factor -> . NUMBER_FLOAT
    (68) factor -> . FALSE
    (69) factor -> . TRUE
    (31) local -> . HASH ID local_aux
    (32) local -> . ID local_aux

    NOT             shift and go to state 67
    NEG             shift and go to state 68
    LPAREN          shift and go to state 70
    NUMBER_INT      shift and go to state 71
    NUMBER_FLOAT    shift and go to state 72
    FALSE           shift and go to state 73
    TRUE            shift and go to state 74
    HASH            shift and go to state 23
    ID              shift and go to state 24

    term                           shift and go to state 116
    unary                          shift and go to state 66
    factor                         shift and go to state 69
    local                          shift and go to state 54

state 96

    (55) expression_aux -> empty .

    EQ              reduce using rule 55 (expression_aux -> empty .)
    NEQ             reduce using rule 55 (expression_aux -> empty .)
    AND             reduce using rule 55 (expression_aux -> empty .)
    SEMICOLON       reduce using rule 55 (expression_aux -> empty .)
    OR              reduce using rule 55 (expression_aux -> empty .)
    RBRACK          reduce using rule 55 (expression_aux -> empty .)
    RPAREN          reduce using rule 55 (expression_aux -> empty .)


state 97

    (56) expression_operator -> PLUS .

    NOT             reduce using rule 56 (expression_operator -> PLUS .)
    NEG             reduce using rule 56 (expression_operator -> PLUS .)
    LPAREN          reduce using rule 56 (expression_operator -> PLUS .)
    NUMBER_INT      reduce using rule 56 (expression_operator -> PLUS .)
    NUMBER_FLOAT    reduce using rule 56 (expression_operator -> PLUS .)
    FALSE           reduce using rule 56 (expression_operator -> PLUS .)
    TRUE            reduce using rule 56 (expression_operator -> PLUS .)
    HASH            reduce using rule 56 (expression_operator -> PLUS .)
    ID              reduce using rule 56 (expression_operator -> PLUS .)


state 98

    (57) expression_operator -> MINUS .

    NOT             reduce using rule 57 (expression_operator -> MINUS .)
    NEG             reduce using rule 57 (expression_operator -> MINUS .)
    LPAREN          reduce using rule 57 (expression_operator -> MINUS .)
    NUMBER_INT      reduce using rule 57 (expression_operator -> MINUS .)
    NUMBER_FLOAT    reduce using rule 57 (expression_operator -> MINUS .)
    FALSE           reduce using rule 57 (expression_operator -> MINUS .)
    TRUE            reduce using rule 57 (expression_operator -> MINUS .)
    HASH            reduce using rule 57 (expression_operator -> MINUS .)
    ID              reduce using rule 57 (expression_operator -> MINUS .)


state 99

    (61) unary -> NOT unary .

    TIMES           reduce using rule 61 (unary -> NOT unary .)
    DIVIDE          reduce using rule 61 (unary -> NOT unary .)
    PLUS            reduce using rule 61 (unary -> NOT unary .)
    MINUS           reduce using rule 61 (unary -> NOT unary .)
    EQ              reduce using rule 61 (unary -> NOT unary .)
    NEQ             reduce using rule 61 (unary -> NOT unary .)
    AND             reduce using rule 61 (unary -> NOT unary .)
    SEMICOLON       reduce using rule 61 (unary -> NOT unary .)
    OR              reduce using rule 61 (unary -> NOT unary .)
    RBRACK          reduce using rule 61 (unary -> NOT unary .)
    RPAREN          reduce using rule 61 (unary -> NOT unary .)


state 100

    (62) unary -> NEG unary .

    TIMES           reduce using rule 62 (unary -> NEG unary .)
    DIVIDE          reduce using rule 62 (unary -> NEG unary .)
    PLUS            reduce using rule 62 (unary -> NEG unary .)
    MINUS           reduce using rule 62 (unary -> NEG unary .)
    EQ              reduce using rule 62 (unary -> NEG unary .)
    NEQ             reduce using rule 62 (unary -> NEG unary .)
    AND             reduce using rule 62 (unary -> NEG unary .)
    SEMICOLON       reduce using rule 62 (unary -> NEG unary .)
    OR              reduce using rule 62 (unary -> NEG unary .)
    RBRACK          reduce using rule 62 (unary -> NEG unary .)
    RPAREN          reduce using rule 62 (unary -> NEG unary .)


state 101

    (64) factor -> LPAREN boolean . RPAREN
    (41) boolean -> boolean . OR join

    RPAREN          shift and go to state 117
    OR              shift and go to state 87


state 102

    (36) offset -> LBRACK boolean RBRACK . offset
    (36) offset -> . LBRACK boolean RBRACK offset
    (37) offset -> . empty
    (70) empty -> .

    LBRACK          shift and go to state 44
    EQUALS          reduce using rule 70 (empty -> .)
    TIMES           reduce using rule 70 (empty -> .)
    DIVIDE          reduce using rule 70 (empty -> .)
    PLUS            reduce using rule 70 (empty -> .)
    MINUS           reduce using rule 70 (empty -> .)
    EQ              reduce using rule 70 (empty -> .)
    NEQ             reduce using rule 70 (empty -> .)
    AND             reduce using rule 70 (empty -> .)
    SEMICOLON       reduce using rule 70 (empty -> .)
    OR              reduce using rule 70 (empty -> .)
    RBRACK          reduce using rule 70 (empty -> .)
    DOT             reduce using rule 70 (empty -> .)
    RPAREN          reduce using rule 70 (empty -> .)

    offset                         shift and go to state 118
    empty                          shift and go to state 119

state 103

    (38) field -> DOT factor field .

    EQUALS          reduce using rule 38 (field -> DOT factor field .)
    TIMES           reduce using rule 38 (field -> DOT factor field .)
    DIVIDE          reduce using rule 38 (field -> DOT factor field .)
    PLUS            reduce using rule 38 (field -> DOT factor field .)
    MINUS           reduce using rule 38 (field -> DOT factor field .)
    EQ              reduce using rule 38 (field -> DOT factor field .)
    NEQ             reduce using rule 38 (field -> DOT factor field .)
    AND             reduce using rule 38 (field -> DOT factor field .)
    SEMICOLON       reduce using rule 38 (field -> DOT factor field .)
    OR              reduce using rule 38 (field -> DOT factor field .)
    RBRACK          reduce using rule 38 (field -> DOT factor field .)
    DOT             reduce using rule 38 (field -> DOT factor field .)
    RPAREN          reduce using rule 38 (field -> DOT factor field .)


state 104

    (26) conditional -> IF LPAREN boolean RPAREN . statement conditional_aux
    (16) statement -> . local EQUALS boolean SEMICOLON
    (17) statement -> . conditional
    (18) statement -> . while_loop
    (19) statement -> . do_while_loop
    (20) statement -> . BREAK SEMICOLON
    (21) statement -> . print
    (22) statement -> . read
    (23) statement -> . block
    (31) local -> . HASH ID local_aux
    (32) local -> . ID local_aux
    (26) conditional -> . IF LPAREN boolean RPAREN statement conditional_aux
    (29) while_loop -> . WHILE LPAREN boolean RPAREN statement
    (30) do_while_loop -> . DO statement WHILE LPAREN boolean RPAREN SEMICOLON
    (24) print -> . PRINT LPAREN boolean RPAREN SEMICOLON
    (25) read -> . READ LPAREN local RPAREN SEMICOLON
    (2) block -> . LBRACE declaration statements RBRACE

    BREAK           shift and go to state 19
    HASH            shift and go to state 23
    ID              shift and go to state 24
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    DO              shift and go to state 27
    PRINT           shift and go to state 28
    READ            shift and go to state 29
    LBRACE          shift and go to state 3

    statement                      shift and go to state 120
    local                          shift and go to state 15
    conditional                    shift and go to state 16
    while_loop                     shift and go to state 17
    do_while_loop                  shift and go to state 18
    print                          shift and go to state 20
    read                           shift and go to state 21
    block                          shift and go to state 22

state 105

    (29) while_loop -> WHILE LPAREN boolean RPAREN . statement
    (16) statement -> . local EQUALS boolean SEMICOLON
    (17) statement -> . conditional
    (18) statement -> . while_loop
    (19) statement -> . do_while_loop
    (20) statement -> . BREAK SEMICOLON
    (21) statement -> . print
    (22) statement -> . read
    (23) statement -> . block
    (31) local -> . HASH ID local_aux
    (32) local -> . ID local_aux
    (26) conditional -> . IF LPAREN boolean RPAREN statement conditional_aux
    (29) while_loop -> . WHILE LPAREN boolean RPAREN statement
    (30) do_while_loop -> . DO statement WHILE LPAREN boolean RPAREN SEMICOLON
    (24) print -> . PRINT LPAREN boolean RPAREN SEMICOLON
    (25) read -> . READ LPAREN local RPAREN SEMICOLON
    (2) block -> . LBRACE declaration statements RBRACE

    BREAK           shift and go to state 19
    HASH            shift and go to state 23
    ID              shift and go to state 24
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    DO              shift and go to state 27
    PRINT           shift and go to state 28
    READ            shift and go to state 29
    LBRACE          shift and go to state 3

    statement                      shift and go to state 121
    local                          shift and go to state 15
    conditional                    shift and go to state 16
    while_loop                     shift and go to state 17
    do_while_loop                  shift and go to state 18
    print                          shift and go to state 20
    read                           shift and go to state 21
    block                          shift and go to state 22

state 106

    (30) do_while_loop -> DO statement WHILE LPAREN . boolean RPAREN SEMICOLON
    (40) boolean -> . join
    (41) boolean -> . boolean OR join
    (42) join -> . equality
    (43) join -> . join AND equality
    (44) equality -> . relational
    (45) equality -> . equality EQ relational
    (46) equality -> . equality NEQ relational
    (47) relational -> . expression
    (48) relational -> . relational_operator expression
    (53) expression -> . term expression_aux
    (49) relational_operator -> . LT
    (50) relational_operator -> . LE
    (51) relational_operator -> . GT
    (52) relational_operator -> . GE
    (58) term -> . unary
    (59) term -> . term TIMES unary
    (60) term -> . term DIVIDE unary
    (61) unary -> . NOT unary
    (62) unary -> . NEG unary
    (63) unary -> . factor
    (64) factor -> . LPAREN boolean RPAREN
    (65) factor -> . local
    (66) factor -> . NUMBER_INT
    (67) factor -> . NUMBER_FLOAT
    (68) factor -> . FALSE
    (69) factor -> . TRUE
    (31) local -> . HASH ID local_aux
    (32) local -> . ID local_aux

    LT              shift and go to state 62
    LE              shift and go to state 63
    GT              shift and go to state 64
    GE              shift and go to state 65
    NOT             shift and go to state 67
    NEG             shift and go to state 68
    LPAREN          shift and go to state 70
    NUMBER_INT      shift and go to state 71
    NUMBER_FLOAT    shift and go to state 72
    FALSE           shift and go to state 73
    TRUE            shift and go to state 74
    HASH            shift and go to state 23
    ID              shift and go to state 24

    boolean                        shift and go to state 122
    join                           shift and go to state 56
    equality                       shift and go to state 57
    relational                     shift and go to state 58
    expression                     shift and go to state 59
    relational_operator            shift and go to state 60
    term                           shift and go to state 61
    unary                          shift and go to state 66
    factor                         shift and go to state 69
    local                          shift and go to state 54

state 107

    (24) print -> PRINT LPAREN boolean RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 123


state 108

    (25) read -> READ LPAREN local RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 124


state 109

    (9) dimensions -> LBRACK NUMBER_INT RBRACK dimensions .

    ID              reduce using rule 9 (dimensions -> LBRACK NUMBER_INT RBRACK dimensions .)


state 110

    (41) boolean -> boolean OR join .
    (43) join -> join . AND equality

    SEMICOLON       reduce using rule 41 (boolean -> boolean OR join .)
    OR              reduce using rule 41 (boolean -> boolean OR join .)
    RBRACK          reduce using rule 41 (boolean -> boolean OR join .)
    RPAREN          reduce using rule 41 (boolean -> boolean OR join .)
    AND             shift and go to state 88


state 111

    (43) join -> join AND equality .
    (45) equality -> equality . EQ relational
    (46) equality -> equality . NEQ relational

    AND             reduce using rule 43 (join -> join AND equality .)
    SEMICOLON       reduce using rule 43 (join -> join AND equality .)
    OR              reduce using rule 43 (join -> join AND equality .)
    RBRACK          reduce using rule 43 (join -> join AND equality .)
    RPAREN          reduce using rule 43 (join -> join AND equality .)
    EQ              shift and go to state 89
    NEQ             shift and go to state 90


state 112

    (45) equality -> equality EQ relational .

    EQ              reduce using rule 45 (equality -> equality EQ relational .)
    NEQ             reduce using rule 45 (equality -> equality EQ relational .)
    AND             reduce using rule 45 (equality -> equality EQ relational .)
    SEMICOLON       reduce using rule 45 (equality -> equality EQ relational .)
    OR              reduce using rule 45 (equality -> equality EQ relational .)
    RBRACK          reduce using rule 45 (equality -> equality EQ relational .)
    RPAREN          reduce using rule 45 (equality -> equality EQ relational .)


state 113

    (46) equality -> equality NEQ relational .

    EQ              reduce using rule 46 (equality -> equality NEQ relational .)
    NEQ             reduce using rule 46 (equality -> equality NEQ relational .)
    AND             reduce using rule 46 (equality -> equality NEQ relational .)
    SEMICOLON       reduce using rule 46 (equality -> equality NEQ relational .)
    OR              reduce using rule 46 (equality -> equality NEQ relational .)
    RBRACK          reduce using rule 46 (equality -> equality NEQ relational .)
    RPAREN          reduce using rule 46 (equality -> equality NEQ relational .)


state 114

    (59) term -> term TIMES unary .

    TIMES           reduce using rule 59 (term -> term TIMES unary .)
    DIVIDE          reduce using rule 59 (term -> term TIMES unary .)
    PLUS            reduce using rule 59 (term -> term TIMES unary .)
    MINUS           reduce using rule 59 (term -> term TIMES unary .)
    EQ              reduce using rule 59 (term -> term TIMES unary .)
    NEQ             reduce using rule 59 (term -> term TIMES unary .)
    AND             reduce using rule 59 (term -> term TIMES unary .)
    SEMICOLON       reduce using rule 59 (term -> term TIMES unary .)
    OR              reduce using rule 59 (term -> term TIMES unary .)
    RBRACK          reduce using rule 59 (term -> term TIMES unary .)
    RPAREN          reduce using rule 59 (term -> term TIMES unary .)


state 115

    (60) term -> term DIVIDE unary .

    TIMES           reduce using rule 60 (term -> term DIVIDE unary .)
    DIVIDE          reduce using rule 60 (term -> term DIVIDE unary .)
    PLUS            reduce using rule 60 (term -> term DIVIDE unary .)
    MINUS           reduce using rule 60 (term -> term DIVIDE unary .)
    EQ              reduce using rule 60 (term -> term DIVIDE unary .)
    NEQ             reduce using rule 60 (term -> term DIVIDE unary .)
    AND             reduce using rule 60 (term -> term DIVIDE unary .)
    SEMICOLON       reduce using rule 60 (term -> term DIVIDE unary .)
    OR              reduce using rule 60 (term -> term DIVIDE unary .)
    RBRACK          reduce using rule 60 (term -> term DIVIDE unary .)
    RPAREN          reduce using rule 60 (term -> term DIVIDE unary .)


state 116

    (54) expression_aux -> expression_operator term . expression_aux
    (59) term -> term . TIMES unary
    (60) term -> term . DIVIDE unary
    (54) expression_aux -> . expression_operator term expression_aux
    (55) expression_aux -> . empty
    (56) expression_operator -> . PLUS
    (57) expression_operator -> . MINUS
    (70) empty -> .

    TIMES           shift and go to state 93
    DIVIDE          shift and go to state 94
    PLUS            shift and go to state 97
    MINUS           shift and go to state 98
    EQ              reduce using rule 70 (empty -> .)
    NEQ             reduce using rule 70 (empty -> .)
    AND             reduce using rule 70 (empty -> .)
    SEMICOLON       reduce using rule 70 (empty -> .)
    OR              reduce using rule 70 (empty -> .)
    RBRACK          reduce using rule 70 (empty -> .)
    RPAREN          reduce using rule 70 (empty -> .)

    expression_operator            shift and go to state 95
    expression_aux                 shift and go to state 125
    empty                          shift and go to state 96

state 117

    (64) factor -> LPAREN boolean RPAREN .

    TIMES           reduce using rule 64 (factor -> LPAREN boolean RPAREN .)
    DIVIDE          reduce using rule 64 (factor -> LPAREN boolean RPAREN .)
    PLUS            reduce using rule 64 (factor -> LPAREN boolean RPAREN .)
    MINUS           reduce using rule 64 (factor -> LPAREN boolean RPAREN .)
    EQ              reduce using rule 64 (factor -> LPAREN boolean RPAREN .)
    NEQ             reduce using rule 64 (factor -> LPAREN boolean RPAREN .)
    AND             reduce using rule 64 (factor -> LPAREN boolean RPAREN .)
    SEMICOLON       reduce using rule 64 (factor -> LPAREN boolean RPAREN .)
    OR              reduce using rule 64 (factor -> LPAREN boolean RPAREN .)
    RBRACK          reduce using rule 64 (factor -> LPAREN boolean RPAREN .)
    EQUALS          reduce using rule 64 (factor -> LPAREN boolean RPAREN .)
    DOT             reduce using rule 64 (factor -> LPAREN boolean RPAREN .)
    RPAREN          reduce using rule 64 (factor -> LPAREN boolean RPAREN .)


state 118

    (36) offset -> LBRACK boolean RBRACK offset .

    EQUALS          reduce using rule 36 (offset -> LBRACK boolean RBRACK offset .)
    TIMES           reduce using rule 36 (offset -> LBRACK boolean RBRACK offset .)
    DIVIDE          reduce using rule 36 (offset -> LBRACK boolean RBRACK offset .)
    PLUS            reduce using rule 36 (offset -> LBRACK boolean RBRACK offset .)
    MINUS           reduce using rule 36 (offset -> LBRACK boolean RBRACK offset .)
    EQ              reduce using rule 36 (offset -> LBRACK boolean RBRACK offset .)
    NEQ             reduce using rule 36 (offset -> LBRACK boolean RBRACK offset .)
    AND             reduce using rule 36 (offset -> LBRACK boolean RBRACK offset .)
    SEMICOLON       reduce using rule 36 (offset -> LBRACK boolean RBRACK offset .)
    OR              reduce using rule 36 (offset -> LBRACK boolean RBRACK offset .)
    RBRACK          reduce using rule 36 (offset -> LBRACK boolean RBRACK offset .)
    DOT             reduce using rule 36 (offset -> LBRACK boolean RBRACK offset .)
    RPAREN          reduce using rule 36 (offset -> LBRACK boolean RBRACK offset .)


state 119

    (37) offset -> empty .

    EQUALS          reduce using rule 37 (offset -> empty .)
    TIMES           reduce using rule 37 (offset -> empty .)
    DIVIDE          reduce using rule 37 (offset -> empty .)
    PLUS            reduce using rule 37 (offset -> empty .)
    MINUS           reduce using rule 37 (offset -> empty .)
    EQ              reduce using rule 37 (offset -> empty .)
    NEQ             reduce using rule 37 (offset -> empty .)
    AND             reduce using rule 37 (offset -> empty .)
    SEMICOLON       reduce using rule 37 (offset -> empty .)
    OR              reduce using rule 37 (offset -> empty .)
    RBRACK          reduce using rule 37 (offset -> empty .)
    DOT             reduce using rule 37 (offset -> empty .)
    RPAREN          reduce using rule 37 (offset -> empty .)


state 120

    (26) conditional -> IF LPAREN boolean RPAREN statement . conditional_aux
    (27) conditional_aux -> . ELSE statement
    (28) conditional_aux -> . empty
    (70) empty -> .

  ! shift/reduce conflict for ELSE resolved as shift
    ELSE            shift and go to state 127
    BREAK           reduce using rule 70 (empty -> .)
    HASH            reduce using rule 70 (empty -> .)
    ID              reduce using rule 70 (empty -> .)
    IF              reduce using rule 70 (empty -> .)
    WHILE           reduce using rule 70 (empty -> .)
    DO              reduce using rule 70 (empty -> .)
    PRINT           reduce using rule 70 (empty -> .)
    READ            reduce using rule 70 (empty -> .)
    LBRACE          reduce using rule 70 (empty -> .)
    RBRACE          reduce using rule 70 (empty -> .)

  ! ELSE            [ reduce using rule 70 (empty -> .) ]

    conditional_aux                shift and go to state 126
    empty                          shift and go to state 128

state 121

    (29) while_loop -> WHILE LPAREN boolean RPAREN statement .

    BREAK           reduce using rule 29 (while_loop -> WHILE LPAREN boolean RPAREN statement .)
    HASH            reduce using rule 29 (while_loop -> WHILE LPAREN boolean RPAREN statement .)
    ID              reduce using rule 29 (while_loop -> WHILE LPAREN boolean RPAREN statement .)
    IF              reduce using rule 29 (while_loop -> WHILE LPAREN boolean RPAREN statement .)
    WHILE           reduce using rule 29 (while_loop -> WHILE LPAREN boolean RPAREN statement .)
    DO              reduce using rule 29 (while_loop -> WHILE LPAREN boolean RPAREN statement .)
    PRINT           reduce using rule 29 (while_loop -> WHILE LPAREN boolean RPAREN statement .)
    READ            reduce using rule 29 (while_loop -> WHILE LPAREN boolean RPAREN statement .)
    LBRACE          reduce using rule 29 (while_loop -> WHILE LPAREN boolean RPAREN statement .)
    RBRACE          reduce using rule 29 (while_loop -> WHILE LPAREN boolean RPAREN statement .)
    ELSE            reduce using rule 29 (while_loop -> WHILE LPAREN boolean RPAREN statement .)


state 122

    (30) do_while_loop -> DO statement WHILE LPAREN boolean . RPAREN SEMICOLON
    (41) boolean -> boolean . OR join

    RPAREN          shift and go to state 129
    OR              shift and go to state 87


state 123

    (24) print -> PRINT LPAREN boolean RPAREN SEMICOLON .

    BREAK           reduce using rule 24 (print -> PRINT LPAREN boolean RPAREN SEMICOLON .)
    HASH            reduce using rule 24 (print -> PRINT LPAREN boolean RPAREN SEMICOLON .)
    ID              reduce using rule 24 (print -> PRINT LPAREN boolean RPAREN SEMICOLON .)
    IF              reduce using rule 24 (print -> PRINT LPAREN boolean RPAREN SEMICOLON .)
    WHILE           reduce using rule 24 (print -> PRINT LPAREN boolean RPAREN SEMICOLON .)
    DO              reduce using rule 24 (print -> PRINT LPAREN boolean RPAREN SEMICOLON .)
    PRINT           reduce using rule 24 (print -> PRINT LPAREN boolean RPAREN SEMICOLON .)
    READ            reduce using rule 24 (print -> PRINT LPAREN boolean RPAREN SEMICOLON .)
    LBRACE          reduce using rule 24 (print -> PRINT LPAREN boolean RPAREN SEMICOLON .)
    RBRACE          reduce using rule 24 (print -> PRINT LPAREN boolean RPAREN SEMICOLON .)
    ELSE            reduce using rule 24 (print -> PRINT LPAREN boolean RPAREN SEMICOLON .)


state 124

    (25) read -> READ LPAREN local RPAREN SEMICOLON .

    BREAK           reduce using rule 25 (read -> READ LPAREN local RPAREN SEMICOLON .)
    HASH            reduce using rule 25 (read -> READ LPAREN local RPAREN SEMICOLON .)
    ID              reduce using rule 25 (read -> READ LPAREN local RPAREN SEMICOLON .)
    IF              reduce using rule 25 (read -> READ LPAREN local RPAREN SEMICOLON .)
    WHILE           reduce using rule 25 (read -> READ LPAREN local RPAREN SEMICOLON .)
    DO              reduce using rule 25 (read -> READ LPAREN local RPAREN SEMICOLON .)
    PRINT           reduce using rule 25 (read -> READ LPAREN local RPAREN SEMICOLON .)
    READ            reduce using rule 25 (read -> READ LPAREN local RPAREN SEMICOLON .)
    LBRACE          reduce using rule 25 (read -> READ LPAREN local RPAREN SEMICOLON .)
    RBRACE          reduce using rule 25 (read -> READ LPAREN local RPAREN SEMICOLON .)
    ELSE            reduce using rule 25 (read -> READ LPAREN local RPAREN SEMICOLON .)


state 125

    (54) expression_aux -> expression_operator term expression_aux .

    EQ              reduce using rule 54 (expression_aux -> expression_operator term expression_aux .)
    NEQ             reduce using rule 54 (expression_aux -> expression_operator term expression_aux .)
    AND             reduce using rule 54 (expression_aux -> expression_operator term expression_aux .)
    SEMICOLON       reduce using rule 54 (expression_aux -> expression_operator term expression_aux .)
    OR              reduce using rule 54 (expression_aux -> expression_operator term expression_aux .)
    RBRACK          reduce using rule 54 (expression_aux -> expression_operator term expression_aux .)
    RPAREN          reduce using rule 54 (expression_aux -> expression_operator term expression_aux .)


state 126

    (26) conditional -> IF LPAREN boolean RPAREN statement conditional_aux .

    BREAK           reduce using rule 26 (conditional -> IF LPAREN boolean RPAREN statement conditional_aux .)
    HASH            reduce using rule 26 (conditional -> IF LPAREN boolean RPAREN statement conditional_aux .)
    ID              reduce using rule 26 (conditional -> IF LPAREN boolean RPAREN statement conditional_aux .)
    IF              reduce using rule 26 (conditional -> IF LPAREN boolean RPAREN statement conditional_aux .)
    WHILE           reduce using rule 26 (conditional -> IF LPAREN boolean RPAREN statement conditional_aux .)
    DO              reduce using rule 26 (conditional -> IF LPAREN boolean RPAREN statement conditional_aux .)
    PRINT           reduce using rule 26 (conditional -> IF LPAREN boolean RPAREN statement conditional_aux .)
    READ            reduce using rule 26 (conditional -> IF LPAREN boolean RPAREN statement conditional_aux .)
    LBRACE          reduce using rule 26 (conditional -> IF LPAREN boolean RPAREN statement conditional_aux .)
    RBRACE          reduce using rule 26 (conditional -> IF LPAREN boolean RPAREN statement conditional_aux .)
    ELSE            reduce using rule 26 (conditional -> IF LPAREN boolean RPAREN statement conditional_aux .)


state 127

    (27) conditional_aux -> ELSE . statement
    (16) statement -> . local EQUALS boolean SEMICOLON
    (17) statement -> . conditional
    (18) statement -> . while_loop
    (19) statement -> . do_while_loop
    (20) statement -> . BREAK SEMICOLON
    (21) statement -> . print
    (22) statement -> . read
    (23) statement -> . block
    (31) local -> . HASH ID local_aux
    (32) local -> . ID local_aux
    (26) conditional -> . IF LPAREN boolean RPAREN statement conditional_aux
    (29) while_loop -> . WHILE LPAREN boolean RPAREN statement
    (30) do_while_loop -> . DO statement WHILE LPAREN boolean RPAREN SEMICOLON
    (24) print -> . PRINT LPAREN boolean RPAREN SEMICOLON
    (25) read -> . READ LPAREN local RPAREN SEMICOLON
    (2) block -> . LBRACE declaration statements RBRACE

    BREAK           shift and go to state 19
    HASH            shift and go to state 23
    ID              shift and go to state 24
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    DO              shift and go to state 27
    PRINT           shift and go to state 28
    READ            shift and go to state 29
    LBRACE          shift and go to state 3

    statement                      shift and go to state 130
    local                          shift and go to state 15
    conditional                    shift and go to state 16
    while_loop                     shift and go to state 17
    do_while_loop                  shift and go to state 18
    print                          shift and go to state 20
    read                           shift and go to state 21
    block                          shift and go to state 22

state 128

    (28) conditional_aux -> empty .

    ELSE            reduce using rule 28 (conditional_aux -> empty .)
    BREAK           reduce using rule 28 (conditional_aux -> empty .)
    HASH            reduce using rule 28 (conditional_aux -> empty .)
    ID              reduce using rule 28 (conditional_aux -> empty .)
    IF              reduce using rule 28 (conditional_aux -> empty .)
    WHILE           reduce using rule 28 (conditional_aux -> empty .)
    DO              reduce using rule 28 (conditional_aux -> empty .)
    PRINT           reduce using rule 28 (conditional_aux -> empty .)
    READ            reduce using rule 28 (conditional_aux -> empty .)
    LBRACE          reduce using rule 28 (conditional_aux -> empty .)
    RBRACE          reduce using rule 28 (conditional_aux -> empty .)


state 129

    (30) do_while_loop -> DO statement WHILE LPAREN boolean RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 131


state 130

    (27) conditional_aux -> ELSE statement .

    ELSE            reduce using rule 27 (conditional_aux -> ELSE statement .)
    BREAK           reduce using rule 27 (conditional_aux -> ELSE statement .)
    HASH            reduce using rule 27 (conditional_aux -> ELSE statement .)
    ID              reduce using rule 27 (conditional_aux -> ELSE statement .)
    IF              reduce using rule 27 (conditional_aux -> ELSE statement .)
    WHILE           reduce using rule 27 (conditional_aux -> ELSE statement .)
    DO              reduce using rule 27 (conditional_aux -> ELSE statement .)
    PRINT           reduce using rule 27 (conditional_aux -> ELSE statement .)
    READ            reduce using rule 27 (conditional_aux -> ELSE statement .)
    LBRACE          reduce using rule 27 (conditional_aux -> ELSE statement .)
    RBRACE          reduce using rule 27 (conditional_aux -> ELSE statement .)


state 131

    (30) do_while_loop -> DO statement WHILE LPAREN boolean RPAREN SEMICOLON .

    BREAK           reduce using rule 30 (do_while_loop -> DO statement WHILE LPAREN boolean RPAREN SEMICOLON .)
    HASH            reduce using rule 30 (do_while_loop -> DO statement WHILE LPAREN boolean RPAREN SEMICOLON .)
    ID              reduce using rule 30 (do_while_loop -> DO statement WHILE LPAREN boolean RPAREN SEMICOLON .)
    IF              reduce using rule 30 (do_while_loop -> DO statement WHILE LPAREN boolean RPAREN SEMICOLON .)
    WHILE           reduce using rule 30 (do_while_loop -> DO statement WHILE LPAREN boolean RPAREN SEMICOLON .)
    DO              reduce using rule 30 (do_while_loop -> DO statement WHILE LPAREN boolean RPAREN SEMICOLON .)
    PRINT           reduce using rule 30 (do_while_loop -> DO statement WHILE LPAREN boolean RPAREN SEMICOLON .)
    READ            reduce using rule 30 (do_while_loop -> DO statement WHILE LPAREN boolean RPAREN SEMICOLON .)
    LBRACE          reduce using rule 30 (do_while_loop -> DO statement WHILE LPAREN boolean RPAREN SEMICOLON .)
    RBRACE          reduce using rule 30 (do_while_loop -> DO statement WHILE LPAREN boolean RPAREN SEMICOLON .)
    ELSE            reduce using rule 30 (do_while_loop -> DO statement WHILE LPAREN boolean RPAREN SEMICOLON .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for DOT in state 24 resolved as shift
WARNING: shift/reduce conflict for DOT in state 39 resolved as shift
WARNING: shift/reduce conflict for DOT in state 77 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 120 resolved as shift
WARNING: reduce/reduce conflict in state 43 resolved using rule (local_aux -> empty)
WARNING: rejected rule (offset -> empty) in state 43
